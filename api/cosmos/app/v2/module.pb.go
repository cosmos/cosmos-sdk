// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/app/v1alpha1/module.proto

package v2

import (
	fmt "fmt"
	"github.com/cosmos/gogoproto/proto"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModuleDescriptor describes an app module.
type ModuleDescriptor struct {
	// go_import names the package that should be imported by an app to load the
	// module in the runtime module registry. It is required to make debugging
	// of configuration errors easier for users.
	GoImport string `protobuf:"bytes,1,opt,name=go_import,json=goImport,proto3" json:"go_import,omitempty"`
	// use_package refers to a protobuf package that this module
	// uses and exposes to the world. In an app, only one module should "use"
	// or own a single protobuf package. It is assumed that the module uses
	// all of the .proto files in a single package.
	UsePackage []*PackageReference `protobuf:"bytes,2,rep,name=use_package,json=usePackage,proto3" json:"use_package,omitempty"`
	// can_migrate_from defines which module versions this module can migrate
	// state from. The framework will check that one module version is able to
	// migrate from a previous module version before attempting to update its
	// config. It is assumed that modules can transitively migrate from earlier
	// versions. For instance if v3 declares it can migrate from v2, and v2
	// declares it can migrate from v1, the framework knows how to migrate
	// from v1 to v3, assuming all 3 module versions are registered at runtime.
	CanMigrateFrom []*MigrateFromInfo `protobuf:"bytes,3,rep,name=can_migrate_from,json=canMigrateFrom,proto3" json:"can_migrate_from,omitempty"`
}

func (m *ModuleDescriptor) Reset()         { *m = ModuleDescriptor{} }
func (m *ModuleDescriptor) String() string { return proto.CompactTextString(m) }
func (*ModuleDescriptor) ProtoMessage()    {}
func (*ModuleDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e7eb8b9b8dcd164, []int{0}
}
func (m *ModuleDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleDescriptor.Merge(m, src)
}
func (m *ModuleDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ModuleDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleDescriptor proto.InternalMessageInfo

func (m *ModuleDescriptor) GetGoImport() string {
	if m != nil {
		return m.GoImport
	}
	return ""
}

func (m *ModuleDescriptor) GetUsePackage() []*PackageReference {
	if m != nil {
		return m.UsePackage
	}
	return nil
}

func (m *ModuleDescriptor) GetCanMigrateFrom() []*MigrateFromInfo {
	if m != nil {
		return m.CanMigrateFrom
	}
	return nil
}

// PackageReference is a reference to a protobuf package used by a module.
type PackageReference struct {
	// name is the fully-qualified name of the package.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// revision is the optional revision of the package that is being used.
	// Protobuf packages used in Cosmos should generally have a major version
	// as the last part of the package name, ex. foo.bar.baz.v1.
	// The revision of a package can be thought of as the minor version of a
	// package which has additional backwards compatible definitions that weren't
	// present in a previous version.
	//
	// A package should indicate its revision with a source code comment
	// above the package declaration in one of its files containing the
	// text "Revision N" where N is an integer revision. All packages start
	// at revision 0 the first time they are released in a module.
	//
	// When a new version of a module is released and items are added to existing
	// .proto files, these definitions should contain comments of the form
	// "Since: Revision N" where N is an integer revision.
	//
	// When the module runtime starts up, it will check the pinned proto
	// image and panic if there are runtime protobuf definitions that are not
	// in the pinned descriptor which do not have
	// a "Since Revision N" comment or have a "Since Revision N" comment where
	// N is <= to the revision specified here. This indicates that the protobuf
	// files have been updated, but the pinned file descriptor hasn't.
	//
	// If there are items in the pinned file descriptor with a revision
	// greater than the value indicated here, this will also cause a panic
	// as it may mean that the pinned descriptor for a legacy module has been
	// improperly updated or that there is some other versioning discrepancy.
	// Runtime protobuf definitions will also be checked for compatibility
	// with pinned file descriptors to make sure there are no incompatible changes.
	//
	// This behavior ensures that:
	//   - pinned proto images are up-to-date
	//   - protobuf files are carefully annotated with revision comments which
	//     are important good client UX
	//   - protobuf files are changed in backwards and forwards compatible ways
	Revision uint32 `protobuf:"varint,2,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *PackageReference) Reset()         { *m = PackageReference{} }
func (m *PackageReference) String() string { return proto.CompactTextString(m) }
func (*PackageReference) ProtoMessage()    {}
func (*PackageReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e7eb8b9b8dcd164, []int{1}
}
func (m *PackageReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackageReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackageReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackageReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageReference.Merge(m, src)
}
func (m *PackageReference) XXX_Size() int {
	return m.Size()
}
func (m *PackageReference) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageReference.DiscardUnknown(m)
}

var xxx_messageInfo_PackageReference proto.InternalMessageInfo

func (m *PackageReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageReference) GetRevision() uint32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

// MigrateFromInfo is information on a module version that a newer module
// can migrate from.
type MigrateFromInfo struct {
	// module is the fully-qualified protobuf name of the module config object
	// for the previous module version, ex: "cosmos.group.module.v1.Module".
	Module string `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
}

func (m *MigrateFromInfo) Reset()         { *m = MigrateFromInfo{} }
func (m *MigrateFromInfo) String() string { return proto.CompactTextString(m) }
func (*MigrateFromInfo) ProtoMessage()    {}
func (*MigrateFromInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e7eb8b9b8dcd164, []int{2}
}
func (m *MigrateFromInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateFromInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrateFromInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrateFromInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateFromInfo.Merge(m, src)
}
func (m *MigrateFromInfo) XXX_Size() int {
	return m.Size()
}
func (m *MigrateFromInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateFromInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateFromInfo proto.InternalMessageInfo

func (m *MigrateFromInfo) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

var E_Module = &proto.ExtensionDesc{
	ExtendedType:  (*descriptorpb.MessageOptions)(nil),
	ExtensionType: (*ModuleDescriptor)(nil),
	Field:         57193479,
	Name:          "cosmos.app.v1alpha1.module",
	Tag:           "bytes,57193479,opt,name=module",
	Filename:      "cosmos/app/v1alpha1/module.proto",
}

func init() {
	proto.RegisterType((*ModuleDescriptor)(nil), "cosmos.app.v1alpha1.ModuleDescriptor")
	proto.RegisterType((*PackageReference)(nil), "cosmos.app.v1alpha1.PackageReference")
	proto.RegisterType((*MigrateFromInfo)(nil), "cosmos.app.v1alpha1.MigrateFromInfo")
	proto.RegisterExtension(E_Module)
}

func init() { proto.RegisterFile("cosmos/app/v1alpha1/module.proto", fileDescriptor_0e7eb8b9b8dcd164) }

var fileDescriptor_0e7eb8b9b8dcd164 = []byte{
	// 438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xc1, 0x6a, 0xd4, 0x50,
	0x14, 0x86, 0xe7, 0x66, 0xa4, 0xb4, 0x77, 0x50, 0x87, 0x5b, 0xd4, 0xd0, 0x42, 0x1a, 0x06, 0x85,
	0x71, 0x73, 0x63, 0x75, 0x17, 0x57, 0x33, 0x95, 0x4a, 0x17, 0xa3, 0x43, 0x16, 0x22, 0x32, 0x30,
	0x9c, 0x66, 0xee, 0xc4, 0xd0, 0x49, 0xce, 0xe1, 0xde, 0x4c, 0x5f, 0xc1, 0xad, 0xcf, 0xd0, 0xa5,
	0x2f, 0xa2, 0xb8, 0xea, 0xd2, 0x95, 0x48, 0x66, 0x23, 0x3e, 0x85, 0x98, 0x9b, 0x14, 0x19, 0xd2,
	0xdd, 0x39, 0xff, 0xf9, 0xf2, 0xff, 0xc9, 0x4f, 0xb8, 0x1f, 0xa3, 0xc9, 0xd0, 0x04, 0x40, 0x14,
	0x5c, 0x1e, 0xc3, 0x8a, 0x3e, 0xc2, 0x71, 0x90, 0xe1, 0x62, 0xbd, 0x52, 0x92, 0x34, 0x16, 0x28,
	0xf6, 0x2d, 0x21, 0x81, 0x48, 0x36, 0xc4, 0x81, 0x9f, 0x20, 0x26, 0x2b, 0x15, 0x54, 0xc8, 0xf9,
	0x7a, 0x19, 0x2c, 0x94, 0x89, 0x75, 0x4a, 0x05, 0x6a, 0xfb, 0xd8, 0xe0, 0x2b, 0xe3, 0xfd, 0x49,
	0xe5, 0xf3, 0xea, 0xe6, 0x24, 0x0e, 0xf9, 0x5e, 0x82, 0xf3, 0x34, 0x23, 0xd4, 0x85, 0xcb, 0x7c,
	0x36, 0xdc, 0x8b, 0x76, 0x13, 0x3c, 0xab, 0x76, 0x71, 0xca, 0x7b, 0x6b, 0xa3, 0xe6, 0x04, 0xf1,
	0x05, 0x24, 0xca, 0x75, 0xfc, 0xee, 0xb0, 0xf7, 0xfc, 0x89, 0x6c, 0x89, 0x97, 0x53, 0xcb, 0x44,
	0x6a, 0xa9, 0xb4, 0xca, 0x63, 0x15, 0xf1, 0xb5, 0x51, 0xb5, 0x28, 0xde, 0xf0, 0x7e, 0x0c, 0xf9,
	0x3c, 0x4b, 0x13, 0x0d, 0x85, 0x9a, 0x2f, 0x35, 0x66, 0x6e, 0xb7, 0x32, 0x7b, 0xdc, 0x6a, 0x36,
	0xb1, 0xe0, 0xa9, 0xc6, 0xec, 0x2c, 0x5f, 0x62, 0x74, 0x2f, 0x86, 0xfc, 0x3f, 0x6d, 0x30, 0xe6,
	0xfd, 0xed, 0x3c, 0x21, 0xf8, 0x9d, 0x1c, 0x32, 0x55, 0x7f, 0x43, 0x35, 0x8b, 0x03, 0xbe, 0xab,
	0xd5, 0x65, 0x6a, 0x52, 0xcc, 0x5d, 0xc7, 0x67, 0xc3, 0xbb, 0xd1, 0xcd, 0x3e, 0x78, 0xca, 0xef,
	0x6f, 0xc5, 0x88, 0x87, 0x7c, 0xc7, 0xf6, 0x5c, 0x9b, 0xd4, 0x5b, 0x08, 0x8d, 0x2e, 0x8e, 0xa4,
	0x6d, 0x59, 0x36, 0x2d, 0xcb, 0x89, 0x32, 0x06, 0x12, 0xf5, 0x96, 0x8a, 0x14, 0x73, 0xe3, 0x7e,
	0xfa, 0x7d, 0x75, 0xe8, 0xb3, 0x5b, 0x5b, 0xda, 0xae, 0xbf, 0x89, 0x18, 0xff, 0x64, 0xdf, 0x4a,
	0x8f, 0x5d, 0x97, 0x1e, 0xfb, 0x55, 0x7a, 0xec, 0xf3, 0xc6, 0xeb, 0x5c, 0x6f, 0xbc, 0xce, 0x8f,
	0x8d, 0xd7, 0xe1, 0x8f, 0x62, 0xcc, 0xda, 0xcc, 0xc6, 0x3d, 0xeb, 0x36, 0xfd, 0xf7, 0x2a, 0x53,
	0xf6, 0xe1, 0x99, 0x65, 0xcc, 0xe2, 0x42, 0xa6, 0x18, 0x00, 0xa5, 0x41, 0xcb, 0x8f, 0xf4, 0x12,
	0x88, 0x9a, 0xf9, 0xca, 0xe9, 0x9e, 0x8c, 0xde, 0x7f, 0x71, 0xf6, 0x4f, 0xac, 0xf9, 0x88, 0x48,
	0xbe, 0xab, 0x6f, 0xdf, 0x1b, 0x75, 0x36, 0x22, 0x9a, 0x35, 0x6a, 0xe9, 0x1c, 0xb5, 0xa8, 0xb3,
	0xd7, 0xd3, 0xf1, 0x44, 0x15, 0xb0, 0x80, 0x02, 0xfe, 0x38, 0x0f, 0x2c, 0x11, 0x86, 0x23, 0xa2,
	0x30, 0x6c, 0x98, 0xf3, 0x9d, 0xaa, 0xb1, 0x17, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x14,
	0xde, 0x25, 0xde, 0x02, 0x00, 0x00,
}

func (m *ModuleDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanMigrateFrom) > 0 {
		for iNdEx := len(m.CanMigrateFrom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanMigrateFrom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UsePackage) > 0 {
		for iNdEx := len(m.UsePackage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsePackage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GoImport) > 0 {
		i -= len(m.GoImport)
		copy(dAtA[i:], m.GoImport)
		i = encodeVarintModule(dAtA, i, uint64(len(m.GoImport)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PackageReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackageReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		i = encodeVarintModule(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModule(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MigrateFromInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateFromInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateFromInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintModule(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModule(dAtA []byte, offset int, v uint64) int {
	offset -= sovModule(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ModuleDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GoImport)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	if len(m.UsePackage) > 0 {
		for _, e := range m.UsePackage {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	if len(m.CanMigrateFrom) > 0 {
		for _, e := range m.CanMigrateFrom {
			l = e.Size()
			n += 1 + l + sovModule(uint64(l))
		}
	}
	return n
}

func (m *PackageReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	if m.Revision != 0 {
		n += 1 + sovModule(uint64(m.Revision))
	}
	return n
}

func (m *MigrateFromInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovModule(uint64(l))
	}
	return n
}

func sovModule(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModule(x uint64) (n int) {
	return sovModule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ModuleDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoImport", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoImport = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePackage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsePackage = append(m.UsePackage, &PackageReference{})
			if err := m.UsePackage[len(m.UsePackage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanMigrateFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanMigrateFrom = append(m.CanMigrateFrom, &MigrateFromInfo{})
			if err := m.CanMigrateFrom[len(m.CanMigrateFrom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateFromInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateFromInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateFromInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModule
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModule
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModule
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModule        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModule          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModule = fmt.Errorf("proto: unexpected end of group")
)
