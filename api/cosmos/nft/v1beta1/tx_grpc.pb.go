// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: cosmos/nft/v1beta1/tx.proto

package nftv1beta1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_Send_FullMethodName              = "/cosmos.nft.v1beta1.Msg/Send"
	Msg_MintNFT_FullMethodName           = "/cosmos.nft.v1beta1.Msg/MintNFT"
	Msg_BurnNFT_FullMethodName           = "/cosmos.nft.v1beta1.Msg/BurnNFT"
	Msg_StakeNFT_FullMethodName          = "/cosmos.nft.v1beta1.Msg/StakeNFT"
	Msg_StreamNFT_FullMethodName         = "/cosmos.nft.v1beta1.Msg/StreamNFT"
	Msg_WithdrawRoyalties_FullMethodName = "/cosmos.nft.v1beta1.Msg/WithdrawRoyalties"
	Msg_ListNFT_FullMethodName           = "/cosmos.nft.v1beta1.Msg/ListNFT"
	Msg_BuyNFT_FullMethodName            = "/cosmos.nft.v1beta1.Msg/BuyNFT"
	Msg_DelistNFT_FullMethodName         = "/cosmos.nft.v1beta1.Msg/DelistNFT"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	// Send defines a method to send a nft from one account to another account.
	Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)
	// MintNFT defines a method to mint a new NFT.
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	// BurnNFT defines a method to burn an NFT.
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	// StakeNFT defines a method to stake an NFT.
	StakeNFT(ctx context.Context, in *MsgStakeNFT, opts ...grpc.CallOption) (*MsgStakeNFTResponse, error)
	// StreamNFT defines a method to stream an NFT and pay royalties.
	StreamNFT(ctx context.Context, in *MsgStreamNFT, opts ...grpc.CallOption) (*MsgStreamNFTResponse, error)
	// WithdrawRoyalties defines a method to withdraw accumulated royalties.
	WithdrawRoyalties(ctx context.Context, in *MsgWithdrawRoyalties, opts ...grpc.CallOption) (*MsgWithdrawRoyaltiesResponse, error)
	// ListNFT defines a method to list an NFT on the marketplace.
	ListNFT(ctx context.Context, in *MsgListNFT, opts ...grpc.CallOption) (*MsgListNFTResponse, error)
	// BuyNFT defines a method to buy an NFT from the marketplace.
	BuyNFT(ctx context.Context, in *MsgBuyNFT, opts ...grpc.CallOption) (*MsgBuyNFTResponse, error)
	DelistNFT(ctx context.Context, in *MsgDelistNFT, opts ...grpc.CallOption) (*MsgDelistNFTResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {
	out := new(MsgSendResponse)
	err := c.cc.Invoke(ctx, Msg_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, Msg_MintNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_BurnNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) StakeNFT(ctx context.Context, in *MsgStakeNFT, opts ...grpc.CallOption) (*MsgStakeNFTResponse, error) {
	out := new(MsgStakeNFTResponse)
	err := c.cc.Invoke(ctx, Msg_StakeNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) StreamNFT(ctx context.Context, in *MsgStreamNFT, opts ...grpc.CallOption) (*MsgStreamNFTResponse, error) {
	out := new(MsgStreamNFTResponse)
	err := c.cc.Invoke(ctx, Msg_StreamNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawRoyalties(ctx context.Context, in *MsgWithdrawRoyalties, opts ...grpc.CallOption) (*MsgWithdrawRoyaltiesResponse, error) {
	out := new(MsgWithdrawRoyaltiesResponse)
	err := c.cc.Invoke(ctx, Msg_WithdrawRoyalties_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ListNFT(ctx context.Context, in *MsgListNFT, opts ...grpc.CallOption) (*MsgListNFTResponse, error) {
	out := new(MsgListNFTResponse)
	err := c.cc.Invoke(ctx, Msg_ListNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BuyNFT(ctx context.Context, in *MsgBuyNFT, opts ...grpc.CallOption) (*MsgBuyNFTResponse, error) {
	out := new(MsgBuyNFTResponse)
	err := c.cc.Invoke(ctx, Msg_BuyNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DelistNFT(ctx context.Context, in *MsgDelistNFT, opts ...grpc.CallOption) (*MsgDelistNFTResponse, error) {
	out := new(MsgDelistNFTResponse)
	err := c.cc.Invoke(ctx, Msg_DelistNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	// Send defines a method to send a nft from one account to another account.
	Send(context.Context, *MsgSend) (*MsgSendResponse, error)
	// MintNFT defines a method to mint a new NFT.
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	// BurnNFT defines a method to burn an NFT.
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	// StakeNFT defines a method to stake an NFT.
	StakeNFT(context.Context, *MsgStakeNFT) (*MsgStakeNFTResponse, error)
	// StreamNFT defines a method to stream an NFT and pay royalties.
	StreamNFT(context.Context, *MsgStreamNFT) (*MsgStreamNFTResponse, error)
	// WithdrawRoyalties defines a method to withdraw accumulated royalties.
	WithdrawRoyalties(context.Context, *MsgWithdrawRoyalties) (*MsgWithdrawRoyaltiesResponse, error)
	// ListNFT defines a method to list an NFT on the marketplace.
	ListNFT(context.Context, *MsgListNFT) (*MsgListNFTResponse, error)
	// BuyNFT defines a method to buy an NFT from the marketplace.
	BuyNFT(context.Context, *MsgBuyNFT) (*MsgBuyNFTResponse, error)
	DelistNFT(context.Context, *MsgDelistNFT) (*MsgDelistNFTResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) Send(context.Context, *MsgSend) (*MsgSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedMsgServer) MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (UnimplementedMsgServer) BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (UnimplementedMsgServer) StakeNFT(context.Context, *MsgStakeNFT) (*MsgStakeNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StakeNFT not implemented")
}
func (UnimplementedMsgServer) StreamNFT(context.Context, *MsgStreamNFT) (*MsgStreamNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StreamNFT not implemented")
}
func (UnimplementedMsgServer) WithdrawRoyalties(context.Context, *MsgWithdrawRoyalties) (*MsgWithdrawRoyaltiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawRoyalties not implemented")
}
func (UnimplementedMsgServer) ListNFT(context.Context, *MsgListNFT) (*MsgListNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNFT not implemented")
}
func (UnimplementedMsgServer) BuyNFT(context.Context, *MsgBuyNFT) (*MsgBuyNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyNFT not implemented")
}
func (UnimplementedMsgServer) DelistNFT(context.Context, *MsgDelistNFT) (*MsgDelistNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelistNFT not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Send(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_StakeNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgStakeNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).StakeNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_StakeNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).StakeNFT(ctx, req.(*MsgStakeNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_StreamNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgStreamNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).StreamNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_StreamNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).StreamNFT(ctx, req.(*MsgStreamNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawRoyalties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawRoyalties)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawRoyalties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_WithdrawRoyalties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawRoyalties(ctx, req.(*MsgWithdrawRoyalties))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ListNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgListNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ListNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ListNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ListNFT(ctx, req.(*MsgListNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BuyNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBuyNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BuyNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BuyNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BuyNFT(ctx, req.(*MsgBuyNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DelistNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDelistNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DelistNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_DelistNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DelistNFT(ctx, req.(*MsgDelistNFT))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cosmos.nft.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Msg_Send_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "StakeNFT",
			Handler:    _Msg_StakeNFT_Handler,
		},
		{
			MethodName: "StreamNFT",
			Handler:    _Msg_StreamNFT_Handler,
		},
		{
			MethodName: "WithdrawRoyalties",
			Handler:    _Msg_WithdrawRoyalties_Handler,
		},
		{
			MethodName: "ListNFT",
			Handler:    _Msg_ListNFT_Handler,
		},
		{
			MethodName: "BuyNFT",
			Handler:    _Msg_BuyNFT_Handler,
		},
		{
			MethodName: "DelistNFT",
			Handler:    _Msg_DelistNFT_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cosmos/nft/v1beta1/tx.proto",
}
