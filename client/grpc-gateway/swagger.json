{
  "swagger": "2.0",
  "info": {
    "title": "Cosmos SDK - GRPC Gateway",
    "version": "1.0.0"
  },
  "paths": {
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "summary": "Account returns account details based on address.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account": {
                  "description": "account defines the account of the corresponding address.",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  }
                }
              },
              "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address defines the address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "AuthParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "max_memo_characters": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_sig_limit": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_size_cost_per_byte": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_ed25519": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_secp256k1": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "operationId": "AllBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "balances is the balances of all the coins."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/{denom}": {
      "get": {
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "description": "balance is the balance of the coin.",
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of x/bank module.",
        "operationId": "BankParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "enabled": {
                            "type": "boolean",
                            "format": "boolean"
                          }
                        },
                        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
                      }
                    },
                    "default_send_enabled": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  },
                  "description": "Params defines the parameters for the bank module."
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "summary": "TotalSupply queries the total supply of all coins.",
        "operationId": "TotalSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "supply": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "title": "supply is the supply of the coins"
                }
              },
              "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply/{denom}": {
      "get": {
        "summary": "SupplyOf queries the supply of a single coin.",
        "operationId": "SupplyOf",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "description": "amount is the supply of the coin.",
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/community_pool": {
      "get": {
        "summary": "CommunityPool queries the community pool coins.",
        "operationId": "CommunityPool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "pool": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "pool defines community pool's coins."
                }
              },
              "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
      "get": {
        "summary": "DelegationTotalRewards queries the total rewards accrued by a each validator.",
        "operationId": "DelegationTotalRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "reward": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                        }
                      }
                    },
                    "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
                  },
                  "description": "rewards defines all the rewards accrued by a delegator."
                },
                "total": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "total defines the sum of all the rewards."
                }
              },
              "description": "QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
      "get": {
        "summary": "DelegationRewards queries the total rewards accrued by a delegation.",
        "operationId": "DelegationRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "rewards defines the rewards accrued by a delegation."
                }
              },
              "description": "QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
      "get": {
        "summary": "DelegatorValidators queries the validators of a delegator.",
        "operationId": "DelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "validators defines the validators a delegator is delegating for."
                }
              },
              "description": "QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
      "get": {
        "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
        "operationId": "DelegatorWithdrawAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "withdraw_address": {
                  "type": "string",
                  "format": "byte",
                  "description": "withdraw_address defines the delegator address to query for."
                }
              },
              "description": "QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_address",
            "description": "delegator_address defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/params": {
      "get": {
        "summary": "Params queries params of the distribution module.",
        "operationId": "DistributionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "community_tax": {
                      "type": "string"
                    },
                    "base_proposer_reward": {
                      "type": "string"
                    },
                    "bonus_proposer_reward": {
                      "type": "string"
                    },
                    "withdraw_addr_enabled": {
                      "type": "boolean",
                      "format": "boolean"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
      "get": {
        "summary": "ValidatorCommission queries accumulated commission for a validator.",
        "operationId": "ValidatorCommission",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commission": {
                  "description": "commission defines the commision the validator received.",
                  "type": "object",
                  "properties": {
                    "commission": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  }
                }
              },
              "title": "QueryValidatorCommissionResponse is the response type for the Query/ValidatorCommission RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
      "get": {
        "summary": "ValidatorOutstandingRewards queries rewards of a validator address.",
        "operationId": "ValidatorOutstandingRewards",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "rewards": {
                  "type": "object",
                  "properties": {
                    "rewards": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
                }
              },
              "description": "QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
      "get": {
        "summary": "ValidatorSlashes queries slash events of a validator.",
        "operationId": "ValidatorSlashes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "slashes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "validator_period": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "fraction": {
                        "type": "string"
                      }
                    },
                    "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
                  },
                  "description": "slashes defines the slashes the validator received."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_address",
            "description": "validator_address defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "starting_height",
            "description": "starting_height defines the optional starting height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "ending_height",
            "description": "starting_height defines the optional ending height to query the slashes.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "summary": "AllEvidence queries all evidence.",
        "operationId": "AllEvidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "description": "evidence returns all evidences."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{evidence_hash}": {
      "get": {
        "summary": "Evidence queries evidence based on evidence hash.",
        "operationId": "Evidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "description": "evidence returns the requested evidence.",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  }
                }
              },
              "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "evidence_hash",
            "description": "evidence_hash defines the hash of the requested evidence.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/params/{params_type}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "voting_params": {
                  "description": "voting_params defines the parameters related to voting.",
                  "type": "object",
                  "properties": {
                    "voting_period": {
                      "type": "string",
                      "description": "Length of the voting period."
                    }
                  }
                },
                "deposit_params": {
                  "description": "deposit_params defines the parameters related to deposit.",
                  "type": "object",
                  "properties": {
                    "min_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "Minimum deposit for a proposal to enter voting period."
                    },
                    "max_deposit_period": {
                      "type": "string",
                      "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2 months."
                    }
                  }
                },
                "tally_params": {
                  "description": "tally_params defines the parameters related to tally.",
                  "type": "object",
                  "properties": {
                    "quorum": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum percentage of total stake needed to vote for a result to be considered valid."
                    },
                    "threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                    },
                    "veto_threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum value of Veto votes to Total votes ratio for proposal to be vetoed. Default value: 1/3."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "params_type",
            "description": "params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposals": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "content": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "status": {
                        "type": "string",
                        "enum": [
                          "PROPOSAL_STATUS_UNSPECIFIED",
                          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                          "PROPOSAL_STATUS_VOTING_PERIOD",
                          "PROPOSAL_STATUS_PASSED",
                          "PROPOSAL_STATUS_REJECTED",
                          "PROPOSAL_STATUS_FAILED"
                        ],
                        "default": "PROPOSAL_STATUS_UNSPECIFIED",
                        "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
                      },
                      "final_tally_result": {
                        "type": "object",
                        "properties": {
                          "yes": {
                            "type": "string"
                          },
                          "abstain": {
                            "type": "string"
                          },
                          "no": {
                            "type": "string"
                          },
                          "no_with_veto": {
                            "type": "string"
                          }
                        },
                        "description": "TallyResult defines a standard tally for a governance proposal."
                      },
                      "submit_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "deposit_end_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "total_deposit": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        }
                      },
                      "voting_start_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "voting_end_time": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "Proposal defines the core field members of a governance proposal."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_status",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposal": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "content": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "PROPOSAL_STATUS_UNSPECIFIED",
                        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                        "PROPOSAL_STATUS_VOTING_PERIOD",
                        "PROPOSAL_STATUS_PASSED",
                        "PROPOSAL_STATUS_REJECTED",
                        "PROPOSAL_STATUS_FAILED"
                      ],
                      "default": "PROPOSAL_STATUS_UNSPECIFIED",
                      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
                    },
                    "final_tally_result": {
                      "type": "object",
                      "properties": {
                        "yes": {
                          "type": "string"
                        },
                        "abstain": {
                          "type": "string"
                        },
                        "no": {
                          "type": "string"
                        },
                        "no_with_veto": {
                          "type": "string"
                        }
                      },
                      "description": "TallyResult defines a standard tally for a governance proposal."
                    },
                    "submit_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "deposit_end_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "total_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "voting_start_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "voting_end_time": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "description": "Proposal defines the core field members of a governance proposal."
                }
              },
              "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposits": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "depositor": {
                        "type": "string",
                        "format": "byte"
                      },
                      "amount": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        }
                      }
                    },
                    "description": "Deposit defines an amount deposited by an account address to an active proposal."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based proposalID, depositAddr.",
        "operationId": "Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposit": {
                  "description": "deposit defines the requested deposit.",
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "depositor": {
                      "type": "string",
                      "format": "byte"
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  }
                }
              },
              "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tally": {
                  "description": "tally defines the requested tally.",
                  "type": "object",
                  "properties": {
                    "yes": {
                      "type": "string"
                    },
                    "abstain": {
                      "type": "string"
                    },
                    "no": {
                      "type": "string"
                    },
                    "no_with_veto": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "votes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "voter": {
                        "type": "string",
                        "format": "byte"
                      },
                      "option": {
                        "type": "string",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ],
                        "default": "VOTE_OPTION_UNSPECIFIED",
                        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                      }
                    },
                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                  },
                  "description": "votes defined the queried votes."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "vote": {
                  "description": "vote defined the queried vote.",
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "voter": {
                      "type": "string",
                      "format": "byte"
                    },
                    "option": {
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED",
                      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
                    }
                  }
                }
              },
              "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the oter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/annual_provisions": {
      "get": {
        "summary": "AnnualProvisions current minting annual provisions value.",
        "operationId": "AnnualProvisions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "annual_provisions": {
                  "type": "string",
                  "format": "byte",
                  "description": "annual_provisions is the current minting annual provisions value."
                }
              },
              "description": "QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/inflation": {
      "get": {
        "summary": "Inflation returns the current minting inflation value.",
        "operationId": "Inflation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "inflation": {
                  "type": "string",
                  "format": "byte",
                  "description": "inflation is the current minting inflation value."
                }
              },
              "description": "QueryInflationResponse is the response type for the Query/Inflation RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/mint/v1beta1/params": {
      "get": {
        "summary": "Params returns the total set of minting parameters.",
        "operationId": "MintParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "mint_denom": {
                      "type": "string",
                      "title": "type of coin to mint"
                    },
                    "inflation_rate_change": {
                      "type": "string",
                      "title": "maximum annual change in inflation rate"
                    },
                    "inflation_max": {
                      "type": "string",
                      "title": "maximum inflation rate"
                    },
                    "inflation_min": {
                      "type": "string",
                      "title": "minimum inflation rate"
                    },
                    "goal_bonded": {
                      "type": "string",
                      "title": "goal of percent bonded atoms"
                    },
                    "blocks_per_year": {
                      "type": "string",
                      "format": "uint64",
                      "title": "expected blocks per year"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/params/v1beta1/params": {
      "get": {
        "summary": "Params queries a specific parameter of a module, given its subspace and key.",
        "operationId": "Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "param": {
                  "description": "param defines the queried parameter.",
                  "type": "object",
                  "properties": {
                    "subspace": {
                      "type": "string"
                    },
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "subspace",
            "description": "subspace defines the module to query the parameter for.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "key",
            "description": "key defines the key of the parameter in the subspace.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of slashing module",
        "operationId": "SlashingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "signed_blocks_window": {
                      "type": "string",
                      "format": "int64"
                    },
                    "min_signed_per_window": {
                      "type": "string",
                      "format": "byte"
                    },
                    "downtime_jail_duration": {
                      "type": "string"
                    },
                    "slash_fraction_double_sign": {
                      "type": "string",
                      "format": "byte"
                    },
                    "slash_fraction_downtime": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "Params represents the parameters used for by the slashing module."
                }
              },
              "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "summary": "SigningInfos queries signing info of all validators",
        "operationId": "SigningInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "start_height": {
                        "type": "string",
                        "format": "int64",
                        "title": "height at which validator was first a candidate OR was unjailed"
                      },
                      "index_offset": {
                        "type": "string",
                        "format": "int64",
                        "title": "index offset into signed block bit array"
                      },
                      "jailed_until": {
                        "type": "string",
                        "format": "date-time",
                        "title": "timestamp validator cannot be unjailed until"
                      },
                      "tombstoned": {
                        "type": "boolean",
                        "format": "boolean",
                        "title": "whether or not a validator has been tombstoned (killed out of validator set)"
                      },
                      "missed_blocks_counter": {
                        "type": "string",
                        "format": "int64",
                        "title": "missed blocks counter (to avoid scanning the array every time)"
                      }
                    },
                    "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity."
                  },
                  "title": "info is the signing info of all validators"
                },
                "pagination": {
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
      "get": {
        "summary": "SigningInfo queries the signing info of given cons address",
        "operationId": "SigningInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "val_signing_info": {
                  "title": "val_signing_info is the signing info of requested val cons address",
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "start_height": {
                      "type": "string",
                      "format": "int64",
                      "title": "height at which validator was first a candidate OR was unjailed"
                    },
                    "index_offset": {
                      "type": "string",
                      "format": "int64",
                      "title": "index offset into signed block bit array"
                    },
                    "jailed_until": {
                      "type": "string",
                      "format": "date-time",
                      "title": "timestamp validator cannot be unjailed until"
                    },
                    "tombstoned": {
                      "type": "boolean",
                      "format": "boolean",
                      "title": "whether or not a validator has been tombstoned (killed out of validator set)"
                    },
                    "missed_blocks_counter": {
                      "type": "string",
                      "format": "int64",
                      "title": "missed blocks counter (to avoid scanning the array every time)"
                    }
                  },
                  "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity."
                }
              },
              "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "cons_address",
            "description": "cons_address is the address to query signing info of",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
      "get": {
        "summary": "DelegatorDelegations queries all delegations of a given delegator address.",
        "operationId": "DelegatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "shares": {
                            "type": "string"
                          }
                        },
                        "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                      },
                      "balance": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "description": "DelegationResponse is equivalent to Delegation except that it contains a balance\nin addition to shares which is more suitable for client responses."
                  },
                  "description": "delegation_responses defines all the delegations' info of a delegator."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
      "get": {
        "summary": "Redelegations queries redelegations of given address.",
        "operationId": "Redelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "redelegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "redelegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_src_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_dst_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "entries": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "completion_time": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "initial_balance": {
                                  "type": "string"
                                },
                                "shares_dst": {
                                  "type": "string"
                                }
                              },
                              "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                            }
                          }
                        },
                        "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "redelegation_entry": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "completion_time": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "initial_balance": {
                                  "type": "string"
                                },
                                "shares_dst": {
                                  "type": "string"
                                }
                              },
                              "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                            },
                            "balance": {
                              "type": "string"
                            }
                          },
                          "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                        }
                      }
                    },
                    "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "src_validator_addr",
            "description": "src_validator_addr defines the validator address to redelegate from.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "dst_validator_addr",
            "description": "dst_validator_addr defines the validator address to redelegate to.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
      "get": {
        "summary": "DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.",
        "operationId": "DelegatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbonding_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "creation_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "completion_time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "initial_balance": {
                              "type": "string"
                            },
                            "balance": {
                              "type": "string"
                            }
                          },
                          "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                        }
                      }
                    },
                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
      "get": {
        "summary": "DelegatorValidators queries all validators info for given delegator address.",
        "operationId": "StakingDelegatorValidators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "consensus_pubkey": {
                        "type": "string"
                      },
                      "jailed": {
                        "type": "boolean",
                        "format": "boolean"
                      },
                      "status": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "tokens": {
                        "type": "string"
                      },
                      "delegator_shares": {
                        "type": "string"
                      },
                      "description": {
                        "type": "object",
                        "properties": {
                          "moniker": {
                            "type": "string"
                          },
                          "identity": {
                            "type": "string"
                          },
                          "website": {
                            "type": "string"
                          },
                          "security_contact": {
                            "type": "string"
                          },
                          "details": {
                            "type": "string"
                          }
                        },
                        "description": "Description defines a validator description."
                      },
                      "unbonding_height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "unbonding_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "commission": {
                        "type": "object",
                        "properties": {
                          "commission_rates": {
                            "type": "object",
                            "properties": {
                              "rate": {
                                "type": "string"
                              },
                              "max_rate": {
                                "type": "string"
                              },
                              "max_change_rate": {
                                "type": "string"
                              }
                            },
                            "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                          },
                          "update_time": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "Commission defines commission parameters for a given validator."
                      },
                      "min_self_delegation": {
                        "type": "string"
                      }
                    },
                    "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
                  },
                  "description": "validators defines the the validators' info of a delegator."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
      "get": {
        "summary": "DelegatorValidator queries validator info for given delegator validator pair.",
        "operationId": "DelegatorValidator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator": {
                  "description": "validator defines the the validator info.",
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "consensus_pubkey": {
                      "type": "string"
                    },
                    "jailed": {
                      "type": "boolean",
                      "format": "boolean"
                    },
                    "status": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "tokens": {
                      "type": "string"
                    },
                    "delegator_shares": {
                      "type": "string"
                    },
                    "description": {
                      "type": "object",
                      "properties": {
                        "moniker": {
                          "type": "string"
                        },
                        "identity": {
                          "type": "string"
                        },
                        "website": {
                          "type": "string"
                        },
                        "security_contact": {
                          "type": "string"
                        },
                        "details": {
                          "type": "string"
                        }
                      },
                      "description": "Description defines a validator description."
                    },
                    "unbonding_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "unbonding_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "commission": {
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string"
                            },
                            "max_rate": {
                              "type": "string"
                            },
                            "max_change_rate": {
                              "type": "string"
                            }
                          },
                          "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                        },
                        "update_time": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "Commission defines commission parameters for a given validator."
                    },
                    "min_self_delegation": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/historical_info/{height}": {
      "get": {
        "summary": "HistoricalInfo queries the historical info for given height.",
        "operationId": "HistoricalInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "hist": {
                  "description": "hist defines the historical info at the given height.",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "title": "prev block info",
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          }
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "valset": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "consensus_pubkey": {
                            "type": "string"
                          },
                          "jailed": {
                            "type": "boolean",
                            "format": "boolean"
                          },
                          "status": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "tokens": {
                            "type": "string"
                          },
                          "delegator_shares": {
                            "type": "string"
                          },
                          "description": {
                            "type": "object",
                            "properties": {
                              "moniker": {
                                "type": "string"
                              },
                              "identity": {
                                "type": "string"
                              },
                              "website": {
                                "type": "string"
                              },
                              "security_contact": {
                                "type": "string"
                              },
                              "details": {
                                "type": "string"
                              }
                            },
                            "description": "Description defines a validator description."
                          },
                          "unbonding_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "unbonding_time": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "commission": {
                            "type": "object",
                            "properties": {
                              "commission_rates": {
                                "type": "object",
                                "properties": {
                                  "rate": {
                                    "type": "string"
                                  },
                                  "max_rate": {
                                    "type": "string"
                                  },
                                  "max_change_rate": {
                                    "type": "string"
                                  }
                                },
                                "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                              },
                              "update_time": {
                                "type": "string",
                                "format": "date-time"
                              }
                            },
                            "description": "Commission defines commission parameters for a given validator."
                          },
                          "min_self_delegation": {
                            "type": "string"
                          }
                        },
                        "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
                      }
                    }
                  }
                }
              },
              "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "description": "height defines at which height to query the historical info.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/params": {
      "get": {
        "summary": "Parameters queries the staking parameters.",
        "operationId": "StakingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "unbonding_time": {
                      "type": "string"
                    },
                    "max_validators": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "max_entries": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "historical_entries": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "bond_denom": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/pool": {
      "get": {
        "summary": "Pool queries the pool info.",
        "operationId": "Pool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "pool": {
                  "description": "pool defines the pool info.",
                  "type": "object",
                  "properties": {
                    "not_bonded_tokens": {
                      "type": "string"
                    },
                    "bonded_tokens": {
                      "type": "string"
                    }
                  }
                }
              },
              "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators": {
      "get": {
        "summary": "Validators queries all validators that match the given status.",
        "operationId": "Validators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "consensus_pubkey": {
                        "type": "string"
                      },
                      "jailed": {
                        "type": "boolean",
                        "format": "boolean"
                      },
                      "status": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "tokens": {
                        "type": "string"
                      },
                      "delegator_shares": {
                        "type": "string"
                      },
                      "description": {
                        "type": "object",
                        "properties": {
                          "moniker": {
                            "type": "string"
                          },
                          "identity": {
                            "type": "string"
                          },
                          "website": {
                            "type": "string"
                          },
                          "security_contact": {
                            "type": "string"
                          },
                          "details": {
                            "type": "string"
                          }
                        },
                        "description": "Description defines a validator description."
                      },
                      "unbonding_height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "unbonding_time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "commission": {
                        "type": "object",
                        "properties": {
                          "commission_rates": {
                            "type": "object",
                            "properties": {
                              "rate": {
                                "type": "string"
                              },
                              "max_rate": {
                                "type": "string"
                              },
                              "max_change_rate": {
                                "type": "string"
                              }
                            },
                            "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                          },
                          "update_time": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "Commission defines commission parameters for a given validator."
                      },
                      "min_self_delegation": {
                        "type": "string"
                      }
                    },
                    "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
                  },
                  "description": "validators contains all the queried validators."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "status",
            "description": "status enables to query for validators matching a given status.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}": {
      "get": {
        "summary": "Validator queries validator info for given validator address.",
        "operationId": "Validator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator": {
                  "description": "validator defines the the validator info.",
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "consensus_pubkey": {
                      "type": "string"
                    },
                    "jailed": {
                      "type": "boolean",
                      "format": "boolean"
                    },
                    "status": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "tokens": {
                      "type": "string"
                    },
                    "delegator_shares": {
                      "type": "string"
                    },
                    "description": {
                      "type": "object",
                      "properties": {
                        "moniker": {
                          "type": "string"
                        },
                        "identity": {
                          "type": "string"
                        },
                        "website": {
                          "type": "string"
                        },
                        "security_contact": {
                          "type": "string"
                        },
                        "details": {
                          "type": "string"
                        }
                      },
                      "description": "Description defines a validator description."
                    },
                    "unbonding_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "unbonding_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "commission": {
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string"
                            },
                            "max_rate": {
                              "type": "string"
                            },
                            "max_change_rate": {
                              "type": "string"
                            }
                          },
                          "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                        },
                        "update_time": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "Commission defines commission parameters for a given validator."
                    },
                    "min_self_delegation": {
                      "type": "string"
                    }
                  }
                }
              },
              "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
      "get": {
        "summary": "ValidatorDelegations queries delegate info for given validator.",
        "operationId": "ValidatorDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegation": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "shares": {
                            "type": "string"
                          }
                        },
                        "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                      },
                      "balance": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "description": "DelegationResponse is equivalent to Delegation except that it contains a balance\nin addition to shares which is more suitable for client responses."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryValidatorDelegationsResponse is response type for the Query/ValidatorDelegations RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
      "get": {
        "summary": "Delegation queries delegate info for given validator delegator pair.",
        "operationId": "Delegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_response": {
                  "description": "delegation_responses defines the delegation info of a delegation.",
                  "type": "object",
                  "properties": {
                    "delegation": {
                      "type": "object",
                      "properties": {
                        "delegator_address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validator_address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "shares": {
                          "type": "string"
                        }
                      },
                      "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                    },
                    "balance": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  }
                }
              },
              "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
      "get": {
        "summary": "UnbondingDelegation queries unbonding info for given validator delegator pair.",
        "operationId": "UnbondingDelegation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbond": {
                  "description": "unbond defines the unbonding information of a delegation.",
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "validator_address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "entries": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "creation_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "completion_time": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "initial_balance": {
                            "type": "string"
                          },
                          "balance": {
                            "type": "string"
                          }
                        },
                        "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                      }
                    }
                  }
                }
              },
              "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "delegator_addr",
            "description": "delegator_addr defines the delegator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
      "get": {
        "summary": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
        "operationId": "ValidatorUnbondingDelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "unbonding_responses": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "delegator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "entries": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "creation_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "completion_time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "initial_balance": {
                              "type": "string"
                            },
                            "balance": {
                              "type": "string"
                            }
                          },
                          "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                        }
                      }
                    },
                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_addr",
            "description": "validator_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
      "get": {
        "summary": "AppliedPlan queries a previously applied upgrade plan by its name.",
        "operationId": "AppliedPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64",
                  "description": "height is the block height at which the plan was applied."
                }
              },
              "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "name is the name of the applied plan to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/current_plan": {
      "get": {
        "summary": "CurrentPlan queries the current upgrade plan.",
        "operationId": "CurrentPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "plan": {
                  "description": "plan is the current upgrade plan.",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any\nspecial \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been\nset in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height\nis reached and the software will exit."
                    },
                    "time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "The time after which the upgrade must be performed.\nLeave set to its zero value to use a pre-defined Height instead."
                    },
                    "height": {
                      "type": "string",
                      "format": "int64",
                      "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
                    },
                    "info": {
                      "type": "string",
                      "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
                    }
                  }
                }
              },
              "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels": {
      "get": {
        "summary": "Channels queries all the IBC channels of a chain.",
        "operationId": "Channels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of stored channels of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}": {
      "get": {
        "summary": "Channel queries an IBC Channel.",
        "operationId": "Channel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channel": {
                  "title": "channel associated with the request identifiers",
                  "type": "object",
                  "properties": {
                    "state": {
                      "title": "current state of the channel end",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN",
                        "STATE_CLOSED"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                    },
                    "ordering": {
                      "title": "whether the channel is ordered or unordered",
                      "type": "string",
                      "enum": [
                        "ORDER_NONE_UNSPECIFIED",
                        "ORDER_UNORDERED",
                        "ORDER_ORDERED"
                      ],
                      "default": "ORDER_NONE_UNSPECIFIED",
                      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                    },
                    "counterparty": {
                      "title": "counterparty channel end",
                      "type": "object",
                      "properties": {
                        "port_id": {
                          "type": "string",
                          "description": "port on the counterparty chain which owns the other end of the channel."
                        },
                        "channel_id": {
                          "type": "string",
                          "title": "channel end on the counterparty chain"
                        }
                      }
                    },
                    "connection_hops": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
                    },
                    "version": {
                      "type": "string",
                      "title": "opaque channel version, which is agreed upon during the handshake"
                    }
                  },
                  "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/client_state": {
      "get": {
        "summary": "ChannelClientState queries for the client state for the channel associated\nwith the provided channel identifiers.",
        "operationId": "ChannelClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "title": "client state",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/consensus_state/epoch/{epoch_number}/height/{epoch_height}": {
      "get": {
        "summary": "ChannelConsensusState queries for the consensus state for the channel\nassociated with the provided channel identifiers.",
        "operationId": "ChannelConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "title": "consensus state associated with the channel",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "epoch_number",
            "description": "epoch number of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "epoch_height",
            "description": "epoch height of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/next_sequence": {
      "get": {
        "summary": "NextSequenceReceive returns the next receive sequence for a given channel.",
        "operationId": "NextSequenceReceive",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "next_sequence_receive": {
                  "type": "string",
                  "format": "uint64",
                  "title": "next sequence receive number"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
      "get": {
        "summary": "PacketAcknowledgement queries a stored packet acknowledgement hash.",
        "operationId": "PacketAcknowledgement",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "acknowledgement": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof, its path and the height form which the\nproof was retrieved"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
      "get": {
        "summary": "PacketCommitments returns the all the packet commitments hashes associated\nwith a channel.",
        "operationId": "PacketCommitments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "port_id": {
                        "type": "string",
                        "description": "channel port identifier."
                      },
                      "channel_id": {
                        "type": "string",
                        "description": "channel unique identifier."
                      },
                      "sequence": {
                        "type": "string",
                        "format": "uint64",
                        "description": "packet sequence."
                      },
                      "hash": {
                        "type": "string",
                        "format": "byte",
                        "description": "packet commitment hash."
                      }
                    },
                    "description": "PacketAckCommitment defines the genesis type necessary to retrieve and store\nacknowlegements."
                  }
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/packet_acks/{acknowledgements}/unrelayed_packets": {
      "get": {
        "summary": "UnrelayedPackets returns all the unrelayed IBC packets associated with a\nchannel and sequences.",
        "operationId": "UnrelayedPackets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "title": "list of unrelayed packet sequences"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryUnrelayedPacketsResponse is the request type for the\nQuery/UnrelayedPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "packet_commitment_sequences",
            "description": "list of packet sequences",
            "in": "path",
            "required": true,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "csv",
            "minItems": 1
          },
          {
            "name": "acknowledgements",
            "description": "flag indicating if the return value is packet commitments or\nacknowledgements",
            "in": "path",
            "required": true,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
      "get": {
        "summary": "PacketCommitment queries a stored packet commitment hash.",
        "operationId": "PacketCommitment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitment": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof, its path and the height form which the proof was\nretrieved"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/channel/v1beta1/connections/{connection}/channels": {
      "get": {
        "summary": "ConnectionChannels queries all the channels associated with a connection\nend.",
        "operationId": "ConnectionChannels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of channels associated with a connection."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/client/v1beta1/client_states": {
      "get": {
        "summary": "ClientStates queries all the IBC light clients of a chain.",
        "operationId": "ClientStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "client_id": {
                        "type": "string",
                        "title": "client identifier"
                      },
                      "client_state": {
                        "title": "client state",
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    },
                    "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
                  },
                  "description": "list of stored ClientStates of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/client/v1beta1/client_states/{client_id}": {
      "get": {
        "summary": "ClientState queries an IBC light client.",
        "operationId": "ClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_state": {
                  "title": "client state associated with the request identifier",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client state unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/client/v1beta1/consensus_states/{client_id}": {
      "get": {
        "summary": "ConsensusStates queries all the consensus state associated with a given client.",
        "operationId": "ConsensusStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "title": "consensus states associated with the identifier"
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryConsensusStatesResponse is the response type for the Query/ConsensusStates RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/client/v1beta1/consensus_states/{client_id}/epoch/{epoch_number}/height/{epoch_height}": {
      "get": {
        "summary": "ConsensusState queries a consensus state associated with a client state at a given height.",
        "operationId": "ConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "title": "consensus state associated with the client identifier at the given height",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "epoch_number",
            "description": "consensus state epoch number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "epoch_height",
            "description": "consensus state epoch height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "latest_height",
            "description": "latest_height overrrides the height field and queries the latest stored ConsensusState.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/connection/v1beta1/client_connections/{client_id}": {
      "get": {
        "summary": "ClientConnections queries the connection paths associated with a client\nstate.",
        "operationId": "ClientConnections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection_paths": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "slice of all the connection paths associated with a client."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was generated",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier associated with a connection",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/connection/v1beta1/connections": {
      "get": {
        "summary": "Connections queries all the IBC connections of a chain.",
        "operationId": "Connections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string",
                        "description": "connection identifier."
                      },
                      "client_id": {
                        "type": "string",
                        "description": "client associated with this connection."
                      },
                      "versions": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
                      },
                      "state": {
                        "description": "current state of the connection end.",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                      },
                      "counterparty": {
                        "description": "counterparty chain associated with this connection.",
                        "type": "object",
                        "properties": {
                          "client_id": {
                            "type": "string",
                            "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                          },
                          "connection_id": {
                            "type": "string",
                            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                          },
                          "prefix": {
                            "title": "commitment merkle prefix of the counterparty chain",
                            "type": "object",
                            "properties": {
                              "key_prefix": {
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        }
                      }
                    },
                    "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
                  },
                  "description": "list of stored connections of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/connection/v1beta1/connections/{connection_id}": {
      "get": {
        "summary": "Connection queries an IBC connection end.",
        "operationId": "Connection",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection": {
                  "title": "connection associated with the request identifier",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "description": "client associated with this connection."
                    },
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
                    },
                    "state": {
                      "description": "current state of the connection end.",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                    },
                    "counterparty": {
                      "description": "counterparty chain associated with this connection.",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "type": "string",
                          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                        },
                        "connection_id": {
                          "type": "string",
                          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                        },
                        "prefix": {
                          "title": "commitment merkle prefix of the counterparty chain",
                          "type": "object",
                          "properties": {
                            "key_prefix": {
                              "type": "string",
                              "format": "byte"
                            }
                          }
                        }
                      }
                    }
                  },
                  "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one. NOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/connection/v1beta1/connections/{connection_id}/client_state": {
      "get": {
        "summary": "ConnectionClientState queries the client state associated with the\nconnection.",
        "operationId": "ConnectionClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "title": "client state",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/connection/v1beta1/connections/{connection_id}/consensus_state/epoch/{epoch_number}/height/{epoch_height}": {
      "get": {
        "summary": "ConnectionConsensusState queries the consensus state associated with the\nconnection.",
        "operationId": "ConnectionConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "title": "consensus state associated with the channel",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_path": {
                  "type": "string",
                  "title": "merkle proof path"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "epoch_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the epoch that the client is currently on"
                    },
                    "epoch_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given epoch"
                    }
                  },
                  "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
                }
              },
              "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "epoch_number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "epoch_height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc_transfer/v1beta1/denom_traces": {
      "get": {
        "summary": "DenomTraces queries all denomination traces.",
        "operationId": "DenomTraces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_traces": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "path": {
                        "type": "string",
                        "description": "path defines the chain of port/channel identifiers used for tracing the source of the fungible\ntoken."
                      },
                      "base_denom": {
                        "type": "string",
                        "description": "base denomination of the relayed fungible token."
                      }
                    },
                    "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing\ninformation path."
                  },
                  "description": "denom_traces returns all denominations trace information."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc_transfer/v1beta1/denom_traces/{hash}": {
      "get": {
        "summary": "DenomTrace queries a denomination trace information.",
        "operationId": "DenomTrace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_trace": {
                  "description": "denom_trace returns the requested denomination trace information.",
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "path defines the chain of port/channel identifiers used for tracing the source of the fungible\ntoken."
                    },
                    "base_denom": {
                      "type": "string",
                      "description": "base denomination of the relayed fungible token."
                    }
                  }
                }
              },
              "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash (in hex format) of the denomination trace information.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc_transfer/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters of the ibc-transfer module.",
        "operationId": "IBCTransferParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "send_enabled enables or disables all cross-chain token transfers from this chain."
                    },
                    "receive_enabled": {
                      "type": "boolean",
                      "format": "boolean",
                      "description": "receive_enabled enables or disables all cross-chain token transfers to this chain."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    }
  },
  "definitions": {
    "cosmos.auth.v1beta1.Params": {
      "type": "object",
      "properties": {
        "max_memo_characters": {
          "type": "string",
          "format": "uint64"
        },
        "tx_sig_limit": {
          "type": "string",
          "format": "uint64"
        },
        "tx_size_cost_per_byte": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_ed25519": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_secp256k1": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the auth module."
    },
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "account": {
          "description": "account defines the account of the corresponding address.",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          }
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "max_memo_characters": {
              "type": "string",
              "format": "uint64"
            },
            "tx_sig_limit": {
              "type": "string",
              "format": "uint64"
            },
            "tx_size_cost_per_byte": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_ed25519": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_secp256k1": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "google.protobuf.Any": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "grpc.gateway.runtime.Error": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        }
      }
    },
    "cosmos.bank.v1beta1.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "enabled": {
                "type": "boolean",
                "format": "boolean"
              }
            },
            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
          }
        },
        "default_send_enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method."
    },
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "description": "balance is the balance of the coin.",
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "enabled": {
                    "type": "boolean",
                    "format": "boolean"
                  }
                },
                "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
              }
            },
            "default_send_enabled": {
              "type": "boolean",
              "format": "boolean"
            }
          },
          "description": "Params defines the parameters for the bank module."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
    },
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "description": "amount is the supply of the coin.",
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          }
        }
      },
      "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
    },
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      "type": "object",
      "properties": {
        "supply": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "supply is the supply of the coins"
        }
      },
      "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC method"
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable)."
    },
    "cosmos.base.query.v1beta1.PageRequest": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "format": "byte",
          "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set."
        },
        "offset": {
          "type": "string",
          "format": "uint64",
          "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set."
        },
        "limit": {
          "type": "string",
          "format": "uint64",
          "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app."
        },
        "count_total": {
          "type": "boolean",
          "format": "boolean",
          "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs. count_total\nis only respected when offset is used. It is ignored when key is set."
        }
      },
      "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
      "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:"
    },
    "cosmos.base.query.v1beta1.PageResponse": {
      "type": "object",
      "properties": {
        "next_key": {
          "type": "string",
          "format": "byte",
          "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
        }
      },
      "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
    },
    "cosmos.base.v1beta1.Coin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.base.v1beta1.DecCoin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
    },
    "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
      "type": "object",
      "properties": {
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "reward": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
    },
    "cosmos.distribution.v1beta1.Params": {
      "type": "object",
      "properties": {
        "community_tax": {
          "type": "string"
        },
        "base_proposer_reward": {
          "type": "string"
        },
        "bonus_proposer_reward": {
          "type": "string"
        },
        "withdraw_addr_enabled": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "description": "Params defines the set of params for the distribution module."
    },
    "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "pool defines community pool's coins."
        }
      },
      "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "rewards defines the rewards accrued by a delegation."
        }
      },
      "description": "QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "validator_address": {
                "type": "string",
                "format": "byte"
              },
              "reward": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
          },
          "description": "rewards defines all the rewards accrued by a delegator."
        },
        "total": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "total defines the sum of all the rewards."
        }
      },
      "description": "QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "validators defines the validators a delegator is delegating for."
        }
      },
      "description": "QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method."
    },
    "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
      "type": "object",
      "properties": {
        "withdraw_address": {
          "type": "string",
          "format": "byte",
          "description": "withdraw_address defines the delegator address to query for."
        }
      },
      "description": "QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method."
    },
    "cosmos.distribution.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "community_tax": {
              "type": "string"
            },
            "base_proposer_reward": {
              "type": "string"
            },
            "bonus_proposer_reward": {
              "type": "string"
            },
            "withdraw_addr_enabled": {
              "type": "boolean",
              "format": "boolean"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
      "type": "object",
      "properties": {
        "commission": {
          "description": "commission defines the commision the validator received.",
          "type": "object",
          "properties": {
            "commission": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
              }
            }
          }
        }
      },
      "title": "QueryValidatorCommissionResponse is the response type for the Query/ValidatorCommission RPC method"
    },
    "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "object",
          "properties": {
            "rewards": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
              }
            }
          },
          "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
        }
      },
      "description": "QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method."
    },
    "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
      "type": "object",
      "properties": {
        "slashes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "validator_period": {
                "type": "string",
                "format": "uint64"
              },
              "fraction": {
                "type": "string"
              }
            },
            "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
          },
          "description": "slashes defines the slashes the validator received."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method."
    },
    "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
      "type": "object",
      "properties": {
        "commission": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "ValidatorAccumulatedCommission represents accumulated commission\nfor a validator kept as a running counter, can be withdrawn at any time."
    },
    "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
      "type": "object",
      "properties": {
        "rewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
    },
    "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
      "type": "object",
      "properties": {
        "validator_period": {
          "type": "string",
          "format": "uint64"
        },
        "fraction": {
          "type": "string"
        }
      },
      "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
    },
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "evidence returns all evidences."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method."
    },
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "description": "evidence returns the requested evidence.",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          }
        }
      },
      "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
    },
    "cosmos.gov.v1beta1.Deposit": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "depositor": {
          "type": "string",
          "format": "byte"
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active proposal."
    },
    "cosmos.gov.v1beta1.DepositParams": {
      "type": "object",
      "properties": {
        "min_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "max_deposit_period": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2 months."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1beta1.Proposal": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "content": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "status": {
          "type": "string",
          "enum": [
            "PROPOSAL_STATUS_UNSPECIFIED",
            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
            "PROPOSAL_STATUS_VOTING_PERIOD",
            "PROPOSAL_STATUS_PASSED",
            "PROPOSAL_STATUS_REJECTED",
            "PROPOSAL_STATUS_FAILED"
          ],
          "default": "PROPOSAL_STATUS_UNSPECIFIED",
          "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
        },
        "final_tally_result": {
          "type": "object",
          "properties": {
            "yes": {
              "type": "string"
            },
            "abstain": {
              "type": "string"
            },
            "no": {
              "type": "string"
            },
            "no_with_veto": {
              "type": "string"
            }
          },
          "description": "TallyResult defines a standard tally for a governance proposal."
        },
        "submit_time": {
          "type": "string",
          "format": "date-time"
        },
        "deposit_end_time": {
          "type": "string",
          "format": "date-time"
        },
        "total_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "voting_start_time": {
          "type": "string",
          "format": "date-time"
        },
        "voting_end_time": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1beta1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
    },
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "description": "deposit defines the requested deposit.",
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "depositor": {
              "type": "string",
              "format": "byte"
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            }
          }
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "depositor": {
                "type": "string",
                "format": "byte"
              },
              "amount": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active proposal."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "voting_params": {
          "description": "voting_params defines the parameters related to voting.",
          "type": "object",
          "properties": {
            "voting_period": {
              "type": "string",
              "description": "Length of the voting period."
            }
          }
        },
        "deposit_params": {
          "description": "deposit_params defines the parameters related to deposit.",
          "type": "object",
          "properties": {
            "min_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "Minimum deposit for a proposal to enter voting period."
            },
            "max_deposit_period": {
              "type": "string",
              "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2 months."
            }
          }
        },
        "tally_params": {
          "description": "tally_params defines the parameters related to tally.",
          "type": "object",
          "properties": {
            "quorum": {
              "type": "string",
              "format": "byte",
              "description": "Minimum percentage of total stake needed to vote for a result to be considered valid."
            },
            "threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
            },
            "veto_threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum value of Veto votes to Total votes ratio for proposal to be vetoed. Default value: 1/3."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "content": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "status": {
              "type": "string",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ],
              "default": "PROPOSAL_STATUS_UNSPECIFIED",
              "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
            },
            "final_tally_result": {
              "type": "object",
              "properties": {
                "yes": {
                  "type": "string"
                },
                "abstain": {
                  "type": "string"
                },
                "no": {
                  "type": "string"
                },
                "no_with_veto": {
                  "type": "string"
                }
              },
              "description": "TallyResult defines a standard tally for a governance proposal."
            },
            "submit_time": {
              "type": "string",
              "format": "date-time"
            },
            "deposit_end_time": {
              "type": "string",
              "format": "date-time"
            },
            "total_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "voting_start_time": {
              "type": "string",
              "format": "date-time"
            },
            "voting_end_time": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "Proposal defines the core field members of a governance proposal."
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "content": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "status": {
                "type": "string",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ],
                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed."
              },
              "final_tally_result": {
                "type": "object",
                "properties": {
                  "yes": {
                    "type": "string"
                  },
                  "abstain": {
                    "type": "string"
                  },
                  "no": {
                    "type": "string"
                  },
                  "no_with_veto": {
                    "type": "string"
                  }
                },
                "description": "TallyResult defines a standard tally for a governance proposal."
              },
              "submit_time": {
                "type": "string",
                "format": "date-time"
              },
              "deposit_end_time": {
                "type": "string",
                "format": "date-time"
              },
              "total_deposit": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "voting_start_time": {
                "type": "string",
                "format": "date-time"
              },
              "voting_end_time": {
                "type": "string",
                "format": "date-time"
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC method."
    },
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "description": "tally defines the requested tally.",
          "type": "object",
          "properties": {
            "yes": {
              "type": "string"
            },
            "abstain": {
              "type": "string"
            },
            "no": {
              "type": "string"
            },
            "no_with_veto": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "description": "vote defined the queried vote.",
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64"
            },
            "voter": {
              "type": "string",
              "format": "byte"
            },
            "option": {
              "type": "string",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                "VOTE_OPTION_YES",
                "VOTE_OPTION_ABSTAIN",
                "VOTE_OPTION_NO",
                "VOTE_OPTION_NO_WITH_VETO"
              ],
              "default": "VOTE_OPTION_UNSPECIFIED",
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
            }
          }
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64"
              },
              "voter": {
                "type": "string",
                "format": "byte"
              },
              "option": {
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED",
                "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          },
          "description": "votes defined the queried votes."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1beta1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "format": "byte",
          "description": "Minimum percentage of total stake needed to vote for a result to be considered valid."
        },
        "threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "veto_threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be vetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1beta1.TallyResult": {
      "type": "object",
      "properties": {
        "yes": {
          "type": "string"
        },
        "abstain": {
          "type": "string"
        },
        "no": {
          "type": "string"
        },
        "no_with_veto": {
          "type": "string"
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1beta1.Vote": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64"
        },
        "voter": {
          "type": "string",
          "format": "byte"
        },
        "option": {
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED",
          "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1beta1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1beta1.VotingParams": {
      "type": "object",
      "properties": {
        "voting_period": {
          "type": "string",
          "description": "Length of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.mint.v1beta1.Params": {
      "type": "object",
      "properties": {
        "mint_denom": {
          "type": "string",
          "title": "type of coin to mint"
        },
        "inflation_rate_change": {
          "type": "string",
          "title": "maximum annual change in inflation rate"
        },
        "inflation_max": {
          "type": "string",
          "title": "maximum inflation rate"
        },
        "inflation_min": {
          "type": "string",
          "title": "minimum inflation rate"
        },
        "goal_bonded": {
          "type": "string",
          "title": "goal of percent bonded atoms"
        },
        "blocks_per_year": {
          "type": "string",
          "format": "uint64",
          "title": "expected blocks per year"
        }
      },
      "description": "Params holds parameters for the mint module."
    },
    "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse": {
      "type": "object",
      "properties": {
        "annual_provisions": {
          "type": "string",
          "format": "byte",
          "description": "annual_provisions is the current minting annual provisions value."
        }
      },
      "description": "QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method."
    },
    "cosmos.mint.v1beta1.QueryInflationResponse": {
      "type": "object",
      "properties": {
        "inflation": {
          "type": "string",
          "format": "byte",
          "description": "inflation is the current minting inflation value."
        }
      },
      "description": "QueryInflationResponse is the response type for the Query/Inflation RPC method."
    },
    "cosmos.mint.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "mint_denom": {
              "type": "string",
              "title": "type of coin to mint"
            },
            "inflation_rate_change": {
              "type": "string",
              "title": "maximum annual change in inflation rate"
            },
            "inflation_max": {
              "type": "string",
              "title": "maximum inflation rate"
            },
            "inflation_min": {
              "type": "string",
              "title": "minimum inflation rate"
            },
            "goal_bonded": {
              "type": "string",
              "title": "goal of percent bonded atoms"
            },
            "blocks_per_year": {
              "type": "string",
              "format": "uint64",
              "title": "expected blocks per year"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.params.v1beta1.ParamChange": {
      "type": "object",
      "properties": {
        "subspace": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "ParamChange defines an individual parameter change, for use in ParameterChangeProposal."
    },
    "cosmos.params.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "param": {
          "description": "param defines the queried parameter.",
          "type": "object",
          "properties": {
            "subspace": {
              "type": "string"
            },
            "key": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.slashing.v1beta1.Params": {
      "type": "object",
      "properties": {
        "signed_blocks_window": {
          "type": "string",
          "format": "int64"
        },
        "min_signed_per_window": {
          "type": "string",
          "format": "byte"
        },
        "downtime_jail_duration": {
          "type": "string"
        },
        "slash_fraction_double_sign": {
          "type": "string",
          "format": "byte"
        },
        "slash_fraction_downtime": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Params represents the parameters used for by the slashing module."
    },
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "signed_blocks_window": {
              "type": "string",
              "format": "int64"
            },
            "min_signed_per_window": {
              "type": "string",
              "format": "byte"
            },
            "downtime_jail_duration": {
              "type": "string"
            },
            "slash_fraction_double_sign": {
              "type": "string",
              "format": "byte"
            },
            "slash_fraction_downtime": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Params represents the parameters used for by the slashing module."
        }
      },
      "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      "type": "object",
      "properties": {
        "val_signing_info": {
          "title": "val_signing_info is the signing info of requested val cons address",
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "format": "byte"
            },
            "start_height": {
              "type": "string",
              "format": "int64",
              "title": "height at which validator was first a candidate OR was unjailed"
            },
            "index_offset": {
              "type": "string",
              "format": "int64",
              "title": "index offset into signed block bit array"
            },
            "jailed_until": {
              "type": "string",
              "format": "date-time",
              "title": "timestamp validator cannot be unjailed until"
            },
            "tombstoned": {
              "type": "boolean",
              "format": "boolean",
              "title": "whether or not a validator has been tombstoned (killed out of validator set)"
            },
            "missed_blocks_counter": {
              "type": "string",
              "format": "int64",
              "title": "missed blocks counter (to avoid scanning the array every time)"
            }
          },
          "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity."
        }
      },
      "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC method"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      "type": "object",
      "properties": {
        "info": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "format": "byte"
              },
              "start_height": {
                "type": "string",
                "format": "int64",
                "title": "height at which validator was first a candidate OR was unjailed"
              },
              "index_offset": {
                "type": "string",
                "format": "int64",
                "title": "index offset into signed block bit array"
              },
              "jailed_until": {
                "type": "string",
                "format": "date-time",
                "title": "timestamp validator cannot be unjailed until"
              },
              "tombstoned": {
                "type": "boolean",
                "format": "boolean",
                "title": "whether or not a validator has been tombstoned (killed out of validator set)"
              },
              "missed_blocks_counter": {
                "type": "string",
                "format": "int64",
                "title": "missed blocks counter (to avoid scanning the array every time)"
              }
            },
            "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity."
          },
          "title": "info is the signing info of all validators"
        },
        "pagination": {
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC method"
    },
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "start_height": {
          "type": "string",
          "format": "int64",
          "title": "height at which validator was first a candidate OR was unjailed"
        },
        "index_offset": {
          "type": "string",
          "format": "int64",
          "title": "index offset into signed block bit array"
        },
        "jailed_until": {
          "type": "string",
          "format": "date-time",
          "title": "timestamp validator cannot be unjailed until"
        },
        "tombstoned": {
          "type": "boolean",
          "format": "boolean",
          "title": "whether or not a validator has been tombstoned (killed out of validator set)"
        },
        "missed_blocks_counter": {
          "type": "string",
          "format": "int64",
          "title": "missed blocks counter (to avoid scanning the array every time)"
        }
      },
      "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their liveness activity."
    },
    "cosmos.staking.v1beta1.Commission": {
      "type": "object",
      "properties": {
        "commission_rates": {
          "type": "object",
          "properties": {
            "rate": {
              "type": "string"
            },
            "max_rate": {
              "type": "string"
            },
            "max_change_rate": {
              "type": "string"
            }
          },
          "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
        },
        "update_time": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "Commission defines commission parameters for a given validator."
    },
    "cosmos.staking.v1beta1.CommissionRates": {
      "type": "object",
      "properties": {
        "rate": {
          "type": "string"
        },
        "max_rate": {
          "type": "string"
        },
        "max_change_rate": {
          "type": "string"
        }
      },
      "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
    },
    "cosmos.staking.v1beta1.Delegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "shares": {
          "type": "string"
        }
      },
      "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
    },
    "cosmos.staking.v1beta1.DelegationResponse": {
      "type": "object",
      "properties": {
        "delegation": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "shares": {
              "type": "string"
            }
          },
          "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
        },
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "DelegationResponse is equivalent to Delegation except that it contains a balance\nin addition to shares which is more suitable for client responses."
    },
    "cosmos.staking.v1beta1.Description": {
      "type": "object",
      "properties": {
        "moniker": {
          "type": "string"
        },
        "identity": {
          "type": "string"
        },
        "website": {
          "type": "string"
        },
        "security_contact": {
          "type": "string"
        },
        "details": {
          "type": "string"
        }
      },
      "description": "Description defines a validator description."
    },
    "cosmos.staking.v1beta1.HistoricalInfo": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "title": "prev block info",
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              }
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a Tendermint block header."
        },
        "valset": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "format": "byte"
              },
              "consensus_pubkey": {
                "type": "string"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean"
              },
              "status": {
                "type": "integer",
                "format": "int32"
              },
              "tokens": {
                "type": "string"
              },
              "delegator_shares": {
                "type": "string"
              },
              "description": {
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string"
                  },
                  "identity": {
                    "type": "string"
                  },
                  "website": {
                    "type": "string"
                  },
                  "security_contact": {
                    "type": "string"
                  },
                  "details": {
                    "type": "string"
                  }
                },
                "description": "Description defines a validator description."
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64"
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time"
              },
              "commission": {
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string"
                      },
                      "max_rate": {
                        "type": "string"
                      },
                      "max_change_rate": {
                        "type": "string"
                      }
                    },
                    "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "Commission defines commission parameters for a given validator."
              },
              "min_self_delegation": {
                "type": "string"
              }
            },
            "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
          }
        }
      },
      "description": "HistoricalInfo contains header and validator information for a given block. It is stored\nas part of staking module's state, which persists the `n` most recent HistoricalInfo\n(`n` is set by the staking module's `historical_entries` parameter)."
    },
    "cosmos.staking.v1beta1.Params": {
      "type": "object",
      "properties": {
        "unbonding_time": {
          "type": "string"
        },
        "max_validators": {
          "type": "integer",
          "format": "int64"
        },
        "max_entries": {
          "type": "integer",
          "format": "int64"
        },
        "historical_entries": {
          "type": "integer",
          "format": "int64"
        },
        "bond_denom": {
          "type": "string"
        }
      },
      "description": "Params defines the parameters for the staking module."
    },
    "cosmos.staking.v1beta1.Pool": {
      "type": "object",
      "properties": {
        "not_bonded_tokens": {
          "type": "string"
        },
        "bonded_tokens": {
          "type": "string"
        }
      },
      "description": "Pool is used for tracking bonded and not-bonded token supply of the bond denomination."
    },
    "cosmos.staking.v1beta1.QueryDelegationResponse": {
      "type": "object",
      "properties": {
        "delegation_response": {
          "description": "delegation_responses defines the delegation info of a delegation.",
          "type": "object",
          "properties": {
            "delegation": {
              "type": "object",
              "properties": {
                "delegator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "validator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "shares": {
                  "type": "string"
                }
              },
              "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
            },
            "balance": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          }
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "shares": {
                    "type": "string"
                  }
                },
                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DelegationResponse is equivalent to Delegation except that it contains a balance\nin addition to shares which is more suitable for client responses."
          },
          "description": "delegation_responses defines all the delegations' info of a delegator."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbonding_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "format": "byte"
              },
              "validator_address": {
                "type": "string",
                "format": "byte"
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "completion_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "initial_balance": {
                      "type": "string"
                    },
                    "balance": {
                      "type": "string"
                    }
                  },
                  "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                }
              }
            },
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "description": "validator defines the the validator info.",
          "type": "object",
          "properties": {
            "operator_address": {
              "type": "string",
              "format": "byte"
            },
            "consensus_pubkey": {
              "type": "string"
            },
            "jailed": {
              "type": "boolean",
              "format": "boolean"
            },
            "status": {
              "type": "integer",
              "format": "int32"
            },
            "tokens": {
              "type": "string"
            },
            "delegator_shares": {
              "type": "string"
            },
            "description": {
              "type": "object",
              "properties": {
                "moniker": {
                  "type": "string"
                },
                "identity": {
                  "type": "string"
                },
                "website": {
                  "type": "string"
                },
                "security_contact": {
                  "type": "string"
                },
                "details": {
                  "type": "string"
                }
              },
              "description": "Description defines a validator description."
            },
            "unbonding_height": {
              "type": "string",
              "format": "int64"
            },
            "unbonding_time": {
              "type": "string",
              "format": "date-time"
            },
            "commission": {
              "type": "object",
              "properties": {
                "commission_rates": {
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string"
                    },
                    "max_rate": {
                      "type": "string"
                    },
                    "max_change_rate": {
                      "type": "string"
                    }
                  },
                  "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                },
                "update_time": {
                  "type": "string",
                  "format": "date-time"
                }
              },
              "description": "Commission defines commission parameters for a given validator."
            },
            "min_self_delegation": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method."
    },
    "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "format": "byte"
              },
              "consensus_pubkey": {
                "type": "string"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean"
              },
              "status": {
                "type": "integer",
                "format": "int32"
              },
              "tokens": {
                "type": "string"
              },
              "delegator_shares": {
                "type": "string"
              },
              "description": {
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string"
                  },
                  "identity": {
                    "type": "string"
                  },
                  "website": {
                    "type": "string"
                  },
                  "security_contact": {
                    "type": "string"
                  },
                  "details": {
                    "type": "string"
                  }
                },
                "description": "Description defines a validator description."
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64"
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time"
              },
              "commission": {
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string"
                      },
                      "max_rate": {
                        "type": "string"
                      },
                      "max_change_rate": {
                        "type": "string"
                      }
                    },
                    "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "Commission defines commission parameters for a given validator."
              },
              "min_self_delegation": {
                "type": "string"
              }
            },
            "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
          },
          "description": "validators defines the the validators' info of a delegator."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method."
    },
    "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
      "type": "object",
      "properties": {
        "hist": {
          "description": "hist defines the historical info at the given height.",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "title": "prev block info",
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  }
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "valset": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_pubkey": {
                    "type": "string"
                  },
                  "jailed": {
                    "type": "boolean",
                    "format": "boolean"
                  },
                  "status": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "tokens": {
                    "type": "string"
                  },
                  "delegator_shares": {
                    "type": "string"
                  },
                  "description": {
                    "type": "object",
                    "properties": {
                      "moniker": {
                        "type": "string"
                      },
                      "identity": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string"
                      },
                      "security_contact": {
                        "type": "string"
                      },
                      "details": {
                        "type": "string"
                      }
                    },
                    "description": "Description defines a validator description."
                  },
                  "unbonding_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "unbonding_time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "commission": {
                    "type": "object",
                    "properties": {
                      "commission_rates": {
                        "type": "object",
                        "properties": {
                          "rate": {
                            "type": "string"
                          },
                          "max_rate": {
                            "type": "string"
                          },
                          "max_change_rate": {
                            "type": "string"
                          }
                        },
                        "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                      },
                      "update_time": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "Commission defines commission parameters for a given validator."
                  },
                  "min_self_delegation": {
                    "type": "string"
                  }
                },
                "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
              }
            }
          }
        }
      },
      "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method."
    },
    "cosmos.staking.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "unbonding_time": {
              "type": "string"
            },
            "max_validators": {
              "type": "integer",
              "format": "int64"
            },
            "max_entries": {
              "type": "integer",
              "format": "int64"
            },
            "historical_entries": {
              "type": "integer",
              "format": "int64"
            },
            "bond_denom": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "cosmos.staking.v1beta1.QueryPoolResponse": {
      "type": "object",
      "properties": {
        "pool": {
          "description": "pool defines the pool info.",
          "type": "object",
          "properties": {
            "not_bonded_tokens": {
              "type": "string"
            },
            "bonded_tokens": {
              "type": "string"
            }
          }
        }
      },
      "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
    },
    "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
      "type": "object",
      "properties": {
        "redelegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "redelegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_src_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_dst_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "entries": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "creation_height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "completion_time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "initial_balance": {
                          "type": "string"
                        },
                        "shares_dst": {
                          "type": "string"
                        }
                      },
                      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                    }
                  }
                },
                "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "redelegation_entry": {
                      "type": "object",
                      "properties": {
                        "creation_height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "completion_time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "initial_balance": {
                          "type": "string"
                        },
                        "shares_dst": {
                          "type": "string"
                        }
                      },
                      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                    },
                    "balance": {
                      "type": "string"
                    }
                  },
                  "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                }
              }
            },
            "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
      "type": "object",
      "properties": {
        "unbond": {
          "description": "unbond defines the unbonding information of a delegation.",
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "entries": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "initial_balance": {
                    "type": "string"
                  },
                  "balance": {
                    "type": "string"
                  }
                },
                "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
              }
            }
          }
        }
      },
      "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
      "type": "object",
      "properties": {
        "delegation_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "shares": {
                    "type": "string"
                  }
                },
                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DelegationResponse is equivalent to Delegation except that it contains a balance\nin addition to shares which is more suitable for client responses."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryValidatorDelegationsResponse is response type for the Query/ValidatorDelegations RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "description": "validator defines the the validator info.",
          "type": "object",
          "properties": {
            "operator_address": {
              "type": "string",
              "format": "byte"
            },
            "consensus_pubkey": {
              "type": "string"
            },
            "jailed": {
              "type": "boolean",
              "format": "boolean"
            },
            "status": {
              "type": "integer",
              "format": "int32"
            },
            "tokens": {
              "type": "string"
            },
            "delegator_shares": {
              "type": "string"
            },
            "description": {
              "type": "object",
              "properties": {
                "moniker": {
                  "type": "string"
                },
                "identity": {
                  "type": "string"
                },
                "website": {
                  "type": "string"
                },
                "security_contact": {
                  "type": "string"
                },
                "details": {
                  "type": "string"
                }
              },
              "description": "Description defines a validator description."
            },
            "unbonding_height": {
              "type": "string",
              "format": "int64"
            },
            "unbonding_time": {
              "type": "string",
              "format": "date-time"
            },
            "commission": {
              "type": "object",
              "properties": {
                "commission_rates": {
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string"
                    },
                    "max_rate": {
                      "type": "string"
                    },
                    "max_change_rate": {
                      "type": "string"
                    }
                  },
                  "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                },
                "update_time": {
                  "type": "string",
                  "format": "date-time"
                }
              },
              "description": "Commission defines commission parameters for a given validator."
            },
            "min_self_delegation": {
              "type": "string"
            }
          }
        }
      },
      "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
    },
    "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
      "type": "object",
      "properties": {
        "unbonding_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "format": "byte"
              },
              "validator_address": {
                "type": "string",
                "format": "byte"
              },
              "entries": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "completion_time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "initial_balance": {
                      "type": "string"
                    },
                    "balance": {
                      "type": "string"
                    }
                  },
                  "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                }
              }
            },
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method."
    },
    "cosmos.staking.v1beta1.QueryValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "format": "byte"
              },
              "consensus_pubkey": {
                "type": "string"
              },
              "jailed": {
                "type": "boolean",
                "format": "boolean"
              },
              "status": {
                "type": "integer",
                "format": "int32"
              },
              "tokens": {
                "type": "string"
              },
              "delegator_shares": {
                "type": "string"
              },
              "description": {
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string"
                  },
                  "identity": {
                    "type": "string"
                  },
                  "website": {
                    "type": "string"
                  },
                  "security_contact": {
                    "type": "string"
                  },
                  "details": {
                    "type": "string"
                  }
                },
                "description": "Description defines a validator description."
              },
              "unbonding_height": {
                "type": "string",
                "format": "int64"
              },
              "unbonding_time": {
                "type": "string",
                "format": "date-time"
              },
              "commission": {
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string"
                      },
                      "max_rate": {
                        "type": "string"
                      },
                      "max_change_rate": {
                        "type": "string"
                      }
                    },
                    "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "Commission defines commission parameters for a given validator."
              },
              "min_self_delegation": {
                "type": "string"
              }
            },
            "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
          },
          "description": "validators contains all the queried validators."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
    },
    "cosmos.staking.v1beta1.Redelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_src_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_dst_address": {
          "type": "string",
          "format": "byte"
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "string",
                "format": "int64"
              },
              "completion_time": {
                "type": "string",
                "format": "date-time"
              },
              "initial_balance": {
                "type": "string"
              },
              "shares_dst": {
                "type": "string"
              }
            },
            "description": "RedelegationEntry defines a redelegation object with relevant metadata."
          }
        }
      },
      "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
    },
    "cosmos.staking.v1beta1.RedelegationEntry": {
      "type": "object",
      "properties": {
        "creation_height": {
          "type": "string",
          "format": "int64"
        },
        "completion_time": {
          "type": "string",
          "format": "date-time"
        },
        "initial_balance": {
          "type": "string"
        },
        "shares_dst": {
          "type": "string"
        }
      },
      "description": "RedelegationEntry defines a redelegation object with relevant metadata."
    },
    "cosmos.staking.v1beta1.RedelegationEntryResponse": {
      "type": "object",
      "properties": {
        "redelegation_entry": {
          "type": "object",
          "properties": {
            "creation_height": {
              "type": "string",
              "format": "int64"
            },
            "completion_time": {
              "type": "string",
              "format": "date-time"
            },
            "initial_balance": {
              "type": "string"
            },
            "shares_dst": {
              "type": "string"
            }
          },
          "description": "RedelegationEntry defines a redelegation object with relevant metadata."
        },
        "balance": {
          "type": "string"
        }
      },
      "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.RedelegationResponse": {
      "type": "object",
      "properties": {
        "redelegation": {
          "type": "object",
          "properties": {
            "delegator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_src_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_dst_address": {
              "type": "string",
              "format": "byte"
            },
            "entries": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "initial_balance": {
                    "type": "string"
                  },
                  "shares_dst": {
                    "type": "string"
                  }
                },
                "description": "RedelegationEntry defines a redelegation object with relevant metadata."
              }
            }
          },
          "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "redelegation_entry": {
                "type": "object",
                "properties": {
                  "creation_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "completion_time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "initial_balance": {
                    "type": "string"
                  },
                  "shares_dst": {
                    "type": "string"
                  }
                },
                "description": "RedelegationEntry defines a redelegation object with relevant metadata."
              },
              "balance": {
                "type": "string"
              }
            },
            "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
          }
        }
      },
      "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
    },
    "cosmos.staking.v1beta1.UnbondingDelegation": {
      "type": "object",
      "properties": {
        "delegator_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "string",
                "format": "int64"
              },
              "completion_time": {
                "type": "string",
                "format": "date-time"
              },
              "initial_balance": {
                "type": "string"
              },
              "balance": {
                "type": "string"
              }
            },
            "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
          }
        }
      },
      "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
    },
    "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
      "type": "object",
      "properties": {
        "creation_height": {
          "type": "string",
          "format": "int64"
        },
        "completion_time": {
          "type": "string",
          "format": "date-time"
        },
        "initial_balance": {
          "type": "string"
        },
        "balance": {
          "type": "string"
        }
      },
      "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
    },
    "cosmos.staking.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "operator_address": {
          "type": "string",
          "format": "byte"
        },
        "consensus_pubkey": {
          "type": "string"
        },
        "jailed": {
          "type": "boolean",
          "format": "boolean"
        },
        "status": {
          "type": "integer",
          "format": "int32"
        },
        "tokens": {
          "type": "string"
        },
        "delegator_shares": {
          "type": "string"
        },
        "description": {
          "type": "object",
          "properties": {
            "moniker": {
              "type": "string"
            },
            "identity": {
              "type": "string"
            },
            "website": {
              "type": "string"
            },
            "security_contact": {
              "type": "string"
            },
            "details": {
              "type": "string"
            }
          },
          "description": "Description defines a validator description."
        },
        "unbonding_height": {
          "type": "string",
          "format": "int64"
        },
        "unbonding_time": {
          "type": "string",
          "format": "date-time"
        },
        "commission": {
          "type": "object",
          "properties": {
            "commission_rates": {
              "type": "object",
              "properties": {
                "rate": {
                  "type": "string"
                },
                "max_rate": {
                  "type": "string"
                },
                "max_change_rate": {
                  "type": "string"
                }
              },
              "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
            },
            "update_time": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "Commission defines commission parameters for a given validator."
        },
        "min_self_delegation": {
          "type": "string"
        }
      },
      "description": "Validator defines a validator, together with the total amount of the Validator's\nbond shares and their exchange rate to coins.\nSlashing results in a decrease in the exchange rate, allowing correct\ncalculation of future undelegations without iterating over delegators.\nWhen coins are delegated to this validator, the validator is credited with a\ndelegation whose number of bond shares is based on the amount of coins\ndelegated divided by the current exchange rate. Voting power can be\ncalculated as total bonded shares multiplied by exchange rate."
    },
    "tendermint.types.BlockID": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "part_set_header": {
          "type": "object",
          "properties": {
            "total": {
              "type": "integer",
              "format": "int64"
            },
            "hash": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PartsetHeader"
        }
      },
      "title": "BlockID"
    },
    "tendermint.types.Header": {
      "type": "object",
      "properties": {
        "version": {
          "title": "basic block info",
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          },
          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
        },
        "chain_id": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "last_block_id": {
          "title": "prev block info",
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          }
        },
        "last_commit_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes of block data"
        },
        "data_hash": {
          "type": "string",
          "format": "byte"
        },
        "validators_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes from the app output from the prev block"
        },
        "next_validators_hash": {
          "type": "string",
          "format": "byte"
        },
        "consensus_hash": {
          "type": "string",
          "format": "byte"
        },
        "app_hash": {
          "type": "string",
          "format": "byte"
        },
        "last_results_hash": {
          "type": "string",
          "format": "byte"
        },
        "evidence_hash": {
          "type": "string",
          "format": "byte",
          "title": "consensus info"
        },
        "proposer_address": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Header defines the structure of a Tendermint block header."
    },
    "tendermint.types.PartSetHeader": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int64"
        },
        "hash": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PartsetHeader"
    },
    "tendermint.version.Consensus": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any\nspecial \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been\nset in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height\nis reached and the software will exit."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "The time after which the upgrade must be performed.\nLeave set to its zero value to use a pre-defined Height instead."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
        },
        "info": {
          "type": "string",
          "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
        }
      },
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    },
    "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "description": "height is the block height at which the plan was applied."
        }
      },
      "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method."
    },
    "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
      "type": "object",
      "properties": {
        "plan": {
          "description": "plan is the current upgrade plan.",
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any\nspecial \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been\nset in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height\nis reached and the software will exit."
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "The time after which the upgrade must be performed.\nLeave set to its zero value to use a pre-defined Height instead."
            },
            "height": {
              "type": "string",
              "format": "int64",
              "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set."
            },
            "info": {
              "type": "string",
              "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
            }
          }
        }
      },
      "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method."
    },
    "ibc.channel.Channel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        }
      },
      "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
    },
    "ibc.channel.Counterparty": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "port on the counterparty chain which owns the other end of the channel."
        },
        "channel_id": {
          "type": "string",
          "title": "channel end on the counterparty chain"
        }
      },
      "title": "Counterparty defines a channel end counterparty"
    },
    "ibc.channel.IdentifiedChannel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        },
        "port_id": {
          "type": "string",
          "title": "port identifier"
        },
        "channel_id": {
          "type": "string",
          "title": "channel identifier"
        }
      },
      "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
    },
    "ibc.channel.Order": {
      "type": "string",
      "enum": [
        "ORDER_NONE_UNSPECIFIED",
        "ORDER_UNORDERED",
        "ORDER_ORDERED"
      ],
      "default": "ORDER_NONE_UNSPECIFIED",
      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
      "title": "Order defines if a channel is ORDERED or UNORDERED"
    },
    "ibc.channel.PacketAckCommitment": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "channel port identifier."
        },
        "channel_id": {
          "type": "string",
          "description": "channel unique identifier."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "packet sequence."
        },
        "hash": {
          "type": "string",
          "format": "byte",
          "description": "packet commitment hash."
        }
      },
      "description": "PacketAckCommitment defines the genesis type necessary to retrieve and store\nacknowlegements."
    },
    "ibc.channel.QueryChannelClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "title": "client state",
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.channel.QueryChannelConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "title": "consensus state associated with the channel",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.channel.QueryChannelResponse": {
      "type": "object",
      "properties": {
        "channel": {
          "title": "channel associated with the request identifiers",
          "type": "object",
          "properties": {
            "state": {
              "title": "current state of the channel end",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN",
                "STATE_CLOSED"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED",
              "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
            },
            "ordering": {
              "title": "whether the channel is ordered or unordered",
              "type": "string",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                "ORDER_UNORDERED",
                "ORDER_ORDERED"
              ],
              "default": "ORDER_NONE_UNSPECIFIED",
              "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
            },
            "counterparty": {
              "title": "counterparty channel end",
              "type": "object",
              "properties": {
                "port_id": {
                  "type": "string",
                  "description": "port on the counterparty chain which owns the other end of the channel."
                },
                "channel_id": {
                  "type": "string",
                  "title": "channel end on the counterparty chain"
                }
              }
            },
            "connection_hops": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
            },
            "version": {
              "type": "string",
              "title": "opaque channel version, which is agreed upon during the handshake"
            }
          },
          "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
    },
    "ibc.channel.QueryChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of stored channels of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
    },
    "ibc.channel.QueryConnectionChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on this\nchannel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of channels associated with a connection."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
    },
    "ibc.channel.QueryNextSequenceReceiveResponse": {
      "type": "object",
      "properties": {
        "next_sequence_receive": {
          "type": "string",
          "format": "uint64",
          "title": "next sequence receive number"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
    },
    "ibc.channel.QueryPacketAcknowledgementResponse": {
      "type": "object",
      "properties": {
        "acknowledgement": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof, its path and the height form which the\nproof was retrieved"
    },
    "ibc.channel.QueryPacketCommitmentResponse": {
      "type": "object",
      "properties": {
        "commitment": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof, its path and the height form which the proof was\nretrieved"
    },
    "ibc.channel.QueryPacketCommitmentsResponse": {
      "type": "object",
      "properties": {
        "commitments": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "channel port identifier."
              },
              "channel_id": {
                "type": "string",
                "description": "channel unique identifier."
              },
              "sequence": {
                "type": "string",
                "format": "uint64",
                "description": "packet sequence."
              },
              "hash": {
                "type": "string",
                "format": "byte",
                "description": "packet commitment hash."
              }
            },
            "description": "PacketAckCommitment defines the genesis type necessary to retrieve and store\nacknowlegements."
          }
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
    },
    "ibc.channel.QueryUnrelayedPacketsResponse": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unrelayed packet sequences"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryUnrelayedPacketsResponse is the request type for the\nQuery/UnrelayedPacketCommitments RPC method"
    },
    "ibc.channel.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN",
        "STATE_CLOSED"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
    },
    "ibc.client.Height": {
      "type": "object",
      "properties": {
        "epoch_number": {
          "type": "string",
          "format": "uint64",
          "title": "the epoch that the client is currently on"
        },
        "epoch_height": {
          "type": "string",
          "format": "uint64",
          "title": "the height within the given epoch"
        }
      },
      "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset",
      "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
    },
    "ibc.client.IdentifiedClientState": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client identifier"
        },
        "client_state": {
          "title": "client state",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
    },
    "ibc.client.QueryClientStateResponse": {
      "type": "object",
      "properties": {
        "client_state": {
          "title": "client state associated with the request identifier",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.client.QueryClientStatesResponse": {
      "type": "object",
      "properties": {
        "client_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "title": "client identifier"
              },
              "client_state": {
                "title": "client state",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              }
            },
            "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
          },
          "description": "list of stored ClientStates of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
    },
    "ibc.client.QueryConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "title": "consensus state associated with the client identifier at the given height",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState RPC method"
    },
    "ibc.client.QueryConsensusStatesResponse": {
      "type": "object",
      "properties": {
        "consensus_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "consensus states associated with the identifier"
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryConsensusStatesResponse is the response type for the Query/ConsensusStates RPC method"
    },
    "ibc.commitment.MerklePrefix": {
      "type": "object",
      "properties": {
        "key_prefix": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))"
    },
    "ibc.connection.ConnectionEnd": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "title": "commitment merkle prefix of the counterparty chain",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              }
            }
          }
        }
      },
      "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one. NOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
    },
    "ibc.connection.Counterparty": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
        },
        "connection_id": {
          "type": "string",
          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
        },
        "prefix": {
          "title": "commitment merkle prefix of the counterparty chain",
          "type": "object",
          "properties": {
            "key_prefix": {
              "type": "string",
              "format": "byte"
            }
          }
        }
      },
      "description": "Counterparty defines the counterparty chain associated with a connection end."
    },
    "ibc.connection.IdentifiedConnection": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "connection identifier."
        },
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "title": "commitment merkle prefix of the counterparty chain",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              }
            }
          }
        }
      },
      "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
    },
    "ibc.connection.QueryClientConnectionsResponse": {
      "type": "object",
      "properties": {
        "connection_paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "slice of all the connection paths associated with a client."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was generated",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
    },
    "ibc.connection.QueryConnectionClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "title": "client state",
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "description": "IdentifiedClientState defines a client state with additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
    },
    "ibc.connection.QueryConnectionConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "title": "consensus state associated with the channel",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
    },
    "ibc.connection.QueryConnectionResponse": {
      "type": "object",
      "properties": {
        "connection": {
          "title": "connection associated with the request identifier",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "client associated with this connection."
            },
            "versions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
            },
            "state": {
              "description": "current state of the connection end.",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED"
            },
            "counterparty": {
              "description": "counterparty chain associated with this connection.",
              "type": "object",
              "properties": {
                "client_id": {
                  "type": "string",
                  "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                },
                "connection_id": {
                  "type": "string",
                  "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                },
                "prefix": {
                  "title": "commitment merkle prefix of the counterparty chain",
                  "type": "object",
                  "properties": {
                    "key_prefix": {
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              }
            }
          },
          "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one. NOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_path": {
          "type": "string",
          "title": "merkle proof path"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.connection.QueryConnectionsResponse": {
      "type": "object",
      "properties": {
        "connections": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "connection identifier."
              },
              "client_id": {
                "type": "string",
                "description": "client associated with this connection."
              },
              "versions": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
              },
              "state": {
                "description": "current state of the connection end.",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED"
              },
              "counterparty": {
                "description": "counterparty chain associated with this connection.",
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                  },
                  "connection_id": {
                    "type": "string",
                    "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                  },
                  "prefix": {
                    "title": "commitment merkle prefix of the counterparty chain",
                    "type": "object",
                    "properties": {
                      "key_prefix": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            },
            "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
          },
          "description": "list of stored connections of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the corresponding\nrequest message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "epoch_number": {
              "type": "string",
              "format": "uint64",
              "title": "the epoch that the client is currently on"
            },
            "epoch_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given epoch"
            }
          },
          "description": "Normally the EpochHeight is incremented at each height while keeping epoch\nnumber the same However some consensus algorithms may choose to reset the\nheight in certain conditions e.g. hard forks, state-machine breaking changes\nIn these cases, the epoch number is incremented so that height continues to\nbe monitonically increasing even as the EpochHeight gets reset"
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
    },
    "ibc.connection.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a connection is in one of the following states:\nINIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A connection end has just started the opening handshake.\n - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\nchain.\n - STATE_OPEN: A connection end has completed the handshake."
    },
    "ibc.transfer.DenomTrace": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "path defines the chain of port/channel identifiers used for tracing the source of the fungible\ntoken."
        },
        "base_denom": {
          "type": "string",
          "description": "base denomination of the relayed fungible token."
        }
      },
      "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing\ninformation path."
    },
    "ibc.transfer.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "boolean",
          "format": "boolean",
          "description": "send_enabled enables or disables all cross-chain token transfers from this chain."
        },
        "receive_enabled": {
          "type": "boolean",
          "format": "boolean",
          "description": "receive_enabled enables or disables all cross-chain token transfers to this chain."
        }
      },
      "description": "Params defines the set of IBC transfer parameters.\nNOTE: To prevent a single token from being transferred, set the TransfersEnabled parameter to\ntrue and then set the bank module's SendEnabled parameter for the denomination to false."
    },
    "ibc.transfer.QueryDenomTraceResponse": {
      "type": "object",
      "properties": {
        "denom_trace": {
          "description": "denom_trace returns the requested denomination trace information.",
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "path defines the chain of port/channel identifiers used for tracing the source of the fungible\ntoken."
            },
            "base_denom": {
              "type": "string",
              "description": "base denomination of the relayed fungible token."
            }
          }
        }
      },
      "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC method."
    },
    "ibc.transfer.QueryDenomTracesResponse": {
      "type": "object",
      "properties": {
        "denom_traces": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "path defines the chain of port/channel identifiers used for tracing the source of the fungible\ntoken."
              },
              "base_denom": {
                "type": "string",
                "description": "base denomination of the relayed fungible token."
              }
            },
            "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing\ninformation path."
          },
          "description": "denom_traces returns all denominations trace information."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently"
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC method."
    },
    "ibc.transfer.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "boolean",
              "format": "boolean",
              "description": "send_enabled enables or disables all cross-chain token transfers from this chain."
            },
            "receive_enabled": {
              "type": "boolean",
              "format": "boolean",
              "description": "receive_enabled enables or disables all cross-chain token transfers to this chain."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    }
  }
}