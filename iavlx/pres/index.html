<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAVL Tree Visualization</title>

    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.min.css"
          integrity="sha512-ZIo9ivf88U0L1S+0D/npMNTTkjez5B9cK5xIecN4IA2OmtbTNBbPAZo/0cBC195sq7FU7cEOVPwtit37f/+1rQ=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/theme/black.min.css"
          integrity="sha512-8xTQdrxFqvj1S4G+pM5d0AwjjKm5vHbi6gZwDX2FDq8HHvfPDf1BEIjBC0fvIh/EFiPeGdDVJZtx66b+4veM9g=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <style>
        /* Custom styles for tree visualization */
        .reveal .slides section {
            height: 100%;
            display: flex !important;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .dual-svg-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 95%;
        }

        .svg-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .svg-section h3 {
            margin: 0 0 5px 0;
            font-size: 1em;
            color: #4a90e2;
        }

        .svg-container {
            background: white;
            border-radius: 8px;
            padding: 15px;
            width: 100%;
            max-height: 35vh;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .svg-container svg {
            max-width: 100%;
            max-height: 100%;
            height: auto;
        }

        .reveal .slides {
            text-align: center;
        }

        /* Animation controls */
        .animation-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .animation-controls .label {
            font-size: 14px;
            color: #4a90e2;
            font-weight: bold;
        }

        .animation-controls .button-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .animation-controls button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
            min-width: 80px;
        }

        .animation-controls button:hover {
            background: #357abd;
        }

        .animation-controls button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #status {
            font-size: 14px;
            color: #4a90e2;
            min-width: 150px;
            text-align: center;
        }

        /* SVG animation effects */
        @keyframes treeGrow {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.5);
            }
            70% {
                transform: scale(1.5);
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes changesetGrow {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            30% {
                transform: scale(0);
                opacity: 0;
            }
            60% {
                transform: scale(1.5);
                opacity: 1;
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Force all SVG groups to use center transform origin */
        .svg-container svg g {
            transform-box: fill-box;
            transform-origin: center center;
        }

        .animate {
            animation: treeGrow 0.5s ease-out !important;
            filter: drop-shadow(0 0 8px gold) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        .visited {
            filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.5)) !important;
        }

        .changeset-appear {
            animation: changesetGrow 0.5s ease-out !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        /* Navigation highlight - current node is very prominent */
        .nav-highlight {
            transform: scale(2.5) !important;
            filter: drop-shadow(0 0 20px #4a90e2) drop-shadow(0 0 40px #4a90e2) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
            transition: transform 0.3s ease-out, filter 0.3s ease-out !important;
        }

        /* Instructions */
        .instructions {
            font-size: 0.9em;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">

        <!-- Slide 1: Title -->
        <section>
            <h1>IAVL Performance Improvements</h1>
        </section>

        <section>
            <h2>Brief History of IAVL & Store Improvement Efforts</h2>
            <ul>
                <li class="fragment">First IAVL code is from <a href="https://github.com/cosmos/iavl/commit/56cfba1d1965debba4c77c4345d303a8fe2d700b">Jae on Oct 21, 2015</a> (10 years ago!)</li>
                <li class="fragment">First attempt at store/v2 in 2021 based on SMT (Sparse Merkle Tree) and separating SS (state storage) and SC (state commitment) (Cosmos SDK ADR-040)</li>
                <li class="fragment">IAVL node key format refactored in 2022 to <code>version|nonce</code> (IAVL ADR-001)</li>
                <li class="fragment">iavl/v1 released in 2023</li>
                <li class="fragment">Cronos's memiavl originated around 2023</li>
                <li class="fragment">Second attempt at store/v2 in 2023-2024 also based on separating SS and SC (Cosmos SDK ADR-065)</li>
                <li class="fragment">iavl/v2 design based on sqlite in 2024-2025</li>
            </ul>
        </section>

        <section>
            <h2>Memiavl Architecture</h2>
            <ul>
                <li class="fragment">Initially the full tree is stored only in memory, but a WAL is maintained for replayability</li>
                <li class="fragment">At a configurable interval, a snapshot of the full tree is written to disk</li>
                <li class="fragment">A tree at a given height can be recovered by loading the latest snapshot tree and replaying the WAL on top of it</li>
                <li class="fragment">To reclaim any memory, snapshot writing must complete and the WAL must be replayed up to the current height</li>
                <li class="fragment">Native file format (no leveldb/rocksdb) and relatively easy to follow code</li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 Architecture</h2>
            <ul>
                <li class="fragment">Inspiration appears to be taken from memiavl and iavl/v1</li>
                <li class="fragment">Initially, the full tree is stored only in memory with WAL logging for replayability</li>
                <li class="fragment">The WAL, however, serves a dual purpose as leaf node storage</li>
                <li class="fragment">At a configurable interval, a "checkpoint" of the changes since the last checkpoint is written to disk</li>
                <li class="fragment">Nodes are identified by a persistent <code>version|nonce</code> node ID (like iavl/v1)</li>
                <li class="fragment">Data is stored in sqlite</li>
                <li class="fragment">After checkpoints, an eviction process reclaims memory</li>
                <li class="fragment">The eviction height can be configured to use less memory or achieve more performance. With higher memory usage, iavl/v2 is ~75% as fast as memiavl.</li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Ops/Sec Comparison</h2>
            <p>Initial benchmarks showed big improvements over iavl/v1, with iavl/2 and memiavl achieving roughly 2x and 4x improvements respectively</p>
            <img src="iavl2_memiavl_perf1.heic" />
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Memory Comparison</h2>
            <p>But memiavl is a memory hog and it seems to get worse as the tree grows in size.</p>
            <img src="iavl2_memiavl_mem1.heic" />
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Large Benchmark</h2>
            <p>As a tree grows larger, memiavl eventually crashes due to out-of-control memory consumption and slow snapshot writing.</p>
            <img src="iavl2_memiavl_perf2.heic" />
            <img src="iavl2_memiavl_mem2.heic" />
        </section>

        <section>
            <h2>memiavl Snapshot Behavior at Scale</h2>
            <img src="memiavl_snapshot_timing.heic" />
            <ul>
                <li class="fragment">As tree size grows, snapshots take several minutes to write</li>
                <li class="fragment">Snapshots have great read performance due to data locality, but long snapshot write times block normal operations</li>
                <li class="fragment">We know some real world trees are much larger than our benchmarks (eg. Osmosis with ~300 million keys)</li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 & Memiavl Disk Usage & Pruning</h2>
            <img src="iavl2_memiavl_disk1.heic" />
            <ul>
                <li class="fragment">Both memiavl & iavl/v2 consider pruning first class behavior, but this doesn't always work so well</li>
                <li class="fragment">memiavl disk quickly exceeds iavl/v1 disk usage if we set a smaller snapshot interval to manage memory</li>
                <li class="fragment">iavl/v2 disk usage spirals out of control in an effort to rewrite checkpoints before deleting old data</li>
            </ul>
        </section>

        <section>
            <h2>IAVLX Motivation</h2>
            <ul>
                <li class="fragment">memiavl and iavl/v2 both showed promising performance improvements with significant gotchas compared to iavl/v1</li>
                <li class="fragment">memiavl's native file format and simplicity were appealing, but snapshot behavior is like a time-bomb for large trees - whenever the full tree needs to be rewritten/traversed for normal operations, this will always be a problem at scale</li>
                <li class="fragment">iavl/v2's checkpoint architecture is more sensible, but use of sqlite adds complexity and unpredictable performance characteristics</li>
                <li class="fragment">using a secondary db like leveldb or sqlite will always add O(log N) complexity between every node traversal</li>
            </ul>
        </section>

        <section>
            <h2>IAVLX Design Overview</h2>
            <ul>
                <li class="fragment">Native file format like memiavl</li>
                <li class="fragment">Store changesets rather than full snapshots</li>
                <li class="fragment">Persistent <code>version|index</code> node IDs similar iavl/v1 and iavl/v2, but designed as an ordered index key</li>
                <li class="fragment">Simple append-only format that is <em>always indexed</em> for fast lookups</li>
                <li class="fragment">Files stay indexed even when nodes are pruned</li>
                <li class="fragment">Changesets roll over based on size limit, so that pruning/compaction is a bounded unit of work</li>
                <li class="fragment">No spikey snapshot or checkpoint behavior, just flush everything to disk as quickly as possible</li>
                <li class="fragment">Use concurrency whenever possible</li>
            </ul>
        </section>

        <section>
            <h2>IAVLX Changeset Serialization</h2>
            <p>IAVLX uses a custom file format which is based on natural properties of IAVL tree traversal:</p>
            <ul>
                <li class="fragment">each node is assigned a persistent <code>NodeID</code> based on its version and post-order traversal index:
                    <ul>
                        <li>leaf nodes: <code>L{version}|{index}</code></li>
                        <li>branch nodes: <code>B{version}|{index}</code></li>
                    </ul>
                </li>
                <li class="fragment">leaf and branch nodes are stored in <code>NodeID</code> order as fixed sized records on disk</li>
            </ul>
        </section>

        <!-- Tree Version 1 -->
        <section data-animation="version" data-version="1">
            <h2>Version 1</h2>
            <p><em>Click the animation controls on the right to visualization how a changeset is written</em></p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v1"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v1"></div>
                </div>
                <ul>
                    <li>Nodes are written in post-traversal order</li>
                    <li>Children are always written before parents</li>
                    <li>Parents contain direct offset references to children</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 2 -->
        <section data-animation="version" data-version="2">
            <h2>Version 2</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v2"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v2"></div>
                </div>
                <ul>
                    <li>Newer version data is always at the root of the tree</li>
                    <li>Child nodes node version is always <= parent node version</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 3 -->
        <section data-animation="version" data-version="3">
            <h2>Version 3</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v3"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v3"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 4 -->
        <section data-animation="version" data-version="4">
            <h2>Version 4</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v4"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 5 -->
        <section data-animation="version" data-version="5">
            <h2>Version 5</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v5"></div>
                </div>
            </div>
        </section>

        <section>
            <h2>IAVLX Changeset Compaction</h2>
            <ul>
                <li class="fragment">one changeset stores a contiguous range of versions</li>
                <li class="fragment">changesets are size bound (ex. 2GB max size, this is configurable)</li>
                <li class="fragment">a background process periodically compacts old changesets by:
                    <ul>
                        <li>linearly iterating over all nodes and copying only retained nodes</li>
                        <li>joining small changesets into larger ones</li>
                    </ul>
                </li>
                <li class="fragment">pruning is fast with only linear disk IO and doesn't block normal operations</li>
            </ul>
        </section>

        <!-- Tree Compaction Animation -->
        <section data-animation="compaction">
            <h2>Changeset Compaction</h2>
            <p>Let's compact this changeset to only save version 4 and 5 data</p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Original Changeset</h3>
                    <div class="svg-container" id="compaction-original"></div>
                </div>
                <div class="svg-section">
                    <h3>Compacted Changeset (Pruned)</h3>
                    <div class="svg-container" id="compaction-compacted"></div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Static - Trees 4 & 5 vs Compacted -->
        <section>
            <h2>Version 4 & 5 Trees â†’ Compacted Changeset</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h5>Version 4 Tree</h5>
                    <div class="svg-container" id="static-tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h5>Version 5 Tree</h5>
                    <div class="svg-container" id="static-tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h5>Compacted Changeset (Only v4 & v5 nodes)</h5>
                    <div class="svg-container" id="static-compacted"></div>
                </div>
            </div>
        </section>

        <section>
            <h2>IAVLX Changeset Lookup</h2>
            <ul>
                <li class="fragment">when traversing tree nodes within a single changeset:
                    <ul>
                        <li class="fragment">parent nodes store direct integer offsets to children</li>
                        <li class="fragment">within a changeset, tree traversal is always O(1)</li>
                    </ul>
                </li>
                <li class="fragment">when traversing a tree across multiple changesets:
                    <ul>
                        <li class="fragment">nodes are always stored in <code>NodeID</code> order within each changeset</li>
                        <li class="fragment">so node lookup is O(log n) via binary search (<em>worst case</em>)</li>
                        <li class="fragment">but a version index speeds this in practice to O(1) for uncompacted changesets and O(log log n) after compaction</li>
                    </ul>
                </li>
            </ul>
        </section>

        <!-- Tree Navigation Animation -->
        <section data-animation="navigation">
            <h2>Tree Navigation</h2>
            <p>Getting the value for key 0x7</p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <div class="svg-container" id="nav-tree"></div>
                </div>
                <div class="svg-section">
                    <div class="svg-container" id="nav-changeset"></div>
                </div>
                <p>
                    Finding a leaf node involves scanning the branches file from the root backwards and then one hop to the leaves file.
                    Child branches always come before parent nodes.
                </p>
            </div>
        </section>

        <section>
            <h2>Implementation Details</h2>
            <ul>
                <li class="fragment">changeset writing is always append-only</li>
                <li class="fragment">changeset reading is done via memory-mapped files (optimal for random access)</li>
                <li class="fragment">disk IO patterns for writing, pruning and reading are simple and easy to reason about</li>
                <li class="fragment">any work which is CPU bound is done concurrently (eg. tree balancing and hashing)</li>
            </ul>
        </section>

    </div>
</div>

<!-- Animation Controls -->
<div class="animation-controls">
    <span class="label">Animation Controls:</span>
    <button id="reset-btn" onclick="resetAnimation()">Reset</button>
    <button id="prev-btn" onclick="previousNode()">Previous</button>
    <button id="next-btn" onclick="nextNode()">Next</button>
    <div id="status"></div>
</div>

<!-- Reveal.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.js"
        integrity="sha512-GvouLVZT+gJSJW5eOfpG46xTaBb2c3VeNnbzmDYTRQkFlgvxNhnzZQqiQ/jAyAYPh+a9roBvAHJP6zvXIVq34Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- Animation utilities -->
<script src="animations.js"></script>

<!-- Main presentation script -->
<script>
    // Initialize Reveal.js
    Reveal.initialize({
        hash: true,
        controls: true,
        progress: true,
        center: true,
        transition: 'slide',
        slideNumber: true,
        width: 1920,
        height: 1080,
        plugins: [],
    });

    // NEW nodes for each version in post-order traversal (only nodes added in that version)
    const versionNodes = {
        1: ['L1_1', 'L1_2', 'B1_1', 'L1_3', 'L1_4', 'B1_2', 'B1_3'],
        2: ['L2_1', 'B2_1', 'L2_2', 'L2_3', 'B2_2', 'B2_3', 'B2_4'],
        3: ['L3_1', 'B3_1', 'B3_2', 'L3_2', 'L3_3', 'B3_3', 'B3_4', 'B3_5'],
        4: ['L4_1', 'B4_1', 'B4_2', 'B4_2', 'B4_3', 'L4_2', 'L4_3', 'B4_4', 'B4_5', 'B4_6'],
        5: ['L5_1', 'L5_2', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'L5_3', 'L5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Get all nodes from previous versions (cumulative)
    function getPreviousVersionNodes(version) {
        let allNodes = [];
        for (let v = 1; v < version; v++) {
            if (versionNodes[v]) {
                allNodes = allNodes.concat(versionNodes[v]);
            }
        }
        return allNodes;
    }

    // Current animator instance
    let currentAnimator = null;
    let currentVersion = null;

    // Status display
    const status = createStatusDisplay('status');

    // Load SVGs for a specific version
    async function loadVersionSVGs(version) {
        try {
            await loadSVG(`ex${version}.dot.svg`, `tree-v${version}`);
            await loadSVG(`ex${version}_cs.dot.svg`, `changeset-v${version}`);
            return true;
        } catch (err) {
            console.error(`Failed to load SVGs for version ${version}:`, err);
            status.update(`Error loading version ${version} SVGs`);
            return false;
        }
    }

    // Initialize animator for current slide
    function initializeAnimator(version) {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        const nodes = versionNodes[version] || [];
        const previousNodes = getPreviousVersionNodes(version);

        currentAnimator = new DualSVGAnimator(
            `tree-v${version}`,
            `changeset-v${version}`,
            nodes,
            previousNodes
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = version;
        updateButtons();
    }

    // Update button states
    function updateButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        if (currentAnimator) {
            prevBtn.disabled = currentAnimator.isAtBeginning();
            nextBtn.disabled = currentAnimator.isAtEnd();
        } else {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
    }

    // Control functions
    function nextNode() {
        if (currentAnimator) {
            currentAnimator.next();
        }
    }

    function previousNode() {
        if (currentAnimator) {
            currentAnimator.previous();
        }
    }

    function resetAnimation() {
        if (currentAnimator) {
            currentAnimator.reset();
        }
    }

    // Compaction node lists (leaves first, then branches)
    const compactionNodes = {
        all: [
            // All leaves first
            'L1_1', 'L1_2', 'L1_3', 'L1_4',
            'L2_1', 'L2_2', 'L2_3',
            'L3_1', 'L3_2', 'L3_3',
            'L4_1', 'L4_2', 'L4_3',
            'L5_1', 'L5_2', 'L5_3', 'L5_4',
            // All branches second
            'B1_1', 'B1_2', 'B1_3',
            'B2_1', 'B2_2', 'B2_3', 'B2_4',
            'B3_1', 'B3_2', 'B3_3', 'B3_4', 'B3_5',
            'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6',
            'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8'
        ],
        copied: ['L2_2', 'L2_3', 'L3_1', 'L3_2', 'L3_3', 'L4_1', 'L4_2', 'L4_3', 'L5_1', 'L5_2', 'L5_3', 'L5_4', 'B3_2', 'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Load compaction SVGs
    async function loadCompactionSVGs() {
        try {
            await loadSVG('ex5_cs.dot.svg', 'compaction-original');
            await loadSVG('ex5_cs_compacted.dot.svg', 'compaction-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load compaction SVGs:', err);
            status.update('Error loading compaction SVGs');
            return false;
        }
    }

    // Initialize compaction animator
    function initializeCompactionAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new CompactionAnimator(
            'compaction-original',
            'compaction-compacted',
            compactionNodes.all,
            compactionNodes.copied
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'compaction';
        updateButtons();
    }

    // Show/hide animation controls
    function showControls() {
        document.querySelector('.animation-controls').style.display = 'flex';
    }

    function hideControls() {
        document.querySelector('.animation-controls').style.display = 'none';
    }

    // Load static SVGs (no animation)
    async function loadStaticSVGs() {
        try {
            await loadSVG('ex4.dot.svg', 'static-tree-v4');
            await loadSVG('ex5.dot.svg', 'static-tree-v5');
            await loadSVG('ex5_cs_compacted.dot.svg', 'static-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load static SVGs:', err);
            return false;
        }
    }

    // Navigation path from root to target leaf (L3_2)
    const navigationPath = ['B5_8', 'B5_7', 'B4_3', 'L3_2'];

    // Load navigation SVGs
    async function loadNavigationSVGs() {
        try {
            await loadSVG('ex5.dot.svg', 'nav-tree');
            await loadSVG('ex5_cs_compacted.dot.svg', 'nav-changeset');
            return true;
        } catch (err) {
            console.error('Failed to load navigation SVGs:', err);
            status.update('Error loading navigation SVGs');
            return false;
        }
    }

    // Initialize navigation animator
    function initializeNavigationAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new NavigationAnimator(
            'nav-tree',
            'nav-changeset',
            navigationPath
        );

        currentAnimator.onUpdate = (current, total) => {
            const currentNode = navigationPath[current - 1] || 'Start';
            status.update(`Node: ${currentNode} (${current} / ${total})`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'navigation';
        updateButtons();
    }

    // Handle slide changes
    Reveal.on('slidechanged', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        if (animationType === 'version') {
            // Version animation slide
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            // Compaction animation slide
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            // Navigation animation slide
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        } else {
            // Static slide - no animation
            currentAnimator = null;
            currentVersion = null;
            status.clear();
            hideControls();

            // Load static SVGs if this is the static slide
            if (slide.querySelector('#static-tree-v4')) {
                loadStaticSVGs();
            }
        }
    });

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Only handle shortcuts if we're on a version slide
        if (currentVersion === null) return;

        // Space or right arrow for next
        if (e.key === ' ' && !e.shiftKey) {
            e.preventDefault();
            nextNode();
        }
        // Shift+Space or left arrow for previous
        else if ((e.key === ' ' && e.shiftKey) || e.key === 'Backspace') {
            e.preventDefault();
            previousNode();
        }
        // R for reset
        else if (e.key === 'r' || e.key === 'R') {
            e.preventDefault();
            resetAnimation();
        }
    });

    // Load initial slide
    Reveal.on('ready', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        // Start with controls hidden
        hideControls();

        if (animationType === 'version') {
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        }
    });
</script>
</body>
</html>