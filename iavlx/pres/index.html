<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAVL Tree Visualization</title>

    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.min.css" integrity="sha512-ZIo9ivf88U0L1S+0D/npMNTTkjez5B9cK5xIecN4IA2OmtbTNBbPAZo/0cBC195sq7FU7cEOVPwtit37f/+1rQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/theme/black.min.css" integrity="sha512-8xTQdrxFqvj1S4G+pM5d0AwjjKm5vHbi6gZwDX2FDq8HHvfPDf1BEIjBC0fvIh/EFiPeGdDVJZtx66b+4veM9g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Custom styles for tree visualization */
        .reveal .slides section {
            height: 100%;
            display: flex !important;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .dual-svg-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 95%;
        }

        .svg-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .svg-section h3 {
            margin: 0 0 5px 0;
            font-size: 1em;
            color: #4a90e2;
        }

        .svg-container {
            background: white;
            border-radius: 8px;
            padding: 15px;
            width: 100%;
            max-height: 35vh;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .svg-container svg {
            max-width: 100%;
            max-height: 100%;
            height: auto;
        }

        .reveal .slides {
            text-align: center;
        }

        /* Animation controls */
        .animation-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .animation-controls button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
            min-width: 80px;
        }

        .animation-controls button:hover {
            background: #357abd;
        }

        .animation-controls button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #status {
            font-size: 14px;
            color: #4a90e2;
            min-width: 150px;
            text-align: center;
        }

        /* SVG animation effects */
        @keyframes treeGrow {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.5);
            }
            70% {
                transform: scale(1.5);
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes changesetGrow {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            30% {
                transform: scale(0);
                opacity: 0;
            }
            60% {
                transform: scale(1.5);
                opacity: 1;
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Force all SVG groups to use center transform origin */
        .svg-container svg g {
            transform-box: fill-box;
            transform-origin: center center;
        }

        .animate {
            animation: treeGrow 0.5s ease-out !important;
            filter: drop-shadow(0 0 8px gold) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        .visited {
            filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.5)) !important;
        }

        .changeset-appear {
            animation: changesetGrow 0.5s ease-out !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        /* Navigation highlight - nodes stay big */
        .nav-highlight {
            transform: scale(1.5) !important;
            filter: drop-shadow(0 0 8px #4a90e2) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
            transition: transform 0.3s ease-out, filter 0.3s ease-out !important;
        }

        /* Instructions */
        .instructions {
            font-size: 0.9em;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">

        <!-- Slide 1: Title -->
        <section>
            <h1>IAVL Performance Improvements</h1>
        </section>

        <section data-markdown>
            <textarea data-template>
                # IAVLX Changeset Serialization
                **IAVLX uses a custom file format which is based on natural properties of IAVL tree
                    traversal:**
                - each node is assigned a persistent `NodeID` based on its version and post-order traversal index:
                    - leaf nodes: `L{version}|{index}`
                    - branch nodes: `B{version}|{index}`
                - leaf and branch nodes are stored in `NodeID` order as fixed sized records on disk
            </textarea>
        </section>

        <section data-markdown>
            <textarea data-template>
            # IAVLX Changeset Lookup
            - when traversing tree nodes within a single changeset:
                - parent nodes store direct integer offsets to children
                - so within a changeset, tree traversal is always O(1) (_best case_)
            - when traversing a tree across multiple changesets:
                - nodes are always stored in `NodeID` order within each changeset
                - so node lookup is O(log n) via binary search (_worst case_)
            </ul>
            </textarea>
        </section>

        <!-- Tree Version 1 -->
        <section data-animation="version" data-version="1">
            <h2>Version 1</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v1"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v1"></div>
                </div>
                <ul>
                    <li>Nodes are written in post-traversal order</li>
                    <li>Children are always written before parents</li>
                    <li>Parents contain direct offset references to children</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 2 -->
        <section data-animation="version" data-version="2">
            <h2>Version 2</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v2"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v2"></div>
                </div>
                <ul>
                    <li>Newer version data is always at the root of the tree</li>
                    <li>Child nodes node version is always <= parent node version</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 3 -->
        <section data-animation="version" data-version="3">
            <h2>Version 3</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v3"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v3"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 4 -->
        <section data-animation="version" data-version="4">
            <h2>Version 4</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v4"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 5 -->
        <section data-animation="version" data-version="5">
            <h2>Version 5</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h3>Changeset (Serialized)</h3>
                    <div class="svg-container" id="changeset-v5"></div>
                </div>
            </div>
        </section>

        <section data-markdown>
            <textarea data-template>
            # IAVLX Changeset Compaction
            - one changeset stores a continuous range of versions
            - changesets are size bound (ex. 2GB max size, this is configurable)
            - a background process periodically compacts old changesets by:
                - linearly iterating over all nodes and copying only retained nodes
                - joining small changesets into larger ones
            - pruning is fast with only linear disk IO and doesn't block normal operations
            </textarea>
        </section>

        <!-- Tree Compaction Animation -->
        <section data-animation="compaction">
            <h2>Changeset Compaction</h2>
            <p>Let's compact this changeset to only save version 4 and 5 data</p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Original Changeset</h3>
                    <div class="svg-container" id="compaction-original"></div>
                </div>
                <div class="svg-section">
                    <h3>Compacted Changeset (Pruned)</h3>
                    <div class="svg-container" id="compaction-compacted"></div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Static - Trees 4 & 5 vs Compacted -->
        <section>
            <h2>Version 4 & 5 Trees â†’ Compacted Changeset</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Version 4 Tree</h3>
                    <div class="svg-container" id="static-tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h3>Version 5 Tree</h3>
                    <div class="svg-container" id="static-tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h3>Compacted Changeset (Only v4 & v5 nodes)</h3>
                    <div class="svg-container" id="static-compacted"></div>
                </div>
            </div>
        </section>

        <!-- Tree Navigation Animation -->
        <section data-animation="navigation">
            <h2>Tree Navigation: Finding a Leaf Node</h2>
            <p>Click through to navigate from root to target leaf (L3_2)</p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h3>Tree Structure</h3>
                    <div class="svg-container" id="nav-tree"></div>
                </div>
                <div class="svg-section">
                    <h3>Compacted Changeset</h3>
                    <div class="svg-container" id="nav-changeset"></div>
                </div>
            </div>
        </section>

        <section data-markdown>
            <textarea data-template>
            # Implementation Details
            - changeset writing is always append-only
            - changeset reading is done via memory-mapped files (optimal for random access)
            - disk IO patterns for writing, pruning and reading are simple and easy to reason about
            - any work which is CPU bound is done concurrently (eg. tree balancing and hashing)
            </textarea>
        </section>

    </div>
</div>

<!-- Animation Controls -->
<div class="animation-controls">
    <button id="reset-btn" onclick="resetAnimation()">Reset</button>
    <button id="prev-btn" onclick="previousNode()">Previous</button>
    <button id="next-btn" onclick="nextNode()">Next</button>
    <div id="status"></div>
</div>

<!-- Reveal.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.js" integrity="sha512-GvouLVZT+gJSJW5eOfpG46xTaBb2c3VeNnbzmDYTRQkFlgvxNhnzZQqiQ/jAyAYPh+a9roBvAHJP6zvXIVq34Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/plugin/markdown/markdown.min.js" integrity="sha512-4exkEeyVuaWUFKozXl6L3UCugl6ai1cKnrVFkWUstdrNB2sDxxmPEaHBzTlYm9wX78EjPzEBG0s8k37oPeUFIw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/plugin/markdown/plugin.min.js" integrity="sha512-E+ALGzPpaGdI2k+lrxWGIfjTvxzwqwiZSinFSZGZsgBU7CZ4pViiLvCiYF92T+wNHigtF99VNFYszeirNqsCXQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- Animation utilities -->
<script src="animations.js"></script>

<!-- Main presentation script -->
<script>
    // Initialize Reveal.js
    Reveal.initialize({
        hash: true,
        controls: true,
        progress: true,
        center: true,
        transition: 'slide',
        slideNumber: true,
        width: 1920,
        height: 1080,
        plugins: [RevealMarkdown],
    });

    // NEW nodes for each version in post-order traversal (only nodes added in that version)
    const versionNodes = {
        1: ['L1_1', 'L1_2', 'B1_1', 'L1_3', 'L1_4', 'B1_2', 'B1_3'],
        2: ['L2_1', 'B2_1', 'L2_2', 'L2_3', 'B2_2', 'B2_3', 'B2_4'],
        3: ['L3_1', 'B3_1', 'B3_2', 'L3_2', 'L3_3', 'B3_3', 'B3_4', 'B3_5'],
        4: ['L4_1', 'B4_1', 'B4_2', 'B4_2', 'B4_3', 'L4_2', 'L4_3', 'B4_4', 'B4_5', 'B4_6'],
        5: ['L5_1', 'L5_2', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'L5_3', 'L5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Get all nodes from previous versions (cumulative)
    function getPreviousVersionNodes(version) {
        let allNodes = [];
        for (let v = 1; v < version; v++) {
            if (versionNodes[v]) {
                allNodes = allNodes.concat(versionNodes[v]);
            }
        }
        return allNodes;
    }

    // Current animator instance
    let currentAnimator = null;
    let currentVersion = null;

    // Status display
    const status = createStatusDisplay('status');

    // Load SVGs for a specific version
    async function loadVersionSVGs(version) {
        try {
            await loadSVG(`ex${version}.dot.svg`, `tree-v${version}`);
            await loadSVG(`ex${version}_cs.dot.svg`, `changeset-v${version}`);
            return true;
        } catch (err) {
            console.error(`Failed to load SVGs for version ${version}:`, err);
            status.update(`Error loading version ${version} SVGs`);
            return false;
        }
    }

    // Initialize animator for current slide
    function initializeAnimator(version) {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        const nodes = versionNodes[version] || [];
        const previousNodes = getPreviousVersionNodes(version);

        currentAnimator = new DualSVGAnimator(
            `tree-v${version}`,
            `changeset-v${version}`,
            nodes,
            previousNodes
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = version;
        updateButtons();
    }

    // Update button states
    function updateButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        if (currentAnimator) {
            prevBtn.disabled = currentAnimator.isAtBeginning();
            nextBtn.disabled = currentAnimator.isAtEnd();
        } else {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
    }

    // Control functions
    function nextNode() {
        if (currentAnimator) {
            currentAnimator.next();
        }
    }

    function previousNode() {
        if (currentAnimator) {
            currentAnimator.previous();
        }
    }

    function resetAnimation() {
        if (currentAnimator) {
            currentAnimator.reset();
        }
    }

    // Compaction node lists (leaves first, then branches)
    const compactionNodes = {
        all: [
            // All leaves first
            'L1_1', 'L1_2', 'L1_3', 'L1_4',
            'L2_1', 'L2_2', 'L2_3',
            'L3_1', 'L3_2', 'L3_3',
            'L4_1', 'L4_2', 'L4_3',
            'L5_1', 'L5_2', 'L5_3', 'L5_4',
            // All branches second
            'B1_1', 'B1_2', 'B1_3',
            'B2_1', 'B2_2', 'B2_3', 'B2_4',
            'B3_1', 'B3_2', 'B3_3', 'B3_4', 'B3_5',
            'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6',
            'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8'
        ],
        copied: ['L2_2', 'L2_3', 'L3_1', 'L3_2', 'L3_3', 'L4_1', 'L4_2', 'L4_3', 'L5_1', 'L5_2', 'L5_3', 'L5_4', 'B3_2', 'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Load compaction SVGs
    async function loadCompactionSVGs() {
        try {
            await loadSVG('ex5_cs.dot.svg', 'compaction-original');
            await loadSVG('ex5_cs_compacted.dot.svg', 'compaction-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load compaction SVGs:', err);
            status.update('Error loading compaction SVGs');
            return false;
        }
    }

    // Initialize compaction animator
    function initializeCompactionAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new CompactionAnimator(
            'compaction-original',
            'compaction-compacted',
            compactionNodes.all,
            compactionNodes.copied
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'compaction';
        updateButtons();
    }

    // Show/hide animation controls
    function showControls() {
        document.querySelector('.animation-controls').style.display = 'flex';
    }

    function hideControls() {
        document.querySelector('.animation-controls').style.display = 'none';
    }

    // Load static SVGs (no animation)
    async function loadStaticSVGs() {
        try {
            await loadSVG('ex4.dot.svg', 'static-tree-v4');
            await loadSVG('ex5.dot.svg', 'static-tree-v5');
            await loadSVG('ex5_cs_compacted.dot.svg', 'static-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load static SVGs:', err);
            return false;
        }
    }

    // Navigation path from root to target leaf (L3_2)
    const navigationPath = ['B5_8', 'B5_7', 'B4_3', 'L3_2'];

    // Load navigation SVGs
    async function loadNavigationSVGs() {
        try {
            await loadSVG('ex5.dot.svg', 'nav-tree');
            await loadSVG('ex5_cs_compacted.dot.svg', 'nav-changeset');
            return true;
        } catch (err) {
            console.error('Failed to load navigation SVGs:', err);
            status.update('Error loading navigation SVGs');
            return false;
        }
    }

    // Initialize navigation animator
    function initializeNavigationAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new NavigationAnimator(
            'nav-tree',
            'nav-changeset',
            navigationPath
        );

        currentAnimator.onUpdate = (current, total) => {
            const currentNode = navigationPath[current - 1] || 'Start';
            status.update(`Node: ${currentNode} (${current} / ${total})`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'navigation';
        updateButtons();
    }

    // Handle slide changes
    Reveal.on('slidechanged', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        if (animationType === 'version') {
            // Version animation slide
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            // Compaction animation slide
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            // Navigation animation slide
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        } else {
            // Static slide - no animation
            currentAnimator = null;
            currentVersion = null;
            status.clear();
            hideControls();

            // Load static SVGs if this is the static slide
            if (slide.querySelector('#static-tree-v4')) {
                loadStaticSVGs();
            }
        }
    });

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Only handle shortcuts if we're on a version slide
        if (currentVersion === null) return;

        // Space or right arrow for next
        if (e.key === ' ' && !e.shiftKey) {
            e.preventDefault();
            nextNode();
        }
        // Shift+Space or left arrow for previous
        else if ((e.key === ' ' && e.shiftKey) || e.key === 'Backspace') {
            e.preventDefault();
            previousNode();
        }
        // R for reset
        else if (e.key === 'r' || e.key === 'R') {
            e.preventDefault();
            resetAnimation();
        }
    });

    // Load initial slide
    Reveal.on('ready', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        // Start with controls hidden
        hideControls();

        if (animationType === 'version') {
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        }
    });
</script>
</body>
</html>