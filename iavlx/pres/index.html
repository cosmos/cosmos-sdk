<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAVL Tree Visualization</title>

    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.min.css"
          integrity="sha512-ZIo9ivf88U0L1S+0D/npMNTTkjez5B9cK5xIecN4IA2OmtbTNBbPAZo/0cBC195sq7FU7cEOVPwtit37f/+1rQ=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/theme/black.min.css"
          integrity="sha512-8xTQdrxFqvj1S4G+pM5d0AwjjKm5vHbi6gZwDX2FDq8HHvfPDf1BEIjBC0fvIh/EFiPeGdDVJZtx66b+4veM9g=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <style>
        /* Custom styles for tree visualization */
        .reveal .slides section {
            height: 100%;
            display: flex !important;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .dual-svg-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 95%;
        }

        .svg-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .svg-section h3 {
            margin: 0 0 5px 0;
            font-size: 1em;
            color: #4a90e2;
        }

        .svg-container {
            background: white;
            border-radius: 8px;
            padding: 15px;
            width: 100%;
            max-height: 35vh;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .svg-container svg {
            max-width: 100%;
            max-height: 100%;
            height: auto;
        }

        /* Three SVG slide - make containers shorter */
        .three-svg-slide .svg-container {
            max-height: 21vh;
        }

        .reveal .slides {
            text-align: center;
        }

        /* Animation controls */
        .animation-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .animation-controls .label {
            font-size: 14px;
            color: #4a90e2;
            font-weight: bold;
        }

        .animation-controls .button-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .animation-controls button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
            min-width: 80px;
        }

        .animation-controls button:hover {
            background: #357abd;
        }

        .animation-controls button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #status {
            font-size: 14px;
            color: #4a90e2;
            min-width: 150px;
            text-align: center;
        }

        /* SVG animation effects */
        @keyframes treeGrow {
            0% {
                transform: scale(1);
            }
            40% {
                transform: scale(1.5);
            }
            70% {
                transform: scale(1.5);
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes changesetGrow {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            30% {
                transform: scale(0);
                opacity: 0;
            }
            60% {
                transform: scale(1.5);
                opacity: 1;
            }
            85% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Force all SVG groups to use center transform origin */
        .svg-container svg g {
            transform-box: fill-box;
            transform-origin: center center;
        }

        .animate {
            animation: treeGrow 0.5s ease-out !important;
            filter: drop-shadow(0 0 8px gold) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        .visited {
            filter: drop-shadow(0 0 3px rgba(255, 215, 0, 0.5)) !important;
        }

        .changeset-appear {
            animation: changesetGrow 0.5s ease-out !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
        }

        /* Navigation highlight - current node is very prominent */
        .nav-highlight {
            transform: scale(2.5) !important;
            filter: drop-shadow(0 0 20px #4a90e2) drop-shadow(0 0 40px #4a90e2) !important;
            transform-box: fill-box !important;
            transform-origin: center center !important;
            transition: transform 0.3s ease-out, filter 0.3s ease-out !important;
        }

        /* Instructions */
        .instructions {
            font-size: 0.9em;
            color: #888;
            margin-top: 20px;
        }

        /* Scale compaction SVGs larger */
        #compaction-original svg {
            transform: scale(1.45, 1.45);  /* horizontal, vertical */
        }
        #compaction-compacted svg {
            transform: scale(1.1, 1.1);  /* horizontal, vertical */
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">

        <!-- Slide 1: Title -->
        <section>
            <h1>IAVL Performance Improvements</h1>
        </section>

        <section>
            <h2>Brief History of IAVL & Improvement Efforts</h2>
            <ul>
                <li class="fragment">First IAVL code is from <a
                        href="https://github.com/cosmos/iavl/commit/56cfba1d1965debba4c77c4345d303a8fe2d700b">Jae on Oct
                    21, 2015</a> (10 years ago!)
                </li>
                <li class="fragment">Performance problems seem to have been flagged early on
                    (<code>PERFORMANCE.md</code> dates to 2017)
                </li>
                <li class="fragment">First attempt at store/v2 in 2021 based on SMT (Sparse Merkle Tree, essentially a
                    radix 2 tree) and separating
                    SS (state storage) and SC (state commitment), see Cosmos SDK ADR-040
                </li>
                <li class="fragment">IAVL node key format refactored in 2022 to <code>version|nonce</code>, see IAVL
                    ADR-001
                </li>
                <li class="fragment">iavl/v1 released in 2023</li>
                <li class="fragment">Cronos's memiavl originated around 2023</li>
                <li class="fragment">Second attempt at store/v2 in 2023-2024 also based on separating SS and SC, see
                    Cosmos SDK ADR-065
                </li>
                <li class="fragment">iavl/v2 design based on sqlite in 2024-2025</li>
                <li class="fragment">Efforts to replace iavl with a different tree (SMT) or explore a split SS/SC
                    architecture have so far been unsuccessful
                </li>
                <li class="fragment">As of mid-2025, memiavl and iavl/v2 appeared to be the best alternatives worth
                    considering, both showing improved performance over iavl/v1
                </li>
            </ul>
        </section>

        <section>
            <h2>iavl/v1 Architecture</h2>
            <ul>
                <li class="fragment">Data is stored in leveldb by default, can be configured to use other key value
                    databases
                </li>
                <li class="fragment">Two layers of in-memory LRU caches</li>
                <li class="fragment">Originally, persistent node identifiers were based on hashes which resulted in
                    terrible data locality
                </li>
                <li class="fragment">Nodes are now identified a <code>version|nonce</code> ID which has better data
                    locality
                </li>
            </ul>
        </section>

        <section>
            <h2>Memiavl Architecture</h2>
            <ul>
                <li class="fragment">Initially the full tree is stored only in memory, but a WAL of KV updates is
                    recorded for
                    replayability
                </li>
                <li class="fragment">At a configurable interval, a snapshot of the full tree is written to disk</li>
                <li class="fragment">A tree at a given height can be recovered by loading the latest snapshot tree and
                    replaying the WAL on top of it
                </li>
                <li class="fragment">To reclaim any memory, snapshot writing must complete and the WAL must be replayed
                    up to the current height, then the old tree can be flus
                </li>
                <li class="fragment">Native file format (no leveldb/rocksdb) and well-structured, easy to follow code
                </li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 Architecture</h2>
            <ul>
                <li class="fragment">Inspiration appears to be taken from memiavl and iavl/v1</li>
                <li class="fragment">Initially, the full tree is stored only in memory with WAL logging for
                    replayability
                </li>
                <li class="fragment">The WAL, however, serves a dual purpose as leaf node storage</li>
                <li class="fragment">At a configurable interval, a "checkpoint" of the changes since the last checkpoint
                    is written to disk
                </li>
                <li class="fragment">Nodes are identified by a persistent <code>version|nonce</code> node ID (like
                    iavl/v1)
                </li>
                <li class="fragment">Data is stored in sqlite</li>
                <li class="fragment">After checkpoints, an eviction process reclaims memory</li>
                <li class="fragment">The eviction height can be configured to use less memory or achieve more
                    performance. With higher memory usage, iavl/v2 is ~75% as fast as memiavl.
                </li>
                <li class="fragment">Retaining nodes in memory up to a configurable eviction height replaces a separate
                    cache
                </li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Ops/Sec Comparison</h2>
            <p>Initial benchmarks showed big improvements over iavl/v1, with iavl/2 and memiavl achieving roughly 2x and
                4x improvements respectively</p>
            <img src="iavl2_memiavl_perf1.heic"/>
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Memory Comparison</h2>
            <p>But memiavl is a memory hog and it seems to get worse as the tree grows in size.</p>
            <img src="iavl2_memiavl_mem1.heic"/>
        </section>

        <section>
            <h2>iavl/v2 vs memiavl Large Benchmark</h2>
            <p>With larger trees, memiavl eventually crashes due to out-of-control memory usage and slow
                snapshot writing. iavl/v1 and iavl/v2 can (more or less) keep going.</p>
            <img src="iavl2_memiavl_perf2.heic"/>
            <img src="iavl2_memiavl_mem2.heic"/>
        </section>

        <section>
            <h2>memiavl Snapshot Behavior at Scale</h2>
            <img src="memiavl_snapshot_timing.heic"/>
            <ul>
                <li class="fragment">As tree size grows, snapshots take several minutes to write</li>
                <li class="fragment">In this chart there are three phases:
                    <ol>
                        <li class="fragment"><code>snapshot_duration</code>: write snapshot</li>
                        <li class="fragment"><code>best_effort_wal_duration</code>: replay WAL in the background to
                            catch up to the height when the snapshot completed
                        </li>
                        <li class="fragment"><code>wal_sync_duration</code>: stop all processing and replay the WAL
                            until caught up to the current height to reclaim memory. In this example, memiavl crashed
                            and ran out of memory before this completed.
                        </li>
                    </ol>
                </li>
                <li class="fragment">Snapshots have great read performance due to data locality</li>
                <li class="fragment">But long snapshot write times could force other processing to pause for several
                    minutes or even crash the process
                </li>
                <li class="fragment">We know some real world trees are much larger than our benchmarks (eg. Osmosis with
                    ~300 million keys), so this could be problematic
                </li>
            </ul>
        </section>

        <section>
            <h2>iavl/v2 & Memiavl Disk Usage & Pruning</h2>
            <img src="iavl2_memiavl_disk1.heic"/>
            <ul>
                <li class="fragment">Both memiavl & iavl/v2 consider pruning first class behavior, but this doesn't
                    always work so well
                </li>
                <li class="fragment">memiavl quickly exceeds iavl/v1 disk usage if we use a smaller snapshot
                    interval to try to manage memory more aggressively. The memiavl-100-2 run is snapshotting every 100
                    blocks and manages to survive a little longer than with the default snapshot interval of 1000
                    blocks, but it also crashes
                </li>
                <li class="fragment">Eventually iavl/v2 disk usage spirals out of control in an effort to rewrite
                    checkpoints
                    before deleting old data
                </li>
            </ul>
        </section>

        <section>
            <h2>IAVLX Motivation</h2>
            <ul>
                <li class="fragment">memiavl and iavl/v2 both showed promising performance improvements, but with
                    significant
                    gotchas compared to iavl/v1
                </li>
                <li class="fragment">memiavl's intial performance is impressive, but long snapshot behavior
                    with the potential of out-of-control memory usage and long pauses is an unacceptable risk for larger
                    trees
                </li>
                <li class="fragment">iavl/v2 provided decent performance, but its code wasn't production ready and
                    showed disk usage problems at scale. Also, its dependency on sqlite introduces complexity and
                    unpredictable
                    performance characteristics
                </li>
                <li class="fragment">we decided to try an experimental hybrid codenamed IAVLX (X for experimental),
                    which aimed to combined the best parts of both designs:
                    <ul>
                        <li class="fragment">Native file format like memiavl. Whenever nodes are stored in a
                            secondary db like leveldb or sqlite, we pay O(log N) complexity when traversing from node to
                            node, on top of IAVL's
                            intrinsic O(log N) traversal
                            complexity
                        <li class="fragment">Write incremental diffs or checkpoints like iavl/v2 instead of all or
                            nothing snapshots, and clean up memory and disk usage incrementally.
                        </li>
                    </ul>
                </li>

            </ul>
        </section>

        <section>
            <h2>IAVLX Design Overview</h2>
            <ul>
                <li class="fragment">Persistent <code>version|index</code> node IDs similar iavl/v1 and iavl/v2, but
                    designed as an ordered index key based on post-order traversal
                </li>
                <li class="fragment">Simple append-only format that is <em>always indexed</em> for fast lookups</li>
                <li class="fragment">Files stay indexed even when nodes are pruned</li>
                <li class="fragment">Changesets roll over based on size limit, so that pruning/compaction is a bounded
                    unit of work
                </li>
                <li class="fragment">No spikey snapshot or checkpoint behavior, just flush everything to disk as quickly
                    as possible
                </li>
                <li class="fragment">Use concurrency whenever possible</li>
                <li class="fragment">Configurable eviction like iavl/v2 instead of a separate cache</li>
            </ul>
        </section>
        <section>
            <h2>IAVLX Disk Format</h2>
            <ul>
                <li class="fragment">IAVLX uses a custom disk format composed of changesets which spans a contiguous
                    range of versions, ex. <code>1-53</code>, <code>54-75</code>, <code>76-105</code>, etc.
                <li class="fragment">each changeset is a directory composed of the following files:
                    <ul>
                        <li class="fragment"><code>kv.log</code> - append-only log of key/value data for leaf nodes,
                            doubles
                            as write-ahead log (WAL) for replay
                        </li>
                        <li class="fragment"><code>leaves.dat</code> - append-only log of fixed size leaf node structs
                        </li>
                        <li class="fragment"><code>branches.dat</code> - append-only log of fixed size branch node
                            structs
                        </li>
                        <li class="fragment"><code>versions.dat</code> - append-only log of version -> leaf/branch file
                            offsets for fast node lookups across changesets, plus version metadata
                        </li>
                        <li class="fragment"><code>orphans.dat</code> - append-only log of orphan node ID/orphan version
                            pairs
                            for pruning
                        </li>
                        <li class="fragment"><code>info.dat</code> - metadata about the changeset (version range, orphan
                            statistics)
                        </li>
                    </ul>
                </li>
            </ul>
        </section>
        <section>
            <h2>IAVLX Node ID Format & Changeset Serialization</h2>
            <ul>
                <li class="fragment">Each node is assigned a persistent 64-bit <code>NodeID</code> based on its version
                    and
                    post-order traversal index:
                    <ul>
                        <li>leaf nodes: <code>L{version}|{index}</code></li>
                        <li>branch nodes: <code>B{version}|{index}</code></li>
                    </ul>
                </li>
                <li class="fragment">Leaf and branch nodes are appended to <code>leaves.dat</code> and
                    <code>branches.dat</code> in post-traversal order as fixed sized records.
                </li>
                <li class="fragment">Because <code>NodeID</code> is assigned in post-order traversal and nodes are
                    serialized in this order:
                    <ul>
                        <li class="fragment">Changesets are always ordered by <code>NodeID</code>, meaning O(log N)
                            binary search is always possible
                        </li>
                        <li class="fragment">Parents are written after children and contain direct offsets to children,
                            meaning O(1) traversal within a changeset
                        </li>
                    </ul>
                </li>
                <li class="fragment">This <code>NodeID</code> design and serialization order is IAVLX's fundamental
                    design choice for fast writing, reading and pruning
                </li>
            </ul>
        </section>

        <!-- Tree Version 1 -->
        <section data-animation="version" data-version="1">
            <h2>Version 1</h2>
            <p><em>Click the animation controls on the right to visualization how a changeset is written</em></p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h6>Tree Structure</h6>
                    <div class="svg-container" id="tree-v1"></div>
                </div>
                <div class="svg-section">
                    <h6>Changeset (Serialized)</h6>
                    <div class="svg-container" id="changeset-v1"></div>
                </div>
                <ul>
                    <li>Nodes are written in post-traversal order</li>
                    <li>Children are always written before parents</li>
                    <li>Parents contain direct offset references to children</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 2 -->
        <section data-animation="version" data-version="2">
            <h2 style="margin: 0 0 0 0;">Version 2</h2>
            <div class="dual-svg-container" style="gap: 5px;">
                <div class="svg-section">
                    <h6 style="margin: 0;">Tree Structure</h6>
                    <div class="svg-container" id="tree-v2" style="padding: 0; max-height: 30vh;"></div>
                </div>
                <div class="svg-section">
                    <h6 style="margin: 0;">Changeset (Serialized)</h6>
                    <div class="svg-container" id="changeset-v2" style="padding: 0; max-height: 30vh;"></div>
                </div>
                <ul style="margin: 0">
                    <li>Newer version data is always at the root of the tree, so we always traverse a shallow sub-tree
                    </li>
                    <li>Child nodes node version is always <= parent node version</li>
                </ul>
            </div>
        </section>

        <!-- Tree Version 3 -->
        <section data-animation="version" data-version="3">
            <h2>Version 3</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h6>Tree Structure</h6>
                    <div class="svg-container" id="tree-v3"></div>
                </div>
                <div class="svg-section">
                    <h6>Changeset (Serialized)</h6>
                    <div class="svg-container" id="changeset-v3"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 4 -->
        <section data-animation="version" data-version="4">
            <h2>Version 4</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h6>Tree Structure</h6>
                    <div class="svg-container" id="tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h6>Changeset (Serialized)</h6>
                    <div class="svg-container" id="changeset-v4"></div>
                </div>
            </div>
        </section>

        <!-- Tree Version 5 -->
        <section data-animation="version" data-version="5">
            <h2>Version 5</h2>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h6>Tree Structure</h6>
                    <div class="svg-container" id="tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h6>Changeset (Serialized)</h6>
                    <div class="svg-container" id="changeset-v5"></div>
                </div>
            </div>
        </section>

        <section>
            <h2>IAVLX Changeset Compaction</h2>
            <ul>
                <li class="fragment">each changeset stores some contiguous range of versions, ex. <code>405-673</code>
                </li>
                <li class="fragment">changesets are size bound (ex. 2GB max size, this is configurable)</li>
                <li class="fragment">a background process periodically compacts old changesets by:
                    <ul>
                        <li class="fragment">linearly iterating over all nodes and copying only retained nodes</li>
                        <li class="fragment">joining small pruned changesets into larger ones</li>

                    </ul>
                </li>
                <li class="fragment">pruning is fast with only linear disk IO and doesn't block normal operations</li>
                <li class="fragment">when to trigger compaction is an open design question
                    <ul>
                        <li class="fragment">current triggers are metric based (how many orphans) and time-based (time
                            since last compaction)
                        </li>
                        <li class="fragment">even though compaction happens in the background, it competes for the same
                            disk IO bandwidth
                        </li>
                        <li class="fragment">compacting too often wastes disk IO</li>
                        <li class="fragment">but compacting and joining old changesets increases node locality and
                            improves
                            read performance
                        </li>
                        <li class="fragment">the compaction/cleanup code is fairly complex and configuration is still
                            evolving
                        </li>
                    </ul>
                </li>
            </ul>
        </section>

        <!-- Tree Compaction Animation -->
        <section data-animation="compaction">
            <h2 style="margin: 0 0 5px 0;">Changeset Compaction</h2>
            <p style="margin: 50px 0;">Let's compact this changeset to only save version 4 and 5 data</p>
            <div class="dual-svg-container" style="gap: 20px;">
                <div class="svg-section">
                    <div class="svg-container" id="compaction-original"></div>
                </div>
                <div class="svg-section">
                    <div class="svg-container" id="compaction-compacted"></div>
                </div>
            </div>
        </section>

        <!-- Slide 8: Static - Trees 4 & 5 vs Compacted -->
        <section class="three-svg-slide">
            <div class="dual-svg-container">
                <div class="svg-section">
                    <h6 style="margin: 0">Version 4 Tree</h6>
                    <div class="svg-container" id="static-tree-v4"></div>
                </div>
                <div class="svg-section">
                    <h6 style="margin: 0">Version 5 Tree</h6>
                    <div class="svg-container" id="static-tree-v5"></div>
                </div>
                <div class="svg-section">
                    <h6 style="margin: 0">Compacted Changeset (Only v4 & v5 nodes)</h6>
                    <div class="svg-container" id="static-compacted"></div>
                </div>
            </div>
        </section>

        <section>
            <h2>IAVLX Node Lookup</h2>
            <ul>
                <li class="fragment">when locating child within the same changeset:
                    <ul>
                        <li class="fragment">parent nodes store direct integer offsets to children</li>
                        <li class="fragment">within a changeset, tree traversal is always O(1)</li>
                    </ul>
                </li>
                <li class="fragment">when locating a child in a different changeset:
                    <ul>
                        <li class="fragment">nodes are always stored in <code>NodeID</code> order</li>
                        <li class="fragment">so node lookup is O(log n) via binary search (<em>worst case</em>)</li>
                        <li class="fragment">but the version index speeds this up</li>
                        <li class="fragment">in practice lookup is O(1) for uncompacted changesets and O(log log n)
                            after compaction
                        </li>
                    </ul>
                </li>
            </ul>
        </section>

        <!-- Tree Navigation Animation -->
        <section data-animation="navigation">
            <h2>Tree Navigation</h2>
            <p>Getting the value for key 0x7</p>
            <div class="dual-svg-container">
                <div class="svg-section">
                    <div class="svg-container" id="nav-tree"></div>
                </div>
                <div class="svg-section">
                    <div class="svg-container" id="nav-changeset"></div>
                </div>
            </div>
            <ul>
                <li class="fragment">To traverse from root to leaf, we navigate backwards in <code>branches.dat</code>
                    then jump
                    to <code>leaves.dat</code>
                </li>
                <li class="fragment">Within the same changeset, parents store direct offsets to children, so each
                    traversal step is O(1)
                </li>
            </ul>
        </section>
        <section>
            <h2>Disk IO and CPU Optimization Summary</h2>
            <ul>
                <li class="fragment">changeset writing is always append-only</li>
                <li class="fragment">changeset reading is done via memory-mapped files (optimal for random access)</li>
                <li class="fragment">changeset compaction/pruning is linear read/linear write operation</li>
                <li class="fragment">any work which is CPU bound is done concurrently (eg. tree balancing and hashing)
                </li>
                <li class="fragment">nodes are linked via atomic pointers so memory can be cleaned up in the
                    background
                </li>
            </ul>
        </section>
        <section>
            <h2>Latest Ops/Sec Performance</h2>
            <p>iavlx vs memiavl showdown</p>
            <image class="fragment" src="iavlx_memiavl1.heic"/>
            <ul>
                <li class="fragment"><strong>NOTE:</strong> These are totally unscientific laptop benchmarks on a small
                    dataset (~15GB
                    across
                    1000
                    blocks)
                </li>
                <li class="fragment">But with the latest optimizations, iavlx may be able to beat or match
                    memiavl in ops/second
                </li>
            </ul>
        </section>
        <section>
            <h2>Large Scale Benchmark</h2>
            <p class="fragment">These benchmarks compare iavl/v1, iavl/v2 and iavlx on a large dataset (~1TB across
                20,000 blocks) running for 16-35 hours.</p>
            <div class="fragment" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 100%;">
                <div>
                    <div style="font-size: 0.7em; margin-bottom: 5px; text-align: center;">Ops/Sec</div>
                    <img src="iavlx_perf_large.heic" style="width: 100%; display: block; margin: 0; padding: 0;"/>
                </div>
                <div>
                    <div style="font-size: 0.7em; margin-bottom: 5px; text-align: center;">Disk Usage</div>
                    <img src="iavlx_disk_large.heic" style="width: 100%; display: block; margin: 0; padding: 0;"/>
                </div>
                <div>
                    <div style="font-size: 0.7em; margin-bottom: 5px; text-align: center;">Memory</div>
                    <img src="iavlx_mem_large.heic" style="width: 100%; display: block; margin: 0; padding: 0;"/>
                </div>
            </div>
            <p class="fragment">iavlx was able to manage memory through eviction and disk usage through pruning while
                maintaining higher ops/second performance.</p>
        </section>
        <section>
            <h2>Next Steps</h2>
            <ul>
                <li class="fragment">Production Readiness
                    <ul>
                        <li class="fragment">Reliable DB reloading and historical queries</li>
                        <li class="fragment">Fault tolerance</li>
                        <li class="fragment">Migrations</li>
                        <li class="fragment">Easy configuration for validator vs query-oriented nodes (nice to have)
                        </li>
                    </ul>
                </li>
                <li class="fragment">Optimizations
                    <ul>
                        <li class="fragment">Better compaction scheduling</li>
                        <li class="fragment">Less allocation and copying on read paths for serving queries</li>
                    </ul>
                </li>
            </ul>
        </section>
        <section>
            <h2>Questions?</h2>
            <p>Thank you for your attention!</p>
        </section>
    </div>
</div>

<!-- Animation Controls -->
<div class="animation-controls">
    <span class="label">Animation Controls:</span>
    <button id="reset-btn" onclick="resetAnimation()">Reset</button>
    <button id="prev-btn" onclick="previousNode()">Previous</button>
    <button id="next-btn" onclick="nextNode()">Next</button>
    <div id="status"></div>
</div>

<!-- Reveal.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.js"
        integrity="sha512-GvouLVZT+gJSJW5eOfpG46xTaBb2c3VeNnbzmDYTRQkFlgvxNhnzZQqiQ/jAyAYPh+a9roBvAHJP6zvXIVq34Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- Animation utilities -->
<script src="animations.js"></script>

<!-- Main presentation script -->
<script>
    // Initialize Reveal.js
    Reveal.initialize({
        hash: true,
        controls: true,
        progress: true,
        center: true,
        transition: 'slide',
        slideNumber: true,
        width: 1920,
        height: 1080,
        plugins: [],
    });

    // NEW nodes for each version in post-order traversal (only nodes added in that version)
    const versionNodes = {
        1: ['L1_1', 'L1_2', 'B1_1', 'L1_3', 'L1_4', 'B1_2', 'B1_3'],
        2: ['L2_1', 'B2_1', 'L2_2', 'L2_3', 'B2_2', 'B2_3', 'B2_4'],
        3: ['L3_1', 'B3_1', 'B3_2', 'L3_2', 'L3_3', 'B3_3', 'B3_4', 'B3_5'],
        4: ['L4_1', 'B4_1', 'B4_2', 'B4_2', 'B4_3', 'L4_2', 'L4_3', 'B4_4', 'B4_5', 'B4_6'],
        5: ['L5_1', 'L5_2', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'L5_3', 'L5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Get all nodes from previous versions (cumulative)
    function getPreviousVersionNodes(version) {
        let allNodes = [];
        for (let v = 1; v < version; v++) {
            if (versionNodes[v]) {
                allNodes = allNodes.concat(versionNodes[v]);
            }
        }
        return allNodes;
    }

    // Current animator instance
    let currentAnimator = null;
    let currentVersion = null;

    // Status display
    const status = createStatusDisplay('status');

    // Load SVGs for a specific version
    async function loadVersionSVGs(version) {
        try {
            await loadSVG(`ex${version}.dot.svg`, `tree-v${version}`);
            await loadSVG(`ex${version}_cs.dot.svg`, `changeset-v${version}`);
            return true;
        } catch (err) {
            console.error(`Failed to load SVGs for version ${version}:`, err);
            status.update(`Error loading version ${version} SVGs`);
            return false;
        }
    }

    // Initialize animator for current slide
    function initializeAnimator(version) {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        const nodes = versionNodes[version] || [];
        const previousNodes = getPreviousVersionNodes(version);

        currentAnimator = new DualSVGAnimator(
            `tree-v${version}`,
            `changeset-v${version}`,
            nodes,
            previousNodes
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = version;
        updateButtons();
    }

    // Update button states
    function updateButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        if (currentAnimator) {
            prevBtn.disabled = currentAnimator.isAtBeginning();
            nextBtn.disabled = currentAnimator.isAtEnd();
        } else {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
    }

    // Control functions
    function nextNode() {
        if (currentAnimator) {
            currentAnimator.next();
        }
    }

    function previousNode() {
        if (currentAnimator) {
            currentAnimator.previous();
        }
    }

    function resetAnimation() {
        if (currentAnimator) {
            currentAnimator.reset();
        }
    }

    // Compaction node lists (leaves first, then branches)
    const compactionNodes = {
        all: [
            // All leaves first
            'L1_1', 'L1_2', 'L1_3', 'L1_4',
            'L2_1', 'L2_2', 'L2_3',
            'L3_1', 'L3_2', 'L3_3',
            'L4_1', 'L4_2', 'L4_3',
            'L5_1', 'L5_2', 'L5_3', 'L5_4',
            // All branches second
            'B1_1', 'B1_2', 'B1_3',
            'B2_1', 'B2_2', 'B2_3', 'B2_4',
            'B3_1', 'B3_2', 'B3_3', 'B3_4', 'B3_5',
            'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6',
            'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8'
        ],
        copied: ['L2_2', 'L2_3', 'L3_1', 'L3_2', 'L3_3', 'L4_1', 'L4_2', 'L4_3', 'L5_1', 'L5_2', 'L5_3', 'L5_4', 'B3_2', 'B4_1', 'B4_2', 'B4_3', 'B4_4', 'B4_5', 'B4_6', 'B5_1', 'B5_2', 'B5_3', 'B5_4', 'B5_5', 'B5_6', 'B5_7', 'B5_8']
    };

    // Load compaction SVGs
    async function loadCompactionSVGs() {
        try {
            await loadSVG('ex5_cs.dot.svg', 'compaction-original');
            await loadSVG('ex5_cs_compacted.dot.svg', 'compaction-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load compaction SVGs:', err);
            status.update('Error loading compaction SVGs');
            return false;
        }
    }

    // Initialize compaction animator
    function initializeCompactionAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new CompactionAnimator(
            'compaction-original',
            'compaction-compacted',
            compactionNodes.all,
            compactionNodes.copied
        );

        currentAnimator.onUpdate = (current, total) => {
            status.update(`${current} / ${total}`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'compaction';
        updateButtons();
    }

    // Show/hide animation controls
    function showControls() {
        document.querySelector('.animation-controls').style.display = 'flex';
    }

    function hideControls() {
        document.querySelector('.animation-controls').style.display = 'none';
    }

    // Load static SVGs (no animation)
    async function loadStaticSVGs() {
        try {
            await loadSVG('ex4.dot.svg', 'static-tree-v4');
            await loadSVG('ex5.dot.svg', 'static-tree-v5');
            await loadSVG('ex5_cs_compacted.dot.svg', 'static-compacted');
            return true;
        } catch (err) {
            console.error('Failed to load static SVGs:', err);
            return false;
        }
    }

    // Navigation path from root to target leaf (L3_2)
    const navigationPath = ['B5_8', 'B5_7', 'B4_3', 'L3_2'];

    // Load navigation SVGs
    async function loadNavigationSVGs() {
        try {
            await loadSVG('ex5.dot.svg', 'nav-tree');
            await loadSVG('ex5_cs_compacted.dot.svg', 'nav-changeset');
            return true;
        } catch (err) {
            console.error('Failed to load navigation SVGs:', err);
            status.update('Error loading navigation SVGs');
            return false;
        }
    }

    // Initialize navigation animator
    function initializeNavigationAnimator() {
        if (currentAnimator) {
            currentAnimator.reset();
        }

        currentAnimator = new NavigationAnimator(
            'nav-tree',
            'nav-changeset',
            navigationPath
        );

        currentAnimator.onUpdate = (current, total) => {
            const currentNode = navigationPath[current - 1] || 'Start';
            status.update(`Node: ${currentNode} (${current} / ${total})`);
            updateButtons();
        };

        currentAnimator.init();
        currentVersion = 'navigation';
        updateButtons();
    }

    // Handle slide changes
    Reveal.on('slidechanged', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        if (animationType === 'version') {
            // Version animation slide
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            // Compaction animation slide
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            // Navigation animation slide
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        } else {
            // Static slide - no animation
            currentAnimator = null;
            currentVersion = null;
            status.clear();
            hideControls();

            // Load static SVGs if this is the static slide
            if (slide.querySelector('#static-tree-v4')) {
                loadStaticSVGs();
            }
        }
    });

    // Handle keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Only handle shortcuts if we're on a version slide
        if (currentVersion === null) return;

        // Space or right arrow for next
        if (e.key === ' ' && !e.shiftKey) {
            e.preventDefault();
            nextNode();
        }
        // Shift+Space or left arrow for previous
        else if ((e.key === ' ' && e.shiftKey) || e.key === 'Backspace') {
            e.preventDefault();
            previousNode();
        }
        // R for reset
        else if (e.key === 'r' || e.key === 'R') {
            e.preventDefault();
            resetAnimation();
        }
    });

    // Load initial slide
    Reveal.on('ready', async event => {
        const slide = event.currentSlide;
        const animationType = slide.getAttribute('data-animation');

        // Start with controls hidden
        hideControls();

        if (animationType === 'version') {
            const version = parseInt(slide.getAttribute('data-version'));
            const loaded = await loadVersionSVGs(version);
            if (loaded) {
                setTimeout(() => {
                    initializeAnimator(version);
                    showControls();
                }, 100);
            }
        } else if (animationType === 'compaction') {
            const loaded = await loadCompactionSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeCompactionAnimator();
                    showControls();
                }, 100);
            }
        } else if (animationType === 'navigation') {
            const loaded = await loadNavigationSVGs();
            if (loaded) {
                setTimeout(() => {
                    initializeNavigationAnimator();
                    showControls();
                }, 100);
            }
        }
    });
</script>
</body>
</html>