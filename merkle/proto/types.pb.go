// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	types.proto

It has these top-level messages:
	Node
	ExistsData
	ExistsProof
	AbsentProof
	RangeProof
	Proof
	MerkleProof
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// HashOp is the hashing algorithm we use at each level
type HashOp int32

const (
	HashOp_RIPEMD160 HashOp = 0
	HashOp_SHA224    HashOp = 1
	HashOp_SHA256    HashOp = 2
	HashOp_SHA384    HashOp = 3
	HashOp_SHA512    HashOp = 4
	HashOp_SHA3_224  HashOp = 5
	HashOp_SHA3_256  HashOp = 6
	HashOp_SHA3_384  HashOp = 7
	HashOp_SHA3_512  HashOp = 8
	HashOp_SHA256_X2 HashOp = 9
)

var HashOp_name = map[int32]string{
	0: "RIPEMD160",
	1: "SHA224",
	2: "SHA256",
	3: "SHA384",
	4: "SHA512",
	5: "SHA3_224",
	6: "SHA3_256",
	7: "SHA3_384",
	8: "SHA3_512",
	9: "SHA256_X2",
}
var HashOp_value = map[string]int32{
	"RIPEMD160": 0,
	"SHA224":    1,
	"SHA256":    2,
	"SHA384":    3,
	"SHA512":    4,
	"SHA3_224":  5,
	"SHA3_256":  6,
	"SHA3_384":  7,
	"SHA3_512":  8,
	"SHA256_X2": 9,
}

func (x HashOp) String() string {
	return proto1.EnumName(HashOp_name, int32(x))
}
func (HashOp) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// If it is KeyValue, this is the data we want
// If it is SubTree, key is name of the tree,
//   value is root hash
type ExistsData_DataType int32

const (
	ExistsData_KeyValue ExistsData_DataType = 0
	ExistsData_SubTree  ExistsData_DataType = 1
)

var ExistsData_DataType_name = map[int32]string{
	0: "KeyValue",
	1: "SubTree",
}
var ExistsData_DataType_value = map[string]int32{
	"KeyValue": 0,
	"SubTree":  1,
}

func (x ExistsData_DataType) String() string {
	return proto1.EnumName(ExistsData_DataType_name, int32(x))
}
func (ExistsData_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// Op represents one hash in a chain of hashes.
// An operation takes the output of the last level and returns
// a hash for the next level:
// Op(last) => Operation(prefix + last + sufix)
//
// A simple left/right hash would simply set prefix=left or
// suffix=right and leave the other blank. However, one could
// also represent the a Patricia trie proof by setting
// prefix to the rlp encoding of all nodes before the branch
// we select, and suffix to all those after the one we select.
type Node struct {
	Prefix []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Suffix []byte `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	Op     HashOp `protobuf:"varint,3,opt,name=op,enum=proto.HashOp" json:"op,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto1.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Node) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Node) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *Node) GetOp() HashOp {
	if m != nil {
		return m.Op
	}
	return HashOp_RIPEMD160
}

// Data is the end value stored,
// used to generate the initial hash store
type ExistsData struct {
	// optional prefix allows second preimage resistance
	Prefix []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Op     HashOp `protobuf:"varint,2,opt,name=op,enum=proto.HashOp" json:"op,omitempty"`
}

func (m *ExistsData) Reset()                    { *m = ExistsData{} }
func (m *ExistsData) String() string            { return proto1.CompactTextString(m) }
func (*ExistsData) ProtoMessage()               {}
func (*ExistsData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ExistsData) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *ExistsData) GetOp() HashOp {
	if m != nil {
		return m.Op
	}
	return HashOp_RIPEMD160
}

// Branch will hash data and then pass it through operations
// from first to last in order to calculate the root node.
//
// Visualize Branch as representing the data closest to
// root as the first item, and the leaf as the last item.
type ExistsProof struct {
	// if either are non-empty, enforce this prefix on all
	// leaf/inner nodes to provide second preimage resistence
	PrefixLeaf  []byte `protobuf:"bytes,1,opt,name=prefixLeaf,proto3" json:"prefixLeaf,omitempty"`
	PrefixInner []byte `protobuf:"bytes,2,opt,name=prefixInner,proto3" json:"prefixInner,omitempty"`
	// this is the data to get the original hash,
	// and a set of operations to calculate the root hash
	Data  *ExistsData `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	Nodes []*Node     `protobuf:"bytes,4,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *ExistsProof) Reset()                    { *m = ExistsProof{} }
func (m *ExistsProof) String() string            { return proto1.CompactTextString(m) }
func (*ExistsProof) ProtoMessage()               {}
func (*ExistsProof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExistsProof) GetPrefixLeaf() []byte {
	if m != nil {
		return m.PrefixLeaf
	}
	return nil
}

func (m *ExistsProof) GetPrefixInner() []byte {
	if m != nil {
		return m.PrefixInner
	}
	return nil
}

func (m *ExistsProof) GetData() *ExistsData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ExistsProof) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type AbsentProof struct {
}

func (m *AbsentProof) Reset()                    { *m = AbsentProof{} }
func (m *AbsentProof) String() string            { return proto1.CompactTextString(m) }
func (*AbsentProof) ProtoMessage()               {}
func (*AbsentProof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type RangeProof struct {
}

func (m *RangeProof) Reset()                    { *m = RangeProof{} }
func (m *RangeProof) String() string            { return proto1.CompactTextString(m) }
func (*RangeProof) ProtoMessage()               {}
func (*RangeProof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Proof struct {
	Root []byte `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// Types that are valid to be assigned to Proof:
	//	*Proof_Exists
	//	*Proof_Absent
	//	*Proof_Range
	Proof isProof_Proof `protobuf_oneof:"proof"`
}

func (m *Proof) Reset()                    { *m = Proof{} }
func (m *Proof) String() string            { return proto1.CompactTextString(m) }
func (*Proof) ProtoMessage()               {}
func (*Proof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isProof_Proof interface {
	isProof_Proof()
}

type Proof_Exists struct {
	Exists *ExistsProof `protobuf:"bytes,2,opt,name=exists,oneof"`
}
type Proof_Absent struct {
	Absent *AbsentProof `protobuf:"bytes,3,opt,name=absent,oneof"`
}
type Proof_Range struct {
	Range *RangeProof `protobuf:"bytes,4,opt,name=range,oneof"`
}

func (*Proof_Exists) isProof_Proof() {}
func (*Proof_Absent) isProof_Proof() {}
func (*Proof_Range) isProof_Proof()  {}

func (m *Proof) GetProof() isProof_Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Proof) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Proof) GetExists() *ExistsProof {
	if x, ok := m.GetProof().(*Proof_Exists); ok {
		return x.Exists
	}
	return nil
}

func (m *Proof) GetAbsent() *AbsentProof {
	if x, ok := m.GetProof().(*Proof_Absent); ok {
		return x.Absent
	}
	return nil
}

func (m *Proof) GetRange() *RangeProof {
	if x, ok := m.GetProof().(*Proof_Range); ok {
		return x.Range
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Proof) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Proof_OneofMarshaler, _Proof_OneofUnmarshaler, _Proof_OneofSizer, []interface{}{
		(*Proof_Exists)(nil),
		(*Proof_Absent)(nil),
		(*Proof_Range)(nil),
	}
}

func _Proof_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Proof)
	// proof
	switch x := m.Proof.(type) {
	case *Proof_Exists:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Exists); err != nil {
			return err
		}
	case *Proof_Absent:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Absent); err != nil {
			return err
		}
	case *Proof_Range:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Range); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Proof.Proof has unexpected type %T", x)
	}
	return nil
}

func _Proof_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Proof)
	switch tag {
	case 2: // proof.exists
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(ExistsProof)
		err := b.DecodeMessage(msg)
		m.Proof = &Proof_Exists{msg}
		return true, err
	case 3: // proof.absent
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(AbsentProof)
		err := b.DecodeMessage(msg)
		m.Proof = &Proof_Absent{msg}
		return true, err
	case 4: // proof.range
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(RangeProof)
		err := b.DecodeMessage(msg)
		m.Proof = &Proof_Range{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Proof_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Proof)
	// proof
	switch x := m.Proof.(type) {
	case *Proof_Exists:
		s := proto1.Size(x.Exists)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Proof_Absent:
		s := proto1.Size(x.Absent)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Proof_Range:
		s := proto1.Size(x.Range)
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MerkleProof struct {
	// branches start from the value, and then may
	// include multiple subtree branches to embed it
	//
	// The first branch must have dataType KeyValue
	// Following branches must have dataType SubTree
	Proofs []*Proof `protobuf:"bytes,1,rep,name=proofs" json:"proofs,omitempty"`
}

func (m *MerkleProof) Reset()                    { *m = MerkleProof{} }
func (m *MerkleProof) String() string            { return proto1.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()               {}
func (*MerkleProof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MerkleProof) GetProofs() []*Proof {
	if m != nil {
		return m.Proofs
	}
	return nil
}

func init() {
	proto1.RegisterType((*Node)(nil), "proto.Node")
	proto1.RegisterType((*ExistsData)(nil), "proto.ExistsData")
	proto1.RegisterType((*ExistsProof)(nil), "proto.ExistsProof")
	proto1.RegisterType((*AbsentProof)(nil), "proto.AbsentProof")
	proto1.RegisterType((*RangeProof)(nil), "proto.RangeProof")
	proto1.RegisterType((*Proof)(nil), "proto.Proof")
	proto1.RegisterType((*MerkleProof)(nil), "proto.MerkleProof")
	proto1.RegisterEnum("proto.HashOp", HashOp_name, HashOp_value)
	proto1.RegisterEnum("proto.ExistsData_DataType", ExistsData_DataType_name, ExistsData_DataType_value)
}

func init() { proto1.RegisterFile("types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 443 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x4d, 0x6f, 0x13, 0x31,
	0x10, 0x8d, 0x37, 0xbb, 0x9b, 0x74, 0x9c, 0x20, 0x33, 0x07, 0xb4, 0x17, 0x50, 0x58, 0x51, 0x29,
	0x20, 0x54, 0x51, 0xa7, 0x89, 0xb8, 0x16, 0xb5, 0x52, 0x2a, 0x28, 0x54, 0x6e, 0x41, 0xdc, 0x2a,
	0x47, 0xf1, 0x42, 0xa1, 0x5a, 0xaf, 0xec, 0x8d, 0xd4, 0xfc, 0x09, 0xee, 0xfc, 0x06, 0xfe, 0x24,
	0xf2, 0x47, 0x9b, 0xf4, 0x90, 0x53, 0xe6, 0xcd, 0xbc, 0x79, 0xef, 0x4d, 0xd6, 0x40, 0xdb, 0x75,
	0xa3, 0xec, 0x41, 0x63, 0x74, 0xab, 0x31, 0xf3, 0x3f, 0xe5, 0x57, 0x48, 0x3f, 0xeb, 0xa5, 0xc2,
	0x67, 0x90, 0x37, 0x46, 0x55, 0x37, 0x77, 0x05, 0x19, 0x91, 0xf1, 0x40, 0x44, 0xe4, 0xfa, 0x76,
	0x55, 0xb9, 0x7e, 0x12, 0xfa, 0x01, 0xe1, 0x73, 0x48, 0x74, 0x53, 0x74, 0x47, 0x64, 0xfc, 0x84,
	0x0f, 0x83, 0xe4, 0xc1, 0x5c, 0xda, 0x9f, 0x5f, 0x1a, 0x91, 0xe8, 0xa6, 0xfc, 0x05, 0x70, 0x7a,
	0x77, 0x63, 0x5b, 0x7b, 0x22, 0x5b, 0xb9, 0x53, 0x3c, 0x88, 0x24, 0xbb, 0x44, 0xf6, 0xa1, 0xef,
	0xd6, 0xaf, 0xd6, 0x8d, 0xc2, 0x01, 0xf4, 0x3f, 0xaa, 0xf5, 0x37, 0x79, 0xbb, 0x52, 0xac, 0x83,
	0x14, 0x7a, 0x97, 0xab, 0xc5, 0x95, 0x51, 0x8a, 0x91, 0xf2, 0x2f, 0x01, 0x1a, 0xcc, 0x2e, 0x8c,
	0xd6, 0x15, 0xbe, 0x00, 0x08, 0xfa, 0x9f, 0x94, 0xac, 0xa2, 0xe3, 0x56, 0x07, 0x47, 0x40, 0x03,
	0x3a, 0xab, 0x6b, 0x65, 0xe2, 0x5d, 0xdb, 0x2d, 0xdc, 0x87, 0x74, 0x29, 0x5b, 0xe9, 0xcf, 0xa3,
	0xfc, 0x69, 0x4c, 0xb6, 0x39, 0x48, 0xf8, 0x31, 0xbe, 0x84, 0xac, 0xd6, 0x4b, 0x65, 0x8b, 0x74,
	0xd4, 0x1d, 0x53, 0x4e, 0x23, 0xcf, 0xfd, 0x9f, 0x22, 0x4c, 0xca, 0x21, 0xd0, 0xe3, 0x85, 0x55,
	0x75, 0xeb, 0xa3, 0x95, 0x03, 0x00, 0x21, 0xeb, 0x1f, 0x2a, 0xa0, 0x7f, 0x04, 0xb2, 0x10, 0x19,
	0x21, 0x35, 0x5a, 0xb7, 0x31, 0xac, 0xaf, 0xf1, 0x2d, 0xe4, 0xca, 0x3b, 0xfa, 0x84, 0x94, 0xe3,
	0xa3, 0x18, 0x7e, 0x6f, 0xde, 0x11, 0x91, 0xe3, 0xd8, 0xd2, 0x1b, 0xc5, 0xd0, 0xf7, 0xec, 0x2d,
	0x77, 0xc7, 0x0e, 0x1c, 0x7c, 0x0d, 0x99, 0x71, 0x39, 0x8a, 0xf4, 0xd1, 0x85, 0x9b, 0x6c, 0xf3,
	0x8e, 0x08, 0x8c, 0x0f, 0x3d, 0x70, 0x2f, 0x45, 0x57, 0xe5, 0x04, 0xe8, 0xb9, 0x32, 0xbf, 0x6f,
	0x03, 0x01, 0x5f, 0xb9, 0x6f, 0xaa, 0x75, 0x65, 0x0b, 0xe2, 0xaf, 0x1f, 0x44, 0x0d, 0x3f, 0x15,
	0x71, 0xf6, 0xe6, 0x0f, 0x81, 0x3c, 0x7c, 0x51, 0x1c, 0xc2, 0x9e, 0x38, 0xbb, 0x38, 0x3d, 0x3f,
	0x39, 0x9c, 0xbd, 0x63, 0x1d, 0x04, 0xc8, 0x2f, 0xe7, 0xc7, 0x9c, 0x1f, 0x31, 0x72, 0x5f, 0x4f,
	0x67, 0x2c, 0x89, 0xf5, 0xe4, 0xfd, 0x11, 0xeb, 0xc6, 0x7a, 0x7a, 0xc8, 0x59, 0xea, 0x1e, 0x80,
	0xeb, 0x5f, 0xbb, 0x8d, 0x6c, 0x83, 0xa6, 0x33, 0x96, 0x3f, 0x20, 0xb7, 0xd5, 0x7b, 0x40, 0x6e,
	0xaf, 0xef, 0x6c, 0x83, 0xf6, 0xf5, 0x77, 0xce, 0xf6, 0x16, 0xb9, 0x4f, 0x39, 0xf9, 0x1f, 0x00,
	0x00, 0xff, 0xff, 0xaa, 0x23, 0x86, 0x03, 0x0c, 0x03, 0x00, 0x00,
}
