// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package bankexample

import (
	context "context"

	ormdb "github.com/cosmos/cosmos-sdk/orm/model/ormdb"
	ormlist "github.com/cosmos/cosmos-sdk/orm/model/ormlist"
	ormtable "github.com/cosmos/cosmos-sdk/orm/model/ormtable"
	ormerrors "github.com/cosmos/cosmos-sdk/orm/types/ormerrors"
)

type BalanceStore interface {
	Insert(ctx context.Context, balance *Balance) error
	Update(ctx context.Context, balance *Balance) error
	Save(ctx context.Context, balance *Balance) error
	Delete(ctx context.Context, balance *Balance) error
	Has(ctx context.Context, address string, denom string) (found bool, err error)
	Get(ctx context.Context, address string, denom string) (*Balance, error)
	List(ctx context.Context, prefixKey BalanceIndexKey, opts ...ormlist.Option) (BalanceIterator, error)
	ListRange(ctx context.Context, from, to BalanceIndexKey, opts ...ormlist.Option) (BalanceIterator, error)
	HasByDenomAmount(ctx context.Context, denom string, amount uint64) (found bool, err error)
	GetByDenomAmount(ctx context.Context, denom string, amount uint64) (*Balance, error)
}

type BalanceIterator struct {
	ormtable.Iterator
}

func (i BalanceIterator) Value() (*Balance, error) {
	var balance Balance
	err := i.UnmarshalMessage(&balance)
	return &balance, err
}

type BalanceIndexKey interface {
	id() uint32
	values() []interface{}
	balanceIndexKey()
}

// primary key starting index..
type BalanceAddressDenomIndexKey struct {
	vs []interface{}
}

func (x BalanceAddressDenomIndexKey) id() uint32            { return 1 }
func (x BalanceAddressDenomIndexKey) values() []interface{} { return x.vs }
func (x BalanceAddressDenomIndexKey) balanceIndexKey()      {}

func (this BalanceAddressDenomIndexKey) WithAddress(address string) BalanceAddressDenomIndexKey {
	this.vs = []interface{}{address}
	return this
}

func (this BalanceAddressDenomIndexKey) WithAddressDenom(address string, denom string) BalanceAddressDenomIndexKey {
	this.vs = []interface{}{address, denom}
	return this
}

type BalanceDenomAmountIndexKey struct {
	vs []interface{}
}

func (x BalanceDenomAmountIndexKey) id() uint32            { return 1 }
func (x BalanceDenomAmountIndexKey) values() []interface{} { return x.vs }
func (x BalanceDenomAmountIndexKey) balanceIndexKey()      {}

func (this BalanceDenomAmountIndexKey) WithDenom(denom string) BalanceDenomAmountIndexKey {
	this.vs = []interface{}{denom}
	return this
}

func (this BalanceDenomAmountIndexKey) WithDenomAmount(denom string, amount uint64) BalanceDenomAmountIndexKey {
	this.vs = []interface{}{denom, amount}
	return this
}

type BalanceAmountIndexKey struct {
	vs []interface{}
}

func (x BalanceAmountIndexKey) id() uint32            { return 2 }
func (x BalanceAmountIndexKey) values() []interface{} { return x.vs }
func (x BalanceAmountIndexKey) balanceIndexKey()      {}

func (this BalanceAmountIndexKey) WithAmount(amount uint64) BalanceAmountIndexKey {
	this.vs = []interface{}{amount}
	return this
}

type BalanceAmountDenomAddressIndexKey struct {
	vs []interface{}
}

func (x BalanceAmountDenomAddressIndexKey) id() uint32            { return 3 }
func (x BalanceAmountDenomAddressIndexKey) values() []interface{} { return x.vs }
func (x BalanceAmountDenomAddressIndexKey) balanceIndexKey()      {}

func (this BalanceAmountDenomAddressIndexKey) WithAmount(amount uint64) BalanceAmountDenomAddressIndexKey {
	this.vs = []interface{}{amount}
	return this
}

func (this BalanceAmountDenomAddressIndexKey) WithAmountDenom(amount uint64, denom string) BalanceAmountDenomAddressIndexKey {
	this.vs = []interface{}{amount, denom}
	return this
}

func (this BalanceAmountDenomAddressIndexKey) WithAmountDenomAddress(amount uint64, denom string, address string) BalanceAmountDenomAddressIndexKey {
	this.vs = []interface{}{amount, denom, address}
	return this
}

type balanceStore struct {
	table ormtable.Table
}

func (this balanceStore) Insert(ctx context.Context, balance *Balance) error {
	return this.table.Insert(ctx, balance)
}
func (this balanceStore) Update(ctx context.Context, balance *Balance) error {
	return this.table.Update(ctx, balance)
}
func (this balanceStore) Save(ctx context.Context, balance *Balance) error {
	return this.table.Save(ctx, balance)
}
func (this balanceStore) Delete(ctx context.Context, balance *Balance) error {
	return this.table.Delete(ctx, balance)
}
func (this balanceStore) Has(ctx context.Context, address string, denom string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address, denom)
}
func (this balanceStore) Get(ctx context.Context, address string, denom string) (*Balance, error) {
	var balance Balance
	found, err := this.table.PrimaryKey().Get(ctx, &balance, address, denom)
	if !found {
		return nil, err
	}
	return &balance, err
}
func (this balanceStore) List(ctx context.Context, prefixKey BalanceIndexKey, opts ...ormlist.Option) (BalanceIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return BalanceIterator{it}, err
}
func (this balanceStore) ListRange(ctx context.Context, from, to BalanceIndexKey, opts ...ormlist.Option) (BalanceIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return BalanceIterator{it}, err
}
func (this balanceStore) HasByDenomAmount(ctx context.Context, denom string, amount uint64) (found bool, err error) {
	return this.table.Has(ctx, &Balance{
		Denom:  denom,
		Amount: amount,
	})
}
func (this balanceStore) GetByDenomAmount(ctx context.Context, denom string, amount uint64) (*Balance, error) {
	balance := &Balance{
		Denom:  denom,
		Amount: amount,
	}
	found, err := this.table.Get(ctx, balance)
	if !found {
		return nil, err
	}
	return balance, nil
}

var _ BalanceStore = balanceStore{}

func NewBalanceStore(db ormdb.ModuleDB) (BalanceStore, error) {
	table := db.GetTable(&Balance{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Balance{}).ProtoReflect().Descriptor().FullName()))
	}
	return balanceStore{table}, nil
}

type SupplyStore interface {
	Insert(ctx context.Context, supply *Supply) error
	Update(ctx context.Context, supply *Supply) error
	Save(ctx context.Context, supply *Supply) error
	Delete(ctx context.Context, supply *Supply) error
	Has(ctx context.Context, denom string) (found bool, err error)
	Get(ctx context.Context, denom string) (*Supply, error)
	List(ctx context.Context, prefixKey SupplyIndexKey, opts ...ormlist.Option) (SupplyIterator, error)
	ListRange(ctx context.Context, from, to SupplyIndexKey, opts ...ormlist.Option) (SupplyIterator, error)
}

type SupplyIterator struct {
	ormtable.Iterator
}

func (i SupplyIterator) Value() (*Supply, error) {
	var supply Supply
	err := i.UnmarshalMessage(&supply)
	return &supply, err
}

type SupplyIndexKey interface {
	id() uint32
	values() []interface{}
	supplyIndexKey()
}

// primary key starting index..
type SupplyDenomIndexKey struct {
	vs []interface{}
}

func (x SupplyDenomIndexKey) id() uint32            { return 2 }
func (x SupplyDenomIndexKey) values() []interface{} { return x.vs }
func (x SupplyDenomIndexKey) supplyIndexKey()       {}

func (this SupplyDenomIndexKey) WithDenom(denom string) SupplyDenomIndexKey {
	this.vs = []interface{}{denom}
	return this
}

type supplyStore struct {
	table ormtable.Table
}

func (this supplyStore) Insert(ctx context.Context, supply *Supply) error {
	return this.table.Insert(ctx, supply)
}
func (this supplyStore) Update(ctx context.Context, supply *Supply) error {
	return this.table.Update(ctx, supply)
}
func (this supplyStore) Save(ctx context.Context, supply *Supply) error {
	return this.table.Save(ctx, supply)
}
func (this supplyStore) Delete(ctx context.Context, supply *Supply) error {
	return this.table.Delete(ctx, supply)
}
func (this supplyStore) Has(ctx context.Context, denom string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, denom)
}
func (this supplyStore) Get(ctx context.Context, denom string) (*Supply, error) {
	var supply Supply
	found, err := this.table.PrimaryKey().Get(ctx, &supply, denom)
	if !found {
		return nil, err
	}
	return &supply, err
}
func (this supplyStore) List(ctx context.Context, prefixKey SupplyIndexKey, opts ...ormlist.Option) (SupplyIterator, error) {
	opts = append(opts, ormlist.Prefix(prefixKey.values()))
	it, err := this.table.GetIndexByID(prefixKey.id()).Iterator(ctx, opts...)
	return SupplyIterator{it}, err
}
func (this supplyStore) ListRange(ctx context.Context, from, to SupplyIndexKey, opts ...ormlist.Option) (SupplyIterator, error) {
	opts = append(opts, ormlist.Start(from.values()), ormlist.End(to))
	it, err := this.table.GetIndexByID(from.id()).Iterator(ctx, opts...)
	return SupplyIterator{it}, err
}

var _ SupplyStore = supplyStore{}

func NewSupplyStore(db ormdb.ModuleDB) (SupplyStore, error) {
	table := db.GetTable(&Supply{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Supply{}).ProtoReflect().Descriptor().FullName()))
	}
	return supplyStore{table}, nil
}

// singleton store
type ExampleStore interface {
	Get(ctx context.Context) (*Example, error)
	Save(ctx context.Context, example *Example) error
}

type exampleStore struct {
	table ormtable.Table
}

var _ ExampleStore = exampleStore{}

func (x exampleStore) Get(ctx context.Context) (*Example, error) {
	var example Example
	found, err := x.table.Get(ctx, &example)
	if !found {
		return nil, err
	}
	return &example, err
}

func (x exampleStore) Save(ctx context.Context, example *Example) error {
	return x.table.Save(ctx, example)
}

func NewExampleStore(db ormdb.ModuleDB) (ExampleStore, error) {
	table := db.GetTable(&Example{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Example{}).ProtoReflect().Descriptor().FullName()))
	}
	return &exampleStore{table}, nil
}

type StateStore interface {
	BalanceStore() BalanceStore
	SupplyStore() SupplyStore
	ExampleStore() ExampleStore
}

type stateStore struct {
	balance BalanceStore
	supply  SupplyStore
	example ExampleStore
}

func (x stateStore) BalanceStore() BalanceStore {
	return x.balance
}
func (x stateStore) SupplyStore() SupplyStore {
	return x.supply
}
func (x stateStore) ExampleStore() ExampleStore {
	return x.example
}

var _ StateStore = stateStore{}

func NewStateStore(db ormdb.ModuleDB) (StateStore, error) {
	balanceStore, err := NewBalanceStore(db)
	if err != nil {
		return nil, err
	}

	supplyStore, err := NewSupplyStore(db)
	if err != nil {
		return nil, err
	}

	exampleStore, err := NewExampleStore(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		balanceStore,
		supplyStore,
		exampleStore,
	}, nil
}
