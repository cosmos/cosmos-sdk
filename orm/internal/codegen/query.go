package codegen

import (
	"bytes"
	"fmt"
	"os"

	ormv1 "cosmossdk.io/api/cosmos/orm/v1"
	"github.com/iancoleman/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/cosmos/cosmos-sdk/orm/internal/fieldnames"
)

type queryProtoGen struct {
	*protogen.File
	imports map[string]bool
	svc     *writer
	msgs    *writer
	outFile *os.File
}

func (g queryProtoGen) gen() error {
	g.imports[g.Desc.Path()] = true

	g.svc.F("service %s {", g.queryServiceName())
	g.svc.Indent()
	for _, msg := range g.Messages {
		tableDesc := proto.GetExtension(msg.Desc.Options(), ormv1.E_Table).(*ormv1.TableDescriptor)
		if tableDesc != nil {
			err := g.genTableRPCMethods(msg, tableDesc)
			if err != nil {
				return err
			}
		}
		singletonDesc := proto.GetExtension(msg.Desc.Options(), ormv1.E_Singleton).(*ormv1.SingletonDescriptor)
		if singletonDesc != nil {
			err := g.genSingletonRPCMethods(msg)
			if err != nil {
				return err
			}
		}
	}
	g.svc.Dedent()
	g.svc.F("}")
	g.svc.F("")

	outBuf := newWriter()
	outBuf.F("// Code generated by protoc-gen-go-cosmos-orm-proto. DO NOT EDIT.")
	outBuf.F(`syntax = "proto3";`)
	outBuf.F("package %s;", g.Desc.Package())
	outBuf.F("")

	imports := maps.Keys(g.imports)
	slices.Sort(imports)
	for _, i := range imports {
		outBuf.F(`import "%s";`, i)
	}
	outBuf.F("")

	_, err := outBuf.Write(g.svc.Bytes())
	if err != nil {
		return err
	}

	_, err = outBuf.Write(g.msgs.Bytes())
	if err != nil {
		return err
	}

	_, err = g.outFile.Write(outBuf.Bytes())
	if err != nil {
		return err
	}

	return g.outFile.Close()
}

func (g queryProtoGen) genTableRPCMethods(msg *protogen.Message, desc *ormv1.TableDescriptor) error {
	name := msg.Desc.Name()
	g.svc.F("rpc Get%s (Get%sRequest) returns (Get%sResponse) {}", name, name, name) // TODO grpc gateway
	g.msgs.F("message Get%sRequest {", name)
	g.msgs.Indent()
	primaryKeyFields := fieldnames.CommaSeparatedFieldNames(desc.PrimaryKey.Fields)
	fields := msg.Desc.Fields()
	for i, fieldName := range primaryKeyFields.Names() {
		field := fields.ByName(fieldName)
		if field == nil {
			return fmt.Errorf("can't find primary key field %s", fieldName)
		}
		g.msgs.F("%s %s = %d;", g.fieldType(field), fieldName, i+1)
	}
	g.msgs.Dedent()

	g.msgs.F("}")
	g.msgs.F("")
	g.msgs.F("message Get%sResponse {", name)
	g.msgs.Indent()
	g.msgs.F("%s value = 1;", name)
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")

	for _, idx := range desc.Index {
		if !idx.Unique {
			continue
		}

		fieldsCamel := fieldsToCamelCase(idx.Fields)
		methodName := fmt.Sprintf("Get%sBy%s", name, fieldsCamel)
		g.svc.F("rpc %s (%sRequest) returns (%sResponse) {}", methodName, methodName, methodName) // TODO grpc gateway

		g.msgs.F("message %sRequest {", methodName)
		g.msgs.Indent()
		fieldNames := fieldnames.CommaSeparatedFieldNames(idx.Fields)
		for i, fieldName := range fieldNames.Names() {
			field := fields.ByName(fieldName)
			if field == nil {
				return fmt.Errorf("can't find unique index field %s", fieldName)
			}
			g.msgs.F("%s %s = %d;", g.fieldType(field), fieldName, i+1)
		}
		g.msgs.Dedent()

		g.msgs.F("}")
		g.msgs.F("")
		g.msgs.F("message %sResponse {", methodName)
		g.msgs.Indent()
		g.msgs.F("%s value = 1;", name)
		g.msgs.Dedent()
		g.msgs.F("}")
		g.msgs.F("")
	}

	g.imports["cosmos/base/query/v1beta1/pagination.proto"] = true
	g.svc.F("rpc List%s (List%sRequest) returns (List%sResponse) {}", name, name, name) // TODO grpc gateway
	g.msgs.F("message List%sRequest {", name)
	g.msgs.Indent()
	g.msgs.F("message IndexKey {")
	g.msgs.Indent()
	indexFields := []string{desc.PrimaryKey.Fields}
	for _, index := range desc.Index {
		indexFields = append(indexFields, index.Fields)
	}

	for _, fieldNames := range indexFields {
		g.msgs.F("message %s {", fieldsToCamelCase(fieldNames))
		g.msgs.Indent()
		for i, fieldName := range fieldnames.CommaSeparatedFieldNames(fieldNames).Names() {
			g.msgs.F("%s %s = %d;", g.fieldType(fields.ByName(fieldName)), fieldName, i+1)
		}
		g.msgs.Dedent()
		g.msgs.F("}")
		g.msgs.F("")
	}

	g.msgs.F("oneof index {")
	g.msgs.Indent()
	for i, fields := range indexFields {
		g.msgs.F("%s %s = %d;", fieldsToCamelCase(fields), fieldsToSnakeCase(fields), i+1)
	}
	g.msgs.Dedent()
	g.msgs.F("}")

	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	g.msgs.F("message RangeQuery {")
	g.msgs.Indent()
	g.msgs.F("IndexKey from = 1;")
	g.msgs.F("IndexKey to = 2;")
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	g.msgs.F("oneof query {")
	g.msgs.Indent()
	g.msgs.F("IndexKey prefix_query = 1;")
	g.msgs.F("RangeQuery range_query = 2;")
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("cosmos.base.query.v1beta1.PageRequest pagination = 3;")
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	g.msgs.F("message List%sResponse {", name)
	g.msgs.Indent()
	g.msgs.F("repeated %s values = 1;", name)
	g.msgs.F("cosmos.base.query.v1beta1.PageResponse pagination = 2;")
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	return nil
}

func (g queryProtoGen) genSingletonRPCMethods(msg *protogen.Message) error {
	name := msg.Desc.Name()
	g.svc.F("rpc Get%s (Get%sRequest) returns (Get%sResponse) {}", name, name, name) // TODO grpc gateway
	g.msgs.F("message Get%sRequest {}", name)
	g.msgs.F("")
	g.msgs.F("message Get%sResponse {", name)
	g.msgs.Indent()
	g.msgs.F("%s value = 1;", name)
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	return nil
}

func (g queryProtoGen) queryServiceName() string {
	return fmt.Sprintf("%sQuery", strcase.ToCamel(fileShortName(g.File)))
}

func (g queryProtoGen) fieldType(descriptor protoreflect.FieldDescriptor) string {
	if descriptor.Kind() == protoreflect.MessageKind {
		message := descriptor.Message()
		g.imports[message.ParentFile().Path()] = true
		return string(message.FullName())
	}

	return descriptor.Kind().String()
}

type writer struct {
	*bytes.Buffer
	indent    int
	indentStr string
}

func newWriter() *writer {
	return &writer{
		Buffer: &bytes.Buffer{},
	}
}

func (w *writer) F(format string, args ...interface{}) {
	_, err := w.Write([]byte(w.indentStr))
	if err != nil {
		panic(err)
	}

	_, err = fmt.Fprintf(w, format, args...)
	if err != nil {
		panic(err)
	}

	_, err = fmt.Fprintln(w)
	if err != nil {
		panic(err)
	}

}

func (w *writer) Indent() {
	w.indent += 1
	w.updateIndent()
}

func (w *writer) updateIndent() {
	w.indentStr = ""
	for i := 0; i < w.indent; i++ {
		w.indentStr += "  "
	}
}

func (w *writer) Dedent() {
	w.indent -= 1
	w.updateIndent()
}
