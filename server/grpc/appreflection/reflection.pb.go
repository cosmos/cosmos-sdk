// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/base/reflection/v1beta1/reflection.proto

package appreflection

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AppDescriptor describes a cosmos-sdk based application
type AppDescriptor struct {
	// chain provides the chain descriptor
	Chain *ChainDescriptor `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	// codec provides metadata information regarding codec related types
	Codec *CodecDescriptor `protobuf:"bytes,3,opt,name=codec,proto3" json:"codec,omitempty"`
	// configuration provides metadata information regarding the sdk.Config type
	Configuration *ConfigurationDescriptor `protobuf:"bytes,4,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// query_services provides metadata information regarding the available queriable endpoints
	QueryServices *QueryServicesDescriptor `protobuf:"bytes,5,opt,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
	// tx provides metadata information regarding how to send transactions to the given application
	Tx *TxDescriptor `protobuf:"bytes,6,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *AppDescriptor) Reset()         { *m = AppDescriptor{} }
func (m *AppDescriptor) String() string { return proto.CompactTextString(m) }
func (*AppDescriptor) ProtoMessage()    {}
func (*AppDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{0}
}
func (m *AppDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppDescriptor.Merge(m, src)
}
func (m *AppDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AppDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AppDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AppDescriptor proto.InternalMessageInfo

func (m *AppDescriptor) GetChain() *ChainDescriptor {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *AppDescriptor) GetCodec() *CodecDescriptor {
	if m != nil {
		return m.Codec
	}
	return nil
}

func (m *AppDescriptor) GetConfiguration() *ConfigurationDescriptor {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *AppDescriptor) GetQueryServices() *QueryServicesDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

func (m *AppDescriptor) GetTx() *TxDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

// TxDescriptor describes the accepted transaction type
type TxDescriptor struct {
	// fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
	// it is not meant to support polymorphism of transaction types, it is supposed to be used by
	// reflection clients to understand if they can handle a specific transaction type in an application.
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// authn provides information on how to authenticate a transaction in offline mode
	Authn *AuthnDescriptor `protobuf:"bytes,2,opt,name=authn,proto3" json:"authn,omitempty"`
	// msgs lists the accepted application messages (sdk.ServiceMsg, sdk.Msg)
	// NOTE: not to be confused with proto.Message types
	Msgs []*MsgDescriptor `protobuf:"bytes,3,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *TxDescriptor) Reset()         { *m = TxDescriptor{} }
func (m *TxDescriptor) String() string { return proto.CompactTextString(m) }
func (*TxDescriptor) ProtoMessage()    {}
func (*TxDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{1}
}
func (m *TxDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDescriptor.Merge(m, src)
}
func (m *TxDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TxDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TxDescriptor proto.InternalMessageInfo

func (m *TxDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *TxDescriptor) GetAuthn() *AuthnDescriptor {
	if m != nil {
		return m.Authn
	}
	return nil
}

func (m *TxDescriptor) GetMsgs() []*MsgDescriptor {
	if m != nil {
		return m.Msgs
	}
	return nil
}

// AuthnDescriptor provides information on how to sign transactions without relying
// on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
type AuthnDescriptor struct {
	// sign_modes defines the supported signature algorithm
	SignModes []*SigningModeDescriptor `protobuf:"bytes,1,rep,name=sign_modes,json=signModes,proto3" json:"sign_modes,omitempty"`
}

func (m *AuthnDescriptor) Reset()         { *m = AuthnDescriptor{} }
func (m *AuthnDescriptor) String() string { return proto.CompactTextString(m) }
func (*AuthnDescriptor) ProtoMessage()    {}
func (*AuthnDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{2}
}
func (m *AuthnDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthnDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthnDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnDescriptor.Merge(m, src)
}
func (m *AuthnDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AuthnDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnDescriptor proto.InternalMessageInfo

func (m *AuthnDescriptor) GetSignModes() []*SigningModeDescriptor {
	if m != nil {
		return m.SignModes
	}
	return nil
}

// SigningModeDescriptor provides information on a signing flow of the application
// NOTE(fdymylja): here we could go as far as providing an entire flow on how
// to sign a message given a SigningModeDescriptor, but it's better to think about
// this another time
type SigningModeDescriptor struct {
	// name defines the unique name of the signing mode
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// number is the unique int32 identifier for the sign_mode enum
	Number int32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	// authn_info_provider_method_fullname defines the fullname of the method to call to get
	// the metadata required to authenticate using the provided sign_modes
	AuthnInfoProviderMethodFullname string `protobuf:"bytes,3,opt,name=authn_info_provider_method_fullname,json=authnInfoProviderMethodFullname,proto3" json:"authn_info_provider_method_fullname,omitempty"`
}

func (m *SigningModeDescriptor) Reset()         { *m = SigningModeDescriptor{} }
func (m *SigningModeDescriptor) String() string { return proto.CompactTextString(m) }
func (*SigningModeDescriptor) ProtoMessage()    {}
func (*SigningModeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{3}
}
func (m *SigningModeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningModeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningModeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningModeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningModeDescriptor.Merge(m, src)
}
func (m *SigningModeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SigningModeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningModeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SigningModeDescriptor proto.InternalMessageInfo

func (m *SigningModeDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SigningModeDescriptor) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *SigningModeDescriptor) GetAuthnInfoProviderMethodFullname() string {
	if m != nil {
		return m.AuthnInfoProviderMethodFullname
	}
	return ""
}

// ChainDescriptor describes chain information of the application
type ChainDescriptor struct {
	// id is the chain id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ChainDescriptor) Reset()         { *m = ChainDescriptor{} }
func (m *ChainDescriptor) String() string { return proto.CompactTextString(m) }
func (*ChainDescriptor) ProtoMessage()    {}
func (*ChainDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{4}
}
func (m *ChainDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainDescriptor.Merge(m, src)
}
func (m *ChainDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ChainDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ChainDescriptor proto.InternalMessageInfo

func (m *ChainDescriptor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// CodecDescriptor describes the registered interfaces and provides metadata information on the types
type CodecDescriptor struct {
	// interfaces is a list of the registerted interfaces descriptors
	Interfaces []*InterfaceDescriptor `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
}

func (m *CodecDescriptor) Reset()         { *m = CodecDescriptor{} }
func (m *CodecDescriptor) String() string { return proto.CompactTextString(m) }
func (*CodecDescriptor) ProtoMessage()    {}
func (*CodecDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{5}
}
func (m *CodecDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecDescriptor.Merge(m, src)
}
func (m *CodecDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CodecDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CodecDescriptor proto.InternalMessageInfo

func (m *CodecDescriptor) GetInterfaces() []*InterfaceDescriptor {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// InterfaceDescriptor describes the implementation of an interface
type InterfaceDescriptor struct {
	// fullname is the name of the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// interface_accepting_messages contains information regarding the proto messages which contain the interface as google.protobuf.Any field
	InterfaceAcceptingMessages []*InterfaceAcceptingMessageDescriptor `protobuf:"bytes,2,rep,name=interface_accepting_messages,json=interfaceAcceptingMessages,proto3" json:"interface_accepting_messages,omitempty"`
	// interface_implementers is a list of the descriptors of the interface implementers
	InterfaceImplementers []*InterfaceImplementerDescriptor `protobuf:"bytes,3,rep,name=interface_implementers,json=interfaceImplementers,proto3" json:"interface_implementers,omitempty"`
}

func (m *InterfaceDescriptor) Reset()         { *m = InterfaceDescriptor{} }
func (m *InterfaceDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceDescriptor) ProtoMessage()    {}
func (*InterfaceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{6}
}
func (m *InterfaceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDescriptor.Merge(m, src)
}
func (m *InterfaceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDescriptor proto.InternalMessageInfo

func (m *InterfaceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceDescriptor) GetInterfaceAcceptingMessages() []*InterfaceAcceptingMessageDescriptor {
	if m != nil {
		return m.InterfaceAcceptingMessages
	}
	return nil
}

func (m *InterfaceDescriptor) GetInterfaceImplementers() []*InterfaceImplementerDescriptor {
	if m != nil {
		return m.InterfaceImplementers
	}
	return nil
}

// InterfaceImplementerDescriptor describes an interface implementer
type InterfaceImplementerDescriptor struct {
	// fullname is the protobuf queryable name of the interface implementer
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// type_url defines the type URL used when marshalling the type as any
	// this is required so we can provide type safe google.protobuf.Any marshalling and
	// unmarshalling, making sure that we don't accept just 'any' type
	// in our interface fields
	TypeUrl string `protobuf:"bytes,2,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
}

func (m *InterfaceImplementerDescriptor) Reset()         { *m = InterfaceImplementerDescriptor{} }
func (m *InterfaceImplementerDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceImplementerDescriptor) ProtoMessage()    {}
func (*InterfaceImplementerDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{7}
}
func (m *InterfaceImplementerDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceImplementerDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceImplementerDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceImplementerDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceImplementerDescriptor.Merge(m, src)
}
func (m *InterfaceImplementerDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceImplementerDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceImplementerDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceImplementerDescriptor proto.InternalMessageInfo

func (m *InterfaceImplementerDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceImplementerDescriptor) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

// InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
// an interface represented as a google.protobuf.Any
type InterfaceAcceptingMessageDescriptor struct {
	// fullname is the protobuf fullname of the type containing the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// field_descriptor_names is a list of the protobuf name (not fullname) of the field
	// which contains the interface as google.protobuf.Any (the interface is the same, but
	// it can be in multiple fields of the same proto message)
	FieldDescriptorNames []string `protobuf:"bytes,2,rep,name=field_descriptor_names,json=fieldDescriptorNames,proto3" json:"field_descriptor_names,omitempty"`
}

func (m *InterfaceAcceptingMessageDescriptor) Reset()         { *m = InterfaceAcceptingMessageDescriptor{} }
func (m *InterfaceAcceptingMessageDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceAcceptingMessageDescriptor) ProtoMessage()    {}
func (*InterfaceAcceptingMessageDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{8}
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceAcceptingMessageDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceAcceptingMessageDescriptor.Merge(m, src)
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceAcceptingMessageDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceAcceptingMessageDescriptor proto.InternalMessageInfo

func (m *InterfaceAcceptingMessageDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceAcceptingMessageDescriptor) GetFieldDescriptorNames() []string {
	if m != nil {
		return m.FieldDescriptorNames
	}
	return nil
}

// ConfigurationDescriptor contains metadata information on the sdk.Config
type ConfigurationDescriptor struct {
	// bech32_account_address_prefix is the account address prefix
	Bech32AccountAddressPrefix string `protobuf:"bytes,1,opt,name=bech32_account_address_prefix,json=bech32AccountAddressPrefix,proto3" json:"bech32_account_address_prefix,omitempty"`
}

func (m *ConfigurationDescriptor) Reset()         { *m = ConfigurationDescriptor{} }
func (m *ConfigurationDescriptor) String() string { return proto.CompactTextString(m) }
func (*ConfigurationDescriptor) ProtoMessage()    {}
func (*ConfigurationDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{9}
}
func (m *ConfigurationDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigurationDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigurationDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationDescriptor.Merge(m, src)
}
func (m *ConfigurationDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationDescriptor proto.InternalMessageInfo

func (m *ConfigurationDescriptor) GetBech32AccountAddressPrefix() string {
	if m != nil {
		return m.Bech32AccountAddressPrefix
	}
	return ""
}

// MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
type MsgDescriptor struct {
	// msg contains a descriptor of sdk.ServiceMsg, note: sdk.Msg is not supported
	// as every sdk.Msg is already an sdk.ServiceMsg. It is defined as a oneof in case
	// different representation of a msg will be implemented.
	//
	// Types that are valid to be assigned to Msg:
	//	*MsgDescriptor_ServiceMsg
	Msg isMsgDescriptor_Msg `protobuf_oneof:"msg"`
}

func (m *MsgDescriptor) Reset()         { *m = MsgDescriptor{} }
func (m *MsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*MsgDescriptor) ProtoMessage()    {}
func (*MsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{10}
}
func (m *MsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDescriptor.Merge(m, src)
}
func (m *MsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *MsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDescriptor proto.InternalMessageInfo

type isMsgDescriptor_Msg interface {
	isMsgDescriptor_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgDescriptor_ServiceMsg struct {
	ServiceMsg *ServiceMsgDescriptor `protobuf:"bytes,1,opt,name=service_msg,json=serviceMsg,proto3,oneof" json:"service_msg,omitempty"`
}

func (*MsgDescriptor_ServiceMsg) isMsgDescriptor_Msg() {}

func (m *MsgDescriptor) GetMsg() isMsgDescriptor_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *MsgDescriptor) GetServiceMsg() *ServiceMsgDescriptor {
	if x, ok := m.GetMsg().(*MsgDescriptor_ServiceMsg); ok {
		return x.ServiceMsg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgDescriptor) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgDescriptor_ServiceMsg)(nil),
	}
}

// ServiceMsgDescriptor describes an sdk.ServiceMsg type
type ServiceMsgDescriptor struct {
	// request_fullname is the protobuf fullname of the given sdk.ServiceMsg request
	// this is the protobuf message type which should be used as google.protobuf.Any.value
	// when delivering the msg to the DeliverTx endpoint
	RequestFullname string `protobuf:"bytes,1,opt,name=request_fullname,json=requestFullname,proto3" json:"request_fullname,omitempty"`
	// request_route is the sdk.ServiceMsg route, it is equal to type_url
	RequestRoute string `protobuf:"bytes,2,opt,name=request_route,json=requestRoute,proto3" json:"request_route,omitempty"`
	// request_type_url is the identifier that should be used as google.protobuf.Any.type_url
	// when delivering the msg to the DeliverTx endpoint
	RequestTypeUrl string `protobuf:"bytes,3,opt,name=request_type_url,json=requestTypeUrl,proto3" json:"request_type_url,omitempty"`
	// response_fullname is the protobuf fullname of the given sdk.ServiceMsg response
	ResponseFullname string `protobuf:"bytes,4,opt,name=response_fullname,json=responseFullname,proto3" json:"response_fullname,omitempty"`
}

func (m *ServiceMsgDescriptor) Reset()         { *m = ServiceMsgDescriptor{} }
func (m *ServiceMsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*ServiceMsgDescriptor) ProtoMessage()    {}
func (*ServiceMsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{11}
}
func (m *ServiceMsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceMsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceMsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceMsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceMsgDescriptor.Merge(m, src)
}
func (m *ServiceMsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ServiceMsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceMsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceMsgDescriptor proto.InternalMessageInfo

func (m *ServiceMsgDescriptor) GetRequestFullname() string {
	if m != nil {
		return m.RequestFullname
	}
	return ""
}

func (m *ServiceMsgDescriptor) GetRequestRoute() string {
	if m != nil {
		return m.RequestRoute
	}
	return ""
}

func (m *ServiceMsgDescriptor) GetRequestTypeUrl() string {
	if m != nil {
		return m.RequestTypeUrl
	}
	return ""
}

func (m *ServiceMsgDescriptor) GetResponseFullname() string {
	if m != nil {
		return m.ResponseFullname
	}
	return ""
}

// GetAppDescriptorRequest is the request type of the GetAppDescriptor RPC.
type GetAppDescriptorRequest struct {
}

func (m *GetAppDescriptorRequest) Reset()         { *m = GetAppDescriptorRequest{} }
func (m *GetAppDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetAppDescriptorRequest) ProtoMessage()    {}
func (*GetAppDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{12}
}
func (m *GetAppDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppDescriptorRequest.Merge(m, src)
}
func (m *GetAppDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAppDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppDescriptorRequest proto.InternalMessageInfo

// GetAppDescriptorResponse is the response type of the GetAppDescriptor RPC.
type GetAppDescriptorResponse struct {
	// app contains the cosmos-sdk application descriptor
	App *AppDescriptor `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
}

func (m *GetAppDescriptorResponse) Reset()         { *m = GetAppDescriptorResponse{} }
func (m *GetAppDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetAppDescriptorResponse) ProtoMessage()    {}
func (*GetAppDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{13}
}
func (m *GetAppDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppDescriptorResponse.Merge(m, src)
}
func (m *GetAppDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAppDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppDescriptorResponse proto.InternalMessageInfo

func (m *GetAppDescriptorResponse) GetApp() *AppDescriptor {
	if m != nil {
		return m.App
	}
	return nil
}

// QueryServicesDescriptor contains the list of cosmos-sdk queriable services
type QueryServicesDescriptor struct {
	// query_services is a list of cosmos-sdk QueryServiceDescriptor
	QueryServices []*QueryServiceDescriptor `protobuf:"bytes,1,rep,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
}

func (m *QueryServicesDescriptor) Reset()         { *m = QueryServicesDescriptor{} }
func (m *QueryServicesDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServicesDescriptor) ProtoMessage()    {}
func (*QueryServicesDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{14}
}
func (m *QueryServicesDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServicesDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServicesDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServicesDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServicesDescriptor.Merge(m, src)
}
func (m *QueryServicesDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServicesDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServicesDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServicesDescriptor proto.InternalMessageInfo

func (m *QueryServicesDescriptor) GetQueryServices() []*QueryServiceDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

// QueryServiceDescriptor describes a cosmos-sdk queryable service
type QueryServiceDescriptor struct {
	// fullname is the protobuf fullname of the service descriptor
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// methods provides a list of query service methods
	Methods []*QueryMethodDescriptor `protobuf:"bytes,2,rep,name=methods,proto3" json:"methods,omitempty"`
}

func (m *QueryServiceDescriptor) Reset()         { *m = QueryServiceDescriptor{} }
func (m *QueryServiceDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServiceDescriptor) ProtoMessage()    {}
func (*QueryServiceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{15}
}
func (m *QueryServiceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServiceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServiceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServiceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServiceDescriptor.Merge(m, src)
}
func (m *QueryServiceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServiceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServiceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServiceDescriptor proto.InternalMessageInfo

func (m *QueryServiceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *QueryServiceDescriptor) GetMethods() []*QueryMethodDescriptor {
	if m != nil {
		return m.Methods
	}
	return nil
}

// QueryMethodDescriptor describes a queryable method of a query service
// no other info is provided beside method name and tendermint queryable path
// because it would be redundant with the grpc reflection service
type QueryMethodDescriptor struct {
	// name is the protobuf name (not fullname) of the method
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// full_query_path is the path that can be used to query
	// this method via tendermint abci.Query
	FullQueryPath string `protobuf:"bytes,2,opt,name=full_query_path,json=fullQueryPath,proto3" json:"full_query_path,omitempty"`
}

func (m *QueryMethodDescriptor) Reset()         { *m = QueryMethodDescriptor{} }
func (m *QueryMethodDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryMethodDescriptor) ProtoMessage()    {}
func (*QueryMethodDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{16}
}
func (m *QueryMethodDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMethodDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMethodDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMethodDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMethodDescriptor.Merge(m, src)
}
func (m *QueryMethodDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryMethodDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMethodDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMethodDescriptor proto.InternalMessageInfo

func (m *QueryMethodDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryMethodDescriptor) GetFullQueryPath() string {
	if m != nil {
		return m.FullQueryPath
	}
	return ""
}

// ListAllInterfacesRequest is the request type of the ListAllInterfaces RPC.
type ListAllInterfacesRequest struct {
}

func (m *ListAllInterfacesRequest) Reset()         { *m = ListAllInterfacesRequest{} }
func (m *ListAllInterfacesRequest) String() string { return proto.CompactTextString(m) }
func (*ListAllInterfacesRequest) ProtoMessage()    {}
func (*ListAllInterfacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{17}
}
func (m *ListAllInterfacesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllInterfacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllInterfacesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllInterfacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllInterfacesRequest.Merge(m, src)
}
func (m *ListAllInterfacesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAllInterfacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllInterfacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllInterfacesRequest proto.InternalMessageInfo

// ListAllInterfacesResponse is the response type of the ListAllInterfaces RPC.
type ListAllInterfacesResponse struct {
	// interface_names is an array of all the registered interfaces.
	InterfaceNames []string `protobuf:"bytes,1,rep,name=interface_names,json=interfaceNames,proto3" json:"interface_names,omitempty"`
}

func (m *ListAllInterfacesResponse) Reset()         { *m = ListAllInterfacesResponse{} }
func (m *ListAllInterfacesResponse) String() string { return proto.CompactTextString(m) }
func (*ListAllInterfacesResponse) ProtoMessage()    {}
func (*ListAllInterfacesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{18}
}
func (m *ListAllInterfacesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllInterfacesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllInterfacesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllInterfacesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllInterfacesResponse.Merge(m, src)
}
func (m *ListAllInterfacesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAllInterfacesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllInterfacesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllInterfacesResponse proto.InternalMessageInfo

func (m *ListAllInterfacesResponse) GetInterfaceNames() []string {
	if m != nil {
		return m.InterfaceNames
	}
	return nil
}

// ListImplementationsRequest is the request type of the ListImplementations
// RPC.
type ListImplementationsRequest struct {
	// interface_name defines the interface to query the implementations for.
	InterfaceName string `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
}

func (m *ListImplementationsRequest) Reset()         { *m = ListImplementationsRequest{} }
func (m *ListImplementationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListImplementationsRequest) ProtoMessage()    {}
func (*ListImplementationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{19}
}
func (m *ListImplementationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListImplementationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListImplementationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListImplementationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListImplementationsRequest.Merge(m, src)
}
func (m *ListImplementationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListImplementationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListImplementationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListImplementationsRequest proto.InternalMessageInfo

func (m *ListImplementationsRequest) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

// ListImplementationsResponse is the response type of the ListImplementations
// RPC.
type ListImplementationsResponse struct {
	ImplementationMessageNames []string `protobuf:"bytes,1,rep,name=implementation_message_names,json=implementationMessageNames,proto3" json:"implementation_message_names,omitempty"`
}

func (m *ListImplementationsResponse) Reset()         { *m = ListImplementationsResponse{} }
func (m *ListImplementationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListImplementationsResponse) ProtoMessage()    {}
func (*ListImplementationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{20}
}
func (m *ListImplementationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListImplementationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListImplementationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListImplementationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListImplementationsResponse.Merge(m, src)
}
func (m *ListImplementationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListImplementationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListImplementationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListImplementationsResponse proto.InternalMessageInfo

func (m *ListImplementationsResponse) GetImplementationMessageNames() []string {
	if m != nil {
		return m.ImplementationMessageNames
	}
	return nil
}

func init() {
	proto.RegisterType((*AppDescriptor)(nil), "cosmos.base.reflection.v1beta1.AppDescriptor")
	proto.RegisterType((*TxDescriptor)(nil), "cosmos.base.reflection.v1beta1.TxDescriptor")
	proto.RegisterType((*AuthnDescriptor)(nil), "cosmos.base.reflection.v1beta1.AuthnDescriptor")
	proto.RegisterType((*SigningModeDescriptor)(nil), "cosmos.base.reflection.v1beta1.SigningModeDescriptor")
	proto.RegisterType((*ChainDescriptor)(nil), "cosmos.base.reflection.v1beta1.ChainDescriptor")
	proto.RegisterType((*CodecDescriptor)(nil), "cosmos.base.reflection.v1beta1.CodecDescriptor")
	proto.RegisterType((*InterfaceDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceDescriptor")
	proto.RegisterType((*InterfaceImplementerDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceImplementerDescriptor")
	proto.RegisterType((*InterfaceAcceptingMessageDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceAcceptingMessageDescriptor")
	proto.RegisterType((*ConfigurationDescriptor)(nil), "cosmos.base.reflection.v1beta1.ConfigurationDescriptor")
	proto.RegisterType((*MsgDescriptor)(nil), "cosmos.base.reflection.v1beta1.MsgDescriptor")
	proto.RegisterType((*ServiceMsgDescriptor)(nil), "cosmos.base.reflection.v1beta1.ServiceMsgDescriptor")
	proto.RegisterType((*GetAppDescriptorRequest)(nil), "cosmos.base.reflection.v1beta1.GetAppDescriptorRequest")
	proto.RegisterType((*GetAppDescriptorResponse)(nil), "cosmos.base.reflection.v1beta1.GetAppDescriptorResponse")
	proto.RegisterType((*QueryServicesDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryServicesDescriptor")
	proto.RegisterType((*QueryServiceDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryServiceDescriptor")
	proto.RegisterType((*QueryMethodDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryMethodDescriptor")
	proto.RegisterType((*ListAllInterfacesRequest)(nil), "cosmos.base.reflection.v1beta1.ListAllInterfacesRequest")
	proto.RegisterType((*ListAllInterfacesResponse)(nil), "cosmos.base.reflection.v1beta1.ListAllInterfacesResponse")
	proto.RegisterType((*ListImplementationsRequest)(nil), "cosmos.base.reflection.v1beta1.ListImplementationsRequest")
	proto.RegisterType((*ListImplementationsResponse)(nil), "cosmos.base.reflection.v1beta1.ListImplementationsResponse")
}

func init() {
	proto.RegisterFile("cosmos/base/reflection/v1beta1/reflection.proto", fileDescriptor_d48c054165687f5c)
}

var fileDescriptor_d48c054165687f5c = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4b, 0x73, 0xdb, 0x54,
	0x14, 0x8e, 0xec, 0xa4, 0x6d, 0x4e, 0xea, 0xb8, 0xbd, 0x6d, 0x12, 0xc7, 0x04, 0x13, 0x94, 0x01,
	0x02, 0xb4, 0x36, 0x75, 0xda, 0xf0, 0x1c, 0xc0, 0x4d, 0x79, 0x64, 0x68, 0x20, 0x38, 0x61, 0x3a,
	0x03, 0x14, 0x8d, 0x2c, 0x5d, 0xcb, 0x77, 0xb0, 0x74, 0x15, 0x5d, 0x39, 0xa4, 0xc3, 0xb0, 0x61,
	0xa6, 0x7b, 0x18, 0x76, 0xfc, 0x0a, 0x16, 0x2c, 0xe9, 0x9e, 0x65, 0x67, 0xd8, 0xb0, 0x64, 0x12,
	0x7e, 0x04, 0x4b, 0xe6, 0x3e, 0x24, 0x4b, 0x89, 0x6c, 0xb9, 0x5d, 0x25, 0x3a, 0xe7, 0xfb, 0x3e,
	0x9d, 0xd7, 0x3d, 0x57, 0x86, 0x86, 0x45, 0x99, 0x4b, 0x59, 0xa3, 0x63, 0x32, 0xdc, 0x08, 0x70,
	0xb7, 0x8f, 0xad, 0x90, 0x50, 0xaf, 0x71, 0x78, 0xa3, 0x83, 0x43, 0xf3, 0x46, 0xc2, 0x54, 0xf7,
	0x03, 0x1a, 0x52, 0x54, 0x93, 0x84, 0x3a, 0x27, 0xd4, 0x13, 0x5e, 0x45, 0xa8, 0xae, 0x38, 0x94,
	0x3a, 0x7d, 0xdc, 0x30, 0x7d, 0xd2, 0x30, 0x3d, 0x8f, 0x86, 0x26, 0x77, 0x33, 0xc9, 0xd6, 0x7f,
	0x2d, 0x42, 0xa9, 0xe5, 0xfb, 0x77, 0x30, 0xb3, 0x02, 0xe2, 0x87, 0x34, 0x40, 0x1f, 0xc0, 0x8c,
	0xd5, 0x33, 0x89, 0x57, 0x29, 0xac, 0x6a, 0xeb, 0x73, 0xcd, 0x46, 0x7d, 0xbc, 0x7e, 0x7d, 0x8b,
	0x83, 0x87, 0xfc, 0xb6, 0x64, 0x0b, 0x19, 0x6a, 0x63, 0xab, 0x52, 0x9c, 0x50, 0x86, 0x83, 0x53,
	0x32, 0xdc, 0x80, 0xee, 0x43, 0xc9, 0xa2, 0x5e, 0x97, 0x38, 0x83, 0x40, 0xc4, 0x5d, 0x99, 0x16,
	0x72, 0xaf, 0xe7, 0xcb, 0x25, 0x48, 0x09, 0xd9, 0xb4, 0x1a, 0xfa, 0x06, 0xe6, 0x0f, 0x06, 0x38,
	0x78, 0x60, 0x30, 0x1c, 0x1c, 0x12, 0x0b, 0xb3, 0xca, 0xcc, 0x64, 0xfa, 0x9f, 0x73, 0xd6, 0x9e,
	0x22, 0x25, 0xf5, 0x0f, 0x92, 0x0e, 0xf4, 0x0e, 0x14, 0xc2, 0xa3, 0xca, 0x39, 0xa1, 0x79, 0x2d,
	0x4f, 0x73, 0xff, 0x28, 0x21, 0x54, 0x08, 0x8f, 0xf4, 0xdf, 0x35, 0xb8, 0x98, 0x34, 0xa2, 0x2a,
	0x5c, 0xe8, 0x0e, 0xfa, 0x7d, 0xcf, 0x74, 0x71, 0x45, 0x5b, 0xd5, 0xd6, 0x67, 0xdb, 0xf1, 0x33,
	0x2f, 0xb8, 0x39, 0x08, 0x7b, 0x13, 0xf7, 0xad, 0xc5, 0xc1, 0xc9, 0x82, 0x0b, 0x36, 0x6a, 0xc1,
	0xb4, 0xcb, 0x1c, 0x56, 0x29, 0xae, 0x16, 0xd7, 0xe7, 0x9a, 0xd7, 0xf3, 0x54, 0x76, 0x98, 0x93,
	0xd0, 0x10, 0x54, 0xdd, 0x81, 0xf2, 0x29, 0x71, 0xb4, 0x0f, 0xc0, 0x88, 0xe3, 0x19, 0x2e, 0xb5,
	0x31, 0xab, 0x68, 0x42, 0xfb, 0x56, 0x9e, 0xf6, 0x1e, 0x71, 0x3c, 0xe2, 0x39, 0x3b, 0xd4, 0xc6,
	0x89, 0x77, 0xcc, 0x72, 0x21, 0x6e, 0x63, 0xfa, 0xcf, 0x1a, 0x2c, 0x64, 0x82, 0x10, 0x82, 0xe9,
	0x44, 0x91, 0xc4, 0xff, 0x68, 0x11, 0xce, 0x79, 0x03, 0xb7, 0x83, 0x03, 0x51, 0xa1, 0x99, 0xb6,
	0x7a, 0x42, 0x77, 0x61, 0x4d, 0xa4, 0x6e, 0x10, 0xaf, 0x4b, 0x0d, 0x3f, 0xa0, 0x87, 0xc4, 0xc6,
	0x81, 0xe1, 0xe2, 0xb0, 0x47, 0x6d, 0x23, 0xae, 0x77, 0x51, 0x48, 0x3d, 0x27, 0xa0, 0xdb, 0x5e,
	0x97, 0xee, 0x2a, 0xe0, 0x8e, 0xc0, 0x7d, 0xa8, 0x60, 0xfa, 0xf3, 0x50, 0x3e, 0x75, 0x22, 0xd0,
	0x3c, 0x14, 0x88, 0xad, 0x42, 0x29, 0x10, 0x5b, 0xef, 0x42, 0xf9, 0xd4, 0xb4, 0xa3, 0x3d, 0x00,
	0xe2, 0x85, 0x38, 0xe8, 0x9a, 0x56, 0x5c, 0x9f, 0x8d, 0xbc, 0xfa, 0x6c, 0x47, 0x8c, 0x44, 0x75,
	0x12, 0x32, 0xfa, 0x6f, 0x05, 0xb8, 0x92, 0x81, 0x19, 0x3b, 0x45, 0x0f, 0x35, 0x58, 0x89, 0x25,
	0x0c, 0xd3, 0xb2, 0xb0, 0x1f, 0x12, 0xcf, 0x31, 0x5c, 0xcc, 0x98, 0xe9, 0x60, 0x56, 0x29, 0x88,
	0xd8, 0xb6, 0x26, 0x8e, 0xad, 0x15, 0x49, 0xec, 0x48, 0x85, 0x44, 0xac, 0x55, 0x32, 0x0a, 0xc4,
	0xd0, 0x00, 0x16, 0x87, 0x61, 0x10, 0xd7, 0xef, 0x63, 0x17, 0xf3, 0xe7, 0x68, 0x30, 0xdf, 0x9d,
	0x38, 0x80, 0xed, 0x21, 0x39, 0xf1, 0xee, 0x05, 0x92, 0xe1, 0x67, 0xfa, 0x3d, 0xa8, 0x8d, 0x27,
	0x8e, 0x2d, 0xde, 0x32, 0x5c, 0x08, 0x1f, 0xf8, 0xd8, 0x18, 0x04, 0x7d, 0x31, 0x63, 0xb3, 0xed,
	0xf3, 0xfc, 0xf9, 0x8b, 0xa0, 0xaf, 0x7f, 0x07, 0x6b, 0x13, 0x94, 0x64, 0xac, 0xfa, 0x4d, 0x58,
	0xec, 0x12, 0xdc, 0xb7, 0x0d, 0x3b, 0xc6, 0x1b, 0xdc, 0x21, 0x7b, 0x32, 0xdb, 0xbe, 0x2a, 0xbc,
	0x43, 0xb1, 0x4f, 0xb9, 0x4f, 0xff, 0x1a, 0x96, 0x46, 0xec, 0x42, 0xd4, 0x82, 0x67, 0x3b, 0xd8,
	0xea, 0x6d, 0x34, 0x79, 0x9f, 0xe9, 0xc0, 0x0b, 0x0d, 0xd3, 0xb6, 0x03, 0xcc, 0x98, 0xe1, 0x07,
	0xb8, 0x4b, 0x8e, 0x54, 0x04, 0x55, 0x09, 0x6a, 0x49, 0x4c, 0x4b, 0x42, 0x76, 0x05, 0x42, 0xa7,
	0x50, 0x4a, 0x6d, 0x00, 0x74, 0x0f, 0xe6, 0xd4, 0x2a, 0x35, 0x5c, 0xe6, 0x08, 0x85, 0xb9, 0xe6,
	0xcd, 0xdc, 0x93, 0x2e, 0x29, 0x29, 0xa9, 0x8f, 0xa7, 0xda, 0xc0, 0x62, 0xfb, 0xed, 0x19, 0x28,
	0xba, 0xcc, 0xd1, 0x1f, 0x69, 0x70, 0x35, 0x0b, 0x8d, 0x5e, 0x86, 0x4b, 0x01, 0x3e, 0x18, 0x60,
	0x16, 0x1a, 0xa7, 0x2a, 0x58, 0x56, 0xf6, 0xe8, 0x88, 0xa2, 0x35, 0x28, 0x45, 0xd0, 0x80, 0x0e,
	0x42, 0xac, 0x7a, 0x75, 0x51, 0x19, 0xdb, 0xdc, 0x86, 0xd6, 0x87, 0x7a, 0x71, 0x4f, 0xe5, 0x0a,
	0x98, 0x57, 0xf6, 0x7d, 0xd9, 0x5a, 0xf4, 0x2a, 0x5c, 0x0e, 0x30, 0xf3, 0xa9, 0xc7, 0xf0, 0xf0,
	0xd5, 0xd3, 0x02, 0x7a, 0x29, 0x72, 0xc4, 0xeb, 0x61, 0x19, 0x96, 0x3e, 0xc2, 0x61, 0xea, 0xc6,
	0x6d, 0x4b, 0x39, 0xfd, 0x2b, 0xa8, 0x9c, 0x75, 0x49, 0x3a, 0x7a, 0x0f, 0x8a, 0xa6, 0xef, 0xab,
	0x72, 0xe6, 0x2e, 0xe5, 0xb4, 0x06, 0x67, 0xea, 0x47, 0xb0, 0x34, 0xe2, 0xca, 0x42, 0xf7, 0xcf,
	0xdc, 0x81, 0x72, 0xff, 0x6c, 0x3e, 0xc9, 0x1d, 0x38, 0xf2, 0x0a, 0xd4, 0x1f, 0x6a, 0xb0, 0x98,
	0x8d, 0x1c, 0x3b, 0xed, 0x9f, 0xc1, 0x79, 0xb9, 0x81, 0xa3, 0x95, 0x73, 0x6b, 0xa2, 0x70, 0xe4,
	0x36, 0x4e, 0x44, 0x13, 0xa9, 0xe8, 0x7b, 0xb0, 0x90, 0x89, 0xc8, 0xbc, 0x2b, 0x5e, 0x84, 0x32,
	0x8f, 0xc4, 0x90, 0x85, 0xf1, 0xcd, 0xb0, 0xa7, 0x86, 0xa4, 0xc4, 0xcd, 0x42, 0x67, 0xd7, 0x0c,
	0x7b, 0x7a, 0x15, 0x2a, 0x77, 0x09, 0x0b, 0x5b, 0xfd, 0x7e, 0x7c, 0xba, 0x59, 0xd4, 0xcf, 0x3b,
	0xb0, 0x9c, 0xe1, 0x53, 0x0d, 0x7d, 0x09, 0xca, 0xc3, 0xfd, 0x26, 0x4f, 0xb1, 0x26, 0x4e, 0xf1,
	0x7c, 0x6c, 0x96, 0xe7, 0x77, 0x0b, 0xaa, 0x5c, 0x25, 0x5e, 0x46, 0xf2, 0xeb, 0x4d, 0xbd, 0x03,
	0xbd, 0x00, 0xf3, 0x69, 0x19, 0x95, 0x45, 0x29, 0xa5, 0xa2, 0x1b, 0xf0, 0x4c, 0xa6, 0x88, 0x0a,
	0xe6, 0x7d, 0x58, 0x21, 0x29, 0x57, 0xb4, 0xee, 0x53, 0x91, 0x55, 0xd3, 0x18, 0xb5, 0xbc, 0x44,
	0x94, 0xcd, 0xff, 0xa6, 0xe1, 0x72, 0x3b, 0x6e, 0x89, 0xea, 0x34, 0x7a, 0xa4, 0xc1, 0xa5, 0xd3,
	0x23, 0x8d, 0x72, 0x3f, 0xad, 0x46, 0x9c, 0x8f, 0xea, 0x1b, 0x4f, 0x4e, 0x94, 0xf9, 0xe9, 0x9b,
	0x3f, 0xfe, 0xf5, 0xef, 0x2f, 0x85, 0xd7, 0x50, 0x3d, 0xef, 0xe3, 0xda, 0xf4, 0xfd, 0xc4, 0x76,
	0x45, 0x7f, 0x68, 0x70, 0xf9, 0x4c, 0x0b, 0x51, 0x6e, 0x1c, 0xa3, 0x26, 0xa2, 0xfa, 0xe6, 0x53,
	0x30, 0x55, 0x0a, 0x4d, 0x91, 0xc2, 0x35, 0xf4, 0x4a, 0x5e, 0x0a, 0xc3, 0xfb, 0x1f, 0x9d, 0x68,
	0x70, 0x25, 0xa3, 0xed, 0xe8, 0xad, 0x49, 0xc2, 0xc8, 0x1e, 0xb8, 0xea, 0xdb, 0x4f, 0xc5, 0x55,
	0x49, 0xec, 0x89, 0x24, 0x76, 0xd0, 0x27, 0x93, 0x27, 0xd1, 0xf8, 0x3e, 0x3d, 0xdf, 0x3f, 0x34,
	0xd2, 0x53, 0xc8, 0x6e, 0xef, 0xfe, 0x79, 0x5c, 0xd3, 0x1e, 0x1f, 0xd7, 0xb4, 0x7f, 0x8e, 0x6b,
	0xda, 0x4f, 0x27, 0xb5, 0xa9, 0xc7, 0x27, 0xb5, 0xa9, 0xbf, 0x4f, 0x6a, 0x53, 0x5f, 0x6e, 0x3a,
	0x24, 0xec, 0x0d, 0x3a, 0x75, 0x8b, 0xba, 0xd1, 0x0b, 0xe5, 0x9f, 0xeb, 0xcc, 0xfe, 0xb6, 0xc1,
	0xb7, 0x1d, 0x0e, 0x1a, 0x4e, 0xe0, 0x5b, 0xbc, 0xef, 0xc3, 0x28, 0x3a, 0xe7, 0xc4, 0x4f, 0xa3,
	0x8d, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x43, 0x25, 0x78, 0x65, 0x8b, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReflectionServiceClient is the client API for ReflectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReflectionServiceClient interface {
	// GetAppDescriptor returns the full cosmos application descriptor
	GetAppDescriptor(ctx context.Context, in *GetAppDescriptorRequest, opts ...grpc.CallOption) (*GetAppDescriptorResponse, error)
	// ListAllInterfaces lists all the interfaces registered in the interface
	// registry.
	ListAllInterfaces(ctx context.Context, in *ListAllInterfacesRequest, opts ...grpc.CallOption) (*ListAllInterfacesResponse, error)
	// ListImplementations list all the concrete types that implement a given
	// interface.
	ListImplementations(ctx context.Context, in *ListImplementationsRequest, opts ...grpc.CallOption) (*ListImplementationsResponse, error)
}

type reflectionServiceClient struct {
	cc grpc1.ClientConn
}

func NewReflectionServiceClient(cc grpc1.ClientConn) ReflectionServiceClient {
	return &reflectionServiceClient{cc}
}

func (c *reflectionServiceClient) GetAppDescriptor(ctx context.Context, in *GetAppDescriptorRequest, opts ...grpc.CallOption) (*GetAppDescriptorResponse, error) {
	out := new(GetAppDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/GetAppDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) ListAllInterfaces(ctx context.Context, in *ListAllInterfacesRequest, opts ...grpc.CallOption) (*ListAllInterfacesResponse, error) {
	out := new(ListAllInterfacesResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/ListAllInterfaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) ListImplementations(ctx context.Context, in *ListImplementationsRequest, opts ...grpc.CallOption) (*ListImplementationsResponse, error) {
	out := new(ListImplementationsResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/ListImplementations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReflectionServiceServer is the server API for ReflectionService service.
type ReflectionServiceServer interface {
	// GetAppDescriptor returns the full cosmos application descriptor
	GetAppDescriptor(context.Context, *GetAppDescriptorRequest) (*GetAppDescriptorResponse, error)
	// ListAllInterfaces lists all the interfaces registered in the interface
	// registry.
	ListAllInterfaces(context.Context, *ListAllInterfacesRequest) (*ListAllInterfacesResponse, error)
	// ListImplementations list all the concrete types that implement a given
	// interface.
	ListImplementations(context.Context, *ListImplementationsRequest) (*ListImplementationsResponse, error)
}

// UnimplementedReflectionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReflectionServiceServer struct {
}

func (*UnimplementedReflectionServiceServer) GetAppDescriptor(ctx context.Context, req *GetAppDescriptorRequest) (*GetAppDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) ListAllInterfaces(ctx context.Context, req *ListAllInterfacesRequest) (*ListAllInterfacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllInterfaces not implemented")
}
func (*UnimplementedReflectionServiceServer) ListImplementations(ctx context.Context, req *ListImplementationsRequest) (*ListImplementationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImplementations not implemented")
}

func RegisterReflectionServiceServer(s grpc1.Server, srv ReflectionServiceServer) {
	s.RegisterService(&_ReflectionService_serviceDesc, srv)
}

func _ReflectionService_GetAppDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetAppDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/GetAppDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetAppDescriptor(ctx, req.(*GetAppDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_ListAllInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllInterfacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).ListAllInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/ListAllInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).ListAllInterfaces(ctx, req.(*ListAllInterfacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_ListImplementations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImplementationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).ListImplementations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/ListImplementations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).ListImplementations(ctx, req.(*ListImplementationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReflectionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cosmos.base.reflection.v1beta1.ReflectionService",
	HandlerType: (*ReflectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAppDescriptor",
			Handler:    _ReflectionService_GetAppDescriptor_Handler,
		},
		{
			MethodName: "ListAllInterfaces",
			Handler:    _ReflectionService_ListAllInterfaces_Handler,
		},
		{
			MethodName: "ListImplementations",
			Handler:    _ReflectionService_ListImplementations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cosmos/base/reflection/v1beta1/reflection.proto",
}

func (m *AppDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.QueryServices != nil {
		{
			size, err := m.QueryServices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Codec != nil {
		{
			size, err := m.Codec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TxDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Authn != nil {
		{
			size, err := m.Authn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignModes) > 0 {
		for iNdEx := len(m.SignModes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignModes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SigningModeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningModeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningModeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthnInfoProviderMethodFullname) > 0 {
		i -= len(m.AuthnInfoProviderMethodFullname)
		copy(dAtA[i:], m.AuthnInfoProviderMethodFullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.AuthnInfoProviderMethodFullname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != 0 {
		i = encodeVarintReflection(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodecDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceImplementers) > 0 {
		for iNdEx := len(m.InterfaceImplementers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceImplementers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InterfaceAcceptingMessages) > 0 {
		for iNdEx := len(m.InterfaceAcceptingMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceAcceptingMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceImplementerDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceImplementerDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceImplementerDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeUrl) > 0 {
		i -= len(m.TypeUrl)
		copy(dAtA[i:], m.TypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.TypeUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceAcceptingMessageDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceAcceptingMessageDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceAcceptingMessageDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FieldDescriptorNames) > 0 {
		for iNdEx := len(m.FieldDescriptorNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldDescriptorNames[iNdEx])
			copy(dAtA[i:], m.FieldDescriptorNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.FieldDescriptorNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigurationDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bech32AccountAddressPrefix) > 0 {
		i -= len(m.Bech32AccountAddressPrefix)
		copy(dAtA[i:], m.Bech32AccountAddressPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32AccountAddressPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgDescriptor_ServiceMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor_ServiceMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceMsg != nil {
		{
			size, err := m.ServiceMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ServiceMsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceMsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceMsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseFullname) > 0 {
		i -= len(m.ResponseFullname)
		copy(dAtA[i:], m.ResponseFullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.ResponseFullname)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RequestTypeUrl) > 0 {
		i -= len(m.RequestTypeUrl)
		copy(dAtA[i:], m.RequestTypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.RequestTypeUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestRoute) > 0 {
		i -= len(m.RequestRoute)
		copy(dAtA[i:], m.RequestRoute)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.RequestRoute)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestFullname) > 0 {
		i -= len(m.RequestFullname)
		copy(dAtA[i:], m.RequestFullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.RequestFullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAppDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetAppDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryServicesDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServicesDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServicesDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for iNdEx := len(m.QueryServices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryServices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryServiceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServiceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServiceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Methods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMethodDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMethodDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMethodDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FullQueryPath) > 0 {
		i -= len(m.FullQueryPath)
		copy(dAtA[i:], m.FullQueryPath)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.FullQueryPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllInterfacesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllInterfacesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllInterfacesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListAllInterfacesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllInterfacesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllInterfacesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceNames) > 0 {
		for iNdEx := len(m.InterfaceNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InterfaceNames[iNdEx])
			copy(dAtA[i:], m.InterfaceNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.InterfaceNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListImplementationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListImplementationsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListImplementationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceName) > 0 {
		i -= len(m.InterfaceName)
		copy(dAtA[i:], m.InterfaceName)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.InterfaceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListImplementationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListImplementationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListImplementationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImplementationMessageNames) > 0 {
		for iNdEx := len(m.ImplementationMessageNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImplementationMessageNames[iNdEx])
			copy(dAtA[i:], m.ImplementationMessageNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.ImplementationMessageNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintReflection(dAtA []byte, offset int, v uint64) int {
	offset -= sovReflection(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Codec != nil {
		l = m.Codec.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.QueryServices != nil {
		l = m.QueryServices.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *TxDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Authn != nil {
		l = m.Authn.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *AuthnDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignModes) > 0 {
		for _, e := range m.SignModes {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *SigningModeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovReflection(uint64(m.Number))
	}
	l = len(m.AuthnInfoProviderMethodFullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ChainDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *CodecDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.InterfaceAcceptingMessages) > 0 {
		for _, e := range m.InterfaceAcceptingMessages {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	if len(m.InterfaceImplementers) > 0 {
		for _, e := range m.InterfaceImplementers {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceImplementerDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.TypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *InterfaceAcceptingMessageDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.FieldDescriptorNames) > 0 {
		for _, s := range m.FieldDescriptorNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *ConfigurationDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bech32AccountAddressPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *MsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	return n
}

func (m *MsgDescriptor_ServiceMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceMsg != nil {
		l = m.ServiceMsg.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}
func (m *ServiceMsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestFullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.RequestRoute)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.RequestTypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.ResponseFullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetAppDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetAppDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *QueryServicesDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for _, e := range m.QueryServices {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryServiceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.Methods) > 0 {
		for _, e := range m.Methods {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryMethodDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.FullQueryPath)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ListAllInterfacesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListAllInterfacesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceNames) > 0 {
		for _, s := range m.InterfaceNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *ListImplementationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InterfaceName)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ListImplementationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ImplementationMessageNames) > 0 {
		for _, s := range m.ImplementationMessageNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func sovReflection(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReflection(x uint64) (n int) {
	return sovReflection(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &ChainDescriptor{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Codec == nil {
				m.Codec = &CodecDescriptor{}
			}
			if err := m.Codec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationDescriptor{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryServices == nil {
				m.QueryServices = &QueryServicesDescriptor{}
			}
			if err := m.QueryServices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authn == nil {
				m.Authn = &AuthnDescriptor{}
			}
			if err := m.Authn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &MsgDescriptor{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignModes = append(m.SignModes, &SigningModeDescriptor{})
			if err := m.SignModes[len(m.SignModes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningModeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningModeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningModeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthnInfoProviderMethodFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthnInfoProviderMethodFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodecDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodecDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &InterfaceDescriptor{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceAcceptingMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceAcceptingMessages = append(m.InterfaceAcceptingMessages, &InterfaceAcceptingMessageDescriptor{})
			if err := m.InterfaceAcceptingMessages[len(m.InterfaceAcceptingMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceImplementers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceImplementers = append(m.InterfaceImplementers, &InterfaceImplementerDescriptor{})
			if err := m.InterfaceImplementers[len(m.InterfaceImplementers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceImplementerDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceAcceptingMessageDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceAcceptingMessageDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceAcceptingMessageDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldDescriptorNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldDescriptorNames = append(m.FieldDescriptorNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32AccountAddressPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32AccountAddressPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceMsgDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgDescriptor_ServiceMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceMsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceMsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceMsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestRoute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestRoute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestTypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppDescriptor{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServicesDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServicesDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServicesDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryServices = append(m.QueryServices, &QueryServiceDescriptor{})
			if err := m.QueryServices[len(m.QueryServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServiceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServiceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServiceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, &QueryMethodDescriptor{})
			if err := m.Methods[len(m.Methods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMethodDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMethodDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMethodDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullQueryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullQueryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllInterfacesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllInterfacesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllInterfacesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllInterfacesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllInterfacesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllInterfacesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceNames = append(m.InterfaceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListImplementationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListImplementationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListImplementationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListImplementationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListImplementationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListImplementationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplementationMessageNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImplementationMessageNames = append(m.ImplementationMessageNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReflection(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReflection
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReflection
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReflection
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReflection        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReflection          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReflection = fmt.Errorf("proto: unexpected end of group")
)
