// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/base/reflection/v1beta1/reflection.proto

package cosmosreflection

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AppDescriptor describes a cosmos-sdk based application
type AppDescriptor struct {
	// chain provides the chain descriptor
	Chain *ChainDescriptor `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	// codec provides metadata information regarding codec related types
	Codec *CodecDescriptor `protobuf:"bytes,3,opt,name=codec,proto3" json:"codec,omitempty"`
	// configuration provides metadata information regarding the sdk.Config type
	Configuration *ConfigurationDescriptor `protobuf:"bytes,4,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// query_services provides metadata information regarding the available queriable endpoints
	QueryServices *QueryServicesDescriptor `protobuf:"bytes,5,opt,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
	// tx provides metadata information regarding how to send transactions to the given application
	Tx *TxDescriptor `protobuf:"bytes,6,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *AppDescriptor) Reset()         { *m = AppDescriptor{} }
func (m *AppDescriptor) String() string { return proto.CompactTextString(m) }
func (*AppDescriptor) ProtoMessage()    {}
func (*AppDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{0}
}
func (m *AppDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppDescriptor.Merge(m, src)
}
func (m *AppDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AppDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AppDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AppDescriptor proto.InternalMessageInfo

func (m *AppDescriptor) GetChain() *ChainDescriptor {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *AppDescriptor) GetCodec() *CodecDescriptor {
	if m != nil {
		return m.Codec
	}
	return nil
}

func (m *AppDescriptor) GetConfiguration() *ConfigurationDescriptor {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *AppDescriptor) GetQueryServices() *QueryServicesDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

func (m *AppDescriptor) GetTx() *TxDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

// TxDescriptor describes the accepted transaction type
type TxDescriptor struct {
	// fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// auth_config provides information on the accepted signatures
	AuthConfig *AuthConfigDescriptor `protobuf:"bytes,2,opt,name=auth_config,json=authConfig,proto3" json:"auth_config,omitempty"`
	// msgs lists the accepted application messages (sdk.ServiceMsg, sdk.Msg)
	// NOTE: not to be confused with proto.Message types
	Msgs []*MsgDescriptor `protobuf:"bytes,3,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *TxDescriptor) Reset()         { *m = TxDescriptor{} }
func (m *TxDescriptor) String() string { return proto.CompactTextString(m) }
func (*TxDescriptor) ProtoMessage()    {}
func (*TxDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{1}
}
func (m *TxDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDescriptor.Merge(m, src)
}
func (m *TxDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TxDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TxDescriptor proto.InternalMessageInfo

func (m *TxDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *TxDescriptor) GetAuthConfig() *AuthConfigDescriptor {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *TxDescriptor) GetMsgs() []*MsgDescriptor {
	if m != nil {
		return m.Msgs
	}
	return nil
}

// AuthConfigDescriptor provides information on how to sign transactions
type AuthConfigDescriptor struct {
	// signing_modes is a list of descriptors of the sign modes
	SigningModes []*SigningModeDescriptor `protobuf:"bytes,1,rep,name=signing_modes,json=signingModes,proto3" json:"signing_modes,omitempty"`
}

func (m *AuthConfigDescriptor) Reset()         { *m = AuthConfigDescriptor{} }
func (m *AuthConfigDescriptor) String() string { return proto.CompactTextString(m) }
func (*AuthConfigDescriptor) ProtoMessage()    {}
func (*AuthConfigDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{2}
}
func (m *AuthConfigDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthConfigDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthConfigDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthConfigDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthConfigDescriptor.Merge(m, src)
}
func (m *AuthConfigDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AuthConfigDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthConfigDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AuthConfigDescriptor proto.InternalMessageInfo

func (m *AuthConfigDescriptor) GetSigningModes() []*SigningModeDescriptor {
	if m != nil {
		return m.SigningModes
	}
	return nil
}

// SigningModeDescriptor provides information on a signing flow of the application
// NOTE(fdymylja): here we could go as far as providing an entire flow on how
// to sign a message given a SigningModeDescriptor, but it's better to think about
// this another time
type SigningModeDescriptor struct {
	// name defines the unique name of the signing mode
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *SigningModeDescriptor) Reset()         { *m = SigningModeDescriptor{} }
func (m *SigningModeDescriptor) String() string { return proto.CompactTextString(m) }
func (*SigningModeDescriptor) ProtoMessage()    {}
func (*SigningModeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{3}
}
func (m *SigningModeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningModeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningModeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningModeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningModeDescriptor.Merge(m, src)
}
func (m *SigningModeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SigningModeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningModeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SigningModeDescriptor proto.InternalMessageInfo

func (m *SigningModeDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// ChainDescriptor describes chain information of the application
type ChainDescriptor struct {
	// id is the chain id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ChainDescriptor) Reset()         { *m = ChainDescriptor{} }
func (m *ChainDescriptor) String() string { return proto.CompactTextString(m) }
func (*ChainDescriptor) ProtoMessage()    {}
func (*ChainDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{4}
}
func (m *ChainDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainDescriptor.Merge(m, src)
}
func (m *ChainDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ChainDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ChainDescriptor proto.InternalMessageInfo

func (m *ChainDescriptor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// CodecDescriptor describes the registered interfaces and provides metadata information on the types
type CodecDescriptor struct {
	// interfaces is a list of the registerted interfaces descriptors
	Interfaces []*InterfaceDescriptor `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
}

func (m *CodecDescriptor) Reset()         { *m = CodecDescriptor{} }
func (m *CodecDescriptor) String() string { return proto.CompactTextString(m) }
func (*CodecDescriptor) ProtoMessage()    {}
func (*CodecDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{5}
}
func (m *CodecDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecDescriptor.Merge(m, src)
}
func (m *CodecDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CodecDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CodecDescriptor proto.InternalMessageInfo

func (m *CodecDescriptor) GetInterfaces() []*InterfaceDescriptor {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// InterfaceDescriptor describes the implementation of an interface
type InterfaceDescriptor struct {
	// fullname is the name of the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// interface_type_descriptors contains information regarding the types which contain the interface
	InterfaceAcceptingTypes []*InterfaceAcceptingTypeDescriptor `protobuf:"bytes,2,rep,name=interface_accepting_types,json=interfaceAcceptingTypes,proto3" json:"interface_accepting_types,omitempty"`
	// interface_implementers is a list of the descriptors of the interface implementers
	InterfaceImplementers []*InterfaceImplementerDescriptor `protobuf:"bytes,3,rep,name=interface_implementers,json=interfaceImplementers,proto3" json:"interface_implementers,omitempty"`
}

func (m *InterfaceDescriptor) Reset()         { *m = InterfaceDescriptor{} }
func (m *InterfaceDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceDescriptor) ProtoMessage()    {}
func (*InterfaceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{6}
}
func (m *InterfaceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDescriptor.Merge(m, src)
}
func (m *InterfaceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDescriptor proto.InternalMessageInfo

func (m *InterfaceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceDescriptor) GetInterfaceAcceptingTypes() []*InterfaceAcceptingTypeDescriptor {
	if m != nil {
		return m.InterfaceAcceptingTypes
	}
	return nil
}

func (m *InterfaceDescriptor) GetInterfaceImplementers() []*InterfaceImplementerDescriptor {
	if m != nil {
		return m.InterfaceImplementers
	}
	return nil
}

// InterfaceImplementerDescriptor describes an interface implementer
type InterfaceImplementerDescriptor struct {
	// fullname is the protobuf queryable name of the interface implementer
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// type_url defines the type URL used when marshalling the type as any
	// this is required so we can provide type safe google.protobuf.Any marshalling and
	// unmarshalling, making sure that we don't accept just 'any' type
	// in our interface fields
	TypeUrl string `protobuf:"bytes,2,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
}

func (m *InterfaceImplementerDescriptor) Reset()         { *m = InterfaceImplementerDescriptor{} }
func (m *InterfaceImplementerDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceImplementerDescriptor) ProtoMessage()    {}
func (*InterfaceImplementerDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{7}
}
func (m *InterfaceImplementerDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceImplementerDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceImplementerDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceImplementerDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceImplementerDescriptor.Merge(m, src)
}
func (m *InterfaceImplementerDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceImplementerDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceImplementerDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceImplementerDescriptor proto.InternalMessageInfo

func (m *InterfaceImplementerDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceImplementerDescriptor) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

// InterfaceAcceptingTypeDescriptor describes a protobuf message which contains
// an interface represented as a google.protobuf.Any
type InterfaceAcceptingTypeDescriptor struct {
	// fullname is the protobuf fullname of the type containing the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// field_descriptor_names is a list of the protobuf name (not fullname) of the field
	// which contains the interface as google.protobuf.Any (the interface is the same, but
	// it can be in multiple fields of the same proto message)
	FieldDescriptorNames []string `protobuf:"bytes,2,rep,name=field_descriptor_names,json=fieldDescriptorNames,proto3" json:"field_descriptor_names,omitempty"`
}

func (m *InterfaceAcceptingTypeDescriptor) Reset()         { *m = InterfaceAcceptingTypeDescriptor{} }
func (m *InterfaceAcceptingTypeDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceAcceptingTypeDescriptor) ProtoMessage()    {}
func (*InterfaceAcceptingTypeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{8}
}
func (m *InterfaceAcceptingTypeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceAcceptingTypeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceAcceptingTypeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceAcceptingTypeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceAcceptingTypeDescriptor.Merge(m, src)
}
func (m *InterfaceAcceptingTypeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceAcceptingTypeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceAcceptingTypeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceAcceptingTypeDescriptor proto.InternalMessageInfo

func (m *InterfaceAcceptingTypeDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceAcceptingTypeDescriptor) GetFieldDescriptorNames() []string {
	if m != nil {
		return m.FieldDescriptorNames
	}
	return nil
}

// ConfigurationDescriptor contains metadata information on the sdk.Config
type ConfigurationDescriptor struct {
	// bech32_account_address_prefix is the account address prefix
	Bech32AccountAddressPrefix string `protobuf:"bytes,1,opt,name=bech32_account_address_prefix,json=bech32AccountAddressPrefix,proto3" json:"bech32_account_address_prefix,omitempty"`
	// bech32_validator_address_prefix is the bech32 prefix for validator addresses
	Bech32ValidatorAddressPrefix string `protobuf:"bytes,2,opt,name=bech32_validator_address_prefix,json=bech32ValidatorAddressPrefix,proto3" json:"bech32_validator_address_prefix,omitempty"`
	// bech32_consensus_address_prefix is the bech32 prefix for consensus nodes addresses
	Bech32ConsensusAddressPrefix string `protobuf:"bytes,3,opt,name=bech32_consensus_address_prefix,json=bech32ConsensusAddressPrefix,proto3" json:"bech32_consensus_address_prefix,omitempty"`
	// bech32_account_public_key_prefix is the bech32 prefix for accounts public keys
	Bech32AccountPublicKeyPrefix string `protobuf:"bytes,4,opt,name=bech32AccountPublicKeyPrefix,proto3" json:"bech32AccountPublicKeyPrefix,omitempty"`
	// bech32_validator_public_key_prefix is the bech32 prefix for validators public keys
	Bech32ValidatorPublicKeyPrefix string `protobuf:"bytes,5,opt,name=bech32_validator_public_key_prefix,json=bech32ValidatorPublicKeyPrefix,proto3" json:"bech32_validator_public_key_prefix,omitempty"`
	// bech32_consensus_public_key_prefix is the bech32 prefix for consensus nodes public keys
	Bech32ConsensusPublicKeyPrefix string `protobuf:"bytes,6,opt,name=bech32_consensus_public_key_prefix,json=bech32ConsensusPublicKeyPrefix,proto3" json:"bech32_consensus_public_key_prefix,omitempty"`
	// purpose is the BIP-0044 purpose code
	Purpose uint32 `protobuf:"varint,7,opt,name=purpose,proto3" json:"purpose,omitempty"`
	// coin_type is the BIP-0044 coin type code
	CoinType uint32 `protobuf:"varint,8,opt,name=coin_type,json=coinType,proto3" json:"coin_type,omitempty"`
	// full_fundraiser_path is the BIP-0044 prefix (deprecated in favor of full_bip44_path)
	FullFundraiserPath string `protobuf:"bytes,9,opt,name=full_fundraiser_path,json=fullFundraiserPath,proto3" json:"full_fundraiser_path,omitempty"`
	// full_bip44_path is the BIP-0044 prefix
	FullBip44Path string `protobuf:"bytes,10,opt,name=full_bip44_path,json=fullBip44Path,proto3" json:"full_bip44_path,omitempty"`
}

func (m *ConfigurationDescriptor) Reset()         { *m = ConfigurationDescriptor{} }
func (m *ConfigurationDescriptor) String() string { return proto.CompactTextString(m) }
func (*ConfigurationDescriptor) ProtoMessage()    {}
func (*ConfigurationDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{9}
}
func (m *ConfigurationDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigurationDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigurationDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationDescriptor.Merge(m, src)
}
func (m *ConfigurationDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationDescriptor proto.InternalMessageInfo

func (m *ConfigurationDescriptor) GetBech32AccountAddressPrefix() string {
	if m != nil {
		return m.Bech32AccountAddressPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetBech32ValidatorAddressPrefix() string {
	if m != nil {
		return m.Bech32ValidatorAddressPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetBech32ConsensusAddressPrefix() string {
	if m != nil {
		return m.Bech32ConsensusAddressPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetBech32AccountPublicKeyPrefix() string {
	if m != nil {
		return m.Bech32AccountPublicKeyPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetBech32ValidatorPublicKeyPrefix() string {
	if m != nil {
		return m.Bech32ValidatorPublicKeyPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetBech32ConsensusPublicKeyPrefix() string {
	if m != nil {
		return m.Bech32ConsensusPublicKeyPrefix
	}
	return ""
}

func (m *ConfigurationDescriptor) GetPurpose() uint32 {
	if m != nil {
		return m.Purpose
	}
	return 0
}

func (m *ConfigurationDescriptor) GetCoinType() uint32 {
	if m != nil {
		return m.CoinType
	}
	return 0
}

func (m *ConfigurationDescriptor) GetFullFundraiserPath() string {
	if m != nil {
		return m.FullFundraiserPath
	}
	return ""
}

func (m *ConfigurationDescriptor) GetFullBip44Path() string {
	if m != nil {
		return m.FullBip44Path
	}
	return ""
}

// MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
type MsgDescriptor struct {
	// Types that are valid to be assigned to Msg:
	//	*MsgDescriptor_ServiceMsg
	//	*MsgDescriptor_LegacyMsg
	Msg isMsgDescriptor_Msg `protobuf_oneof:"msg"`
}

func (m *MsgDescriptor) Reset()         { *m = MsgDescriptor{} }
func (m *MsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*MsgDescriptor) ProtoMessage()    {}
func (*MsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{10}
}
func (m *MsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDescriptor.Merge(m, src)
}
func (m *MsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *MsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDescriptor proto.InternalMessageInfo

type isMsgDescriptor_Msg interface {
	isMsgDescriptor_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgDescriptor_ServiceMsg struct {
	ServiceMsg *ServiceMsgDescriptor `protobuf:"bytes,1,opt,name=service_msg,json=serviceMsg,proto3,oneof" json:"service_msg,omitempty"`
}
type MsgDescriptor_LegacyMsg struct {
	LegacyMsg *LegacyMsgDescriptor `protobuf:"bytes,2,opt,name=legacy_msg,json=legacyMsg,proto3,oneof" json:"legacy_msg,omitempty"`
}

func (*MsgDescriptor_ServiceMsg) isMsgDescriptor_Msg() {}
func (*MsgDescriptor_LegacyMsg) isMsgDescriptor_Msg()  {}

func (m *MsgDescriptor) GetMsg() isMsgDescriptor_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *MsgDescriptor) GetServiceMsg() *ServiceMsgDescriptor {
	if x, ok := m.GetMsg().(*MsgDescriptor_ServiceMsg); ok {
		return x.ServiceMsg
	}
	return nil
}

func (m *MsgDescriptor) GetLegacyMsg() *LegacyMsgDescriptor {
	if x, ok := m.GetMsg().(*MsgDescriptor_LegacyMsg); ok {
		return x.LegacyMsg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgDescriptor) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgDescriptor_ServiceMsg)(nil),
		(*MsgDescriptor_LegacyMsg)(nil),
	}
}

// ServiceMsgDescriptor describes an sdk.ServiceMsg type
type ServiceMsgDescriptor struct {
	// fullname is the protobuf fullname of the given sdk.ServiceMsg
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// route is the sdk.ServiceMsg route, it is equal to type_url
	Route string `protobuf:"bytes,2,opt,name=route,proto3" json:"route,omitempty"`
	// type_url defines the type URL used when marshalling the type as any
	// this is required so we can provide type safe google.protobuf.Any marshalling and
	// unmarshalling, making sure that we don't accept just 'any' type
	// in our interface fields
	TypeUrl string `protobuf:"bytes,3,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
}

func (m *ServiceMsgDescriptor) Reset()         { *m = ServiceMsgDescriptor{} }
func (m *ServiceMsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*ServiceMsgDescriptor) ProtoMessage()    {}
func (*ServiceMsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{11}
}
func (m *ServiceMsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceMsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceMsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceMsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceMsgDescriptor.Merge(m, src)
}
func (m *ServiceMsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ServiceMsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceMsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceMsgDescriptor proto.InternalMessageInfo

func (m *ServiceMsgDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *ServiceMsgDescriptor) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

func (m *ServiceMsgDescriptor) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

// LegacyMsgDescriptor describes an sdk.Msg type
type LegacyMsgDescriptor struct {
	// fullname is the protobuf fullname of the message
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// type_url defines the type URL used when marshalling the type as any
	// this is required so we can provide type safe google.protobuf.Any marshalling and
	// unmarshalling, making sure that we don't accept just 'any' type
	// in our interface fields
	TypeUrl string `protobuf:"bytes,2,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
}

func (m *LegacyMsgDescriptor) Reset()         { *m = LegacyMsgDescriptor{} }
func (m *LegacyMsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*LegacyMsgDescriptor) ProtoMessage()    {}
func (*LegacyMsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{12}
}
func (m *LegacyMsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LegacyMsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LegacyMsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LegacyMsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegacyMsgDescriptor.Merge(m, src)
}
func (m *LegacyMsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *LegacyMsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LegacyMsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LegacyMsgDescriptor proto.InternalMessageInfo

func (m *LegacyMsgDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *LegacyMsgDescriptor) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

// GetAppDescriptorRequest is the request type of the GetAppDescriptor RPC.
type GetAppDescriptorRequest struct {
}

func (m *GetAppDescriptorRequest) Reset()         { *m = GetAppDescriptorRequest{} }
func (m *GetAppDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetAppDescriptorRequest) ProtoMessage()    {}
func (*GetAppDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{13}
}
func (m *GetAppDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppDescriptorRequest.Merge(m, src)
}
func (m *GetAppDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAppDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppDescriptorRequest proto.InternalMessageInfo

// GetAppDescriptorResponse is the response type of the GetAppDescriptor RPC.
type GetAppDescriptorResponse struct {
	// app contains the cosmos-sdk application descriptor
	App *AppDescriptor `protobuf:"bytes,1,opt,name=app,proto3" json:"app,omitempty"`
}

func (m *GetAppDescriptorResponse) Reset()         { *m = GetAppDescriptorResponse{} }
func (m *GetAppDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetAppDescriptorResponse) ProtoMessage()    {}
func (*GetAppDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{14}
}
func (m *GetAppDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppDescriptorResponse.Merge(m, src)
}
func (m *GetAppDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAppDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppDescriptorResponse proto.InternalMessageInfo

func (m *GetAppDescriptorResponse) GetApp() *AppDescriptor {
	if m != nil {
		return m.App
	}
	return nil
}

// QueryServicesDescriptor contains the list of cosmos-sdk queriable services
type QueryServicesDescriptor struct {
	// query_services is a list of cosmos-sdk QueryServiceDescriptor
	QueryServices []*QueryServiceDescriptor `protobuf:"bytes,1,rep,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
}

func (m *QueryServicesDescriptor) Reset()         { *m = QueryServicesDescriptor{} }
func (m *QueryServicesDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServicesDescriptor) ProtoMessage()    {}
func (*QueryServicesDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{15}
}
func (m *QueryServicesDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServicesDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServicesDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServicesDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServicesDescriptor.Merge(m, src)
}
func (m *QueryServicesDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServicesDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServicesDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServicesDescriptor proto.InternalMessageInfo

func (m *QueryServicesDescriptor) GetQueryServices() []*QueryServiceDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

// QueryServiceDescriptor describes a cosmos-sdk queryable service
type QueryServiceDescriptor struct {
	// fullname is the protobuf fullname of the service descriptor
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// methods provides a list of query service methods
	Methods []*QueryMethodDescriptor `protobuf:"bytes,2,rep,name=methods,proto3" json:"methods,omitempty"`
}

func (m *QueryServiceDescriptor) Reset()         { *m = QueryServiceDescriptor{} }
func (m *QueryServiceDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServiceDescriptor) ProtoMessage()    {}
func (*QueryServiceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{16}
}
func (m *QueryServiceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServiceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServiceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServiceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServiceDescriptor.Merge(m, src)
}
func (m *QueryServiceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServiceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServiceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServiceDescriptor proto.InternalMessageInfo

func (m *QueryServiceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *QueryServiceDescriptor) GetMethods() []*QueryMethodDescriptor {
	if m != nil {
		return m.Methods
	}
	return nil
}

// QueryMethodDescriptor describes a queryable method of a query service
// no other info is provided beside method name and tendermint queryable path
// because it would be redundant with the grpc reflection service
type QueryMethodDescriptor struct {
	// name is the protobuf name (not fullname) of the method
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// full_query_path is the path that can be used to query
	// this method via tendermint abci.Query
	FullQueryPath string `protobuf:"bytes,2,opt,name=full_query_path,json=fullQueryPath,proto3" json:"full_query_path,omitempty"`
}

func (m *QueryMethodDescriptor) Reset()         { *m = QueryMethodDescriptor{} }
func (m *QueryMethodDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryMethodDescriptor) ProtoMessage()    {}
func (*QueryMethodDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{17}
}
func (m *QueryMethodDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMethodDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMethodDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMethodDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMethodDescriptor.Merge(m, src)
}
func (m *QueryMethodDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryMethodDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMethodDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMethodDescriptor proto.InternalMessageInfo

func (m *QueryMethodDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryMethodDescriptor) GetFullQueryPath() string {
	if m != nil {
		return m.FullQueryPath
	}
	return ""
}

// ListAllInterfacesRequest is the request type of the ListAllInterfaces RPC.
type ListAllInterfacesRequest struct {
}

func (m *ListAllInterfacesRequest) Reset()         { *m = ListAllInterfacesRequest{} }
func (m *ListAllInterfacesRequest) String() string { return proto.CompactTextString(m) }
func (*ListAllInterfacesRequest) ProtoMessage()    {}
func (*ListAllInterfacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{18}
}
func (m *ListAllInterfacesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllInterfacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllInterfacesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllInterfacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllInterfacesRequest.Merge(m, src)
}
func (m *ListAllInterfacesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAllInterfacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllInterfacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllInterfacesRequest proto.InternalMessageInfo

// ListAllInterfacesResponse is the response type of the ListAllInterfaces RPC.
type ListAllInterfacesResponse struct {
	// interface_names is an array of all the registered interfaces.
	InterfaceNames []string `protobuf:"bytes,1,rep,name=interface_names,json=interfaceNames,proto3" json:"interface_names,omitempty"`
}

func (m *ListAllInterfacesResponse) Reset()         { *m = ListAllInterfacesResponse{} }
func (m *ListAllInterfacesResponse) String() string { return proto.CompactTextString(m) }
func (*ListAllInterfacesResponse) ProtoMessage()    {}
func (*ListAllInterfacesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{19}
}
func (m *ListAllInterfacesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAllInterfacesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAllInterfacesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAllInterfacesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAllInterfacesResponse.Merge(m, src)
}
func (m *ListAllInterfacesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAllInterfacesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAllInterfacesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAllInterfacesResponse proto.InternalMessageInfo

func (m *ListAllInterfacesResponse) GetInterfaceNames() []string {
	if m != nil {
		return m.InterfaceNames
	}
	return nil
}

// ListImplementationsRequest is the request type of the ListImplementations
// RPC.
type ListImplementationsRequest struct {
	// interface_name defines the interface to query the implementations for.
	InterfaceName string `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
}

func (m *ListImplementationsRequest) Reset()         { *m = ListImplementationsRequest{} }
func (m *ListImplementationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListImplementationsRequest) ProtoMessage()    {}
func (*ListImplementationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{20}
}
func (m *ListImplementationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListImplementationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListImplementationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListImplementationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListImplementationsRequest.Merge(m, src)
}
func (m *ListImplementationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListImplementationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListImplementationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListImplementationsRequest proto.InternalMessageInfo

func (m *ListImplementationsRequest) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

// ListImplementationsResponse is the response type of the ListImplementations
// RPC.
type ListImplementationsResponse struct {
	ImplementationMessageNames []string `protobuf:"bytes,1,rep,name=implementation_message_names,json=implementationMessageNames,proto3" json:"implementation_message_names,omitempty"`
}

func (m *ListImplementationsResponse) Reset()         { *m = ListImplementationsResponse{} }
func (m *ListImplementationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListImplementationsResponse) ProtoMessage()    {}
func (*ListImplementationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d48c054165687f5c, []int{21}
}
func (m *ListImplementationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListImplementationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListImplementationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListImplementationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListImplementationsResponse.Merge(m, src)
}
func (m *ListImplementationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListImplementationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListImplementationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListImplementationsResponse proto.InternalMessageInfo

func (m *ListImplementationsResponse) GetImplementationMessageNames() []string {
	if m != nil {
		return m.ImplementationMessageNames
	}
	return nil
}

func init() {
	proto.RegisterType((*AppDescriptor)(nil), "cosmos.base.reflection.v1beta1.AppDescriptor")
	proto.RegisterType((*TxDescriptor)(nil), "cosmos.base.reflection.v1beta1.TxDescriptor")
	proto.RegisterType((*AuthConfigDescriptor)(nil), "cosmos.base.reflection.v1beta1.AuthConfigDescriptor")
	proto.RegisterType((*SigningModeDescriptor)(nil), "cosmos.base.reflection.v1beta1.SigningModeDescriptor")
	proto.RegisterType((*ChainDescriptor)(nil), "cosmos.base.reflection.v1beta1.ChainDescriptor")
	proto.RegisterType((*CodecDescriptor)(nil), "cosmos.base.reflection.v1beta1.CodecDescriptor")
	proto.RegisterType((*InterfaceDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceDescriptor")
	proto.RegisterType((*InterfaceImplementerDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceImplementerDescriptor")
	proto.RegisterType((*InterfaceAcceptingTypeDescriptor)(nil), "cosmos.base.reflection.v1beta1.InterfaceAcceptingTypeDescriptor")
	proto.RegisterType((*ConfigurationDescriptor)(nil), "cosmos.base.reflection.v1beta1.ConfigurationDescriptor")
	proto.RegisterType((*MsgDescriptor)(nil), "cosmos.base.reflection.v1beta1.MsgDescriptor")
	proto.RegisterType((*ServiceMsgDescriptor)(nil), "cosmos.base.reflection.v1beta1.ServiceMsgDescriptor")
	proto.RegisterType((*LegacyMsgDescriptor)(nil), "cosmos.base.reflection.v1beta1.LegacyMsgDescriptor")
	proto.RegisterType((*GetAppDescriptorRequest)(nil), "cosmos.base.reflection.v1beta1.GetAppDescriptorRequest")
	proto.RegisterType((*GetAppDescriptorResponse)(nil), "cosmos.base.reflection.v1beta1.GetAppDescriptorResponse")
	proto.RegisterType((*QueryServicesDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryServicesDescriptor")
	proto.RegisterType((*QueryServiceDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryServiceDescriptor")
	proto.RegisterType((*QueryMethodDescriptor)(nil), "cosmos.base.reflection.v1beta1.QueryMethodDescriptor")
	proto.RegisterType((*ListAllInterfacesRequest)(nil), "cosmos.base.reflection.v1beta1.ListAllInterfacesRequest")
	proto.RegisterType((*ListAllInterfacesResponse)(nil), "cosmos.base.reflection.v1beta1.ListAllInterfacesResponse")
	proto.RegisterType((*ListImplementationsRequest)(nil), "cosmos.base.reflection.v1beta1.ListImplementationsRequest")
	proto.RegisterType((*ListImplementationsResponse)(nil), "cosmos.base.reflection.v1beta1.ListImplementationsResponse")
}

func init() {
	proto.RegisterFile("cosmos/base/reflection/v1beta1/reflection.proto", fileDescriptor_d48c054165687f5c)
}

var fileDescriptor_d48c054165687f5c = []byte{
	// 1249 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x51, 0x6f, 0xdb, 0xd4,
	0x17, 0xaf, 0x93, 0x76, 0x6d, 0x4e, 0x97, 0xf6, 0xbf, 0xbb, 0x6e, 0x75, 0xb3, 0xfe, 0x43, 0xb1,
	0x04, 0x54, 0xb0, 0x25, 0x5b, 0xd7, 0x0d, 0x06, 0x08, 0x96, 0x76, 0x03, 0xc6, 0x5a, 0x28, 0x49,
	0xc7, 0xa4, 0xa1, 0x61, 0x39, 0xf6, 0x8d, 0x73, 0x35, 0xc7, 0x76, 0x7d, 0xed, 0xaa, 0x11, 0xf0,
	0x82, 0xc4, 0x3b, 0x12, 0x6f, 0x7c, 0x00, 0x3e, 0x05, 0xbc, 0x81, 0xc4, 0xe3, 0x24, 0x1e, 0xe0,
	0x11, 0xb5, 0x7c, 0x08, 0x1e, 0xd1, 0xbd, 0xd7, 0x76, 0xec, 0xd4, 0x89, 0xb3, 0x3e, 0xb5, 0x3e,
	0xe7, 0xf7, 0xfb, 0x9d, 0x73, 0xee, 0x3d, 0xf7, 0x9e, 0x1b, 0xa8, 0xeb, 0x0e, 0xed, 0x39, 0xb4,
	0xde, 0xd6, 0x28, 0xae, 0x7b, 0xb8, 0x63, 0x61, 0xdd, 0x27, 0x8e, 0x5d, 0x3f, 0xbc, 0xd1, 0xc6,
	0xbe, 0x76, 0x23, 0x61, 0xaa, 0xb9, 0x9e, 0xe3, 0x3b, 0xa8, 0x2a, 0x08, 0x35, 0x46, 0xa8, 0x25,
	0xbc, 0x21, 0xa1, 0xb2, 0x6a, 0x3a, 0x8e, 0x69, 0xe1, 0xba, 0xe6, 0x92, 0xba, 0x66, 0xdb, 0x8e,
	0xaf, 0x31, 0x37, 0x15, 0x6c, 0xe5, 0xc7, 0x22, 0x94, 0x1b, 0xae, 0x7b, 0x0f, 0x53, 0xdd, 0x23,
	0xae, 0xef, 0x78, 0xe8, 0x3e, 0xcc, 0xe8, 0x5d, 0x8d, 0xd8, 0x72, 0x61, 0x4d, 0x5a, 0x9f, 0xdf,
	0xa8, 0xd7, 0xc6, 0xeb, 0xd7, 0xb6, 0x19, 0x78, 0xc0, 0x6f, 0x0a, 0x36, 0x97, 0x71, 0x0c, 0xac,
	0xcb, 0xc5, 0x09, 0x65, 0x18, 0x38, 0x25, 0xc3, 0x0c, 0xe8, 0x29, 0x94, 0x75, 0xc7, 0xee, 0x10,
	0x33, 0xf0, 0x78, 0xde, 0xf2, 0x34, 0x97, 0x7b, 0x33, 0x5f, 0x2e, 0x41, 0x4a, 0xc8, 0xa6, 0xd5,
	0xd0, 0x97, 0xb0, 0x70, 0x10, 0x60, 0xaf, 0xaf, 0x52, 0xec, 0x1d, 0x12, 0x1d, 0x53, 0x79, 0x66,
	0x32, 0xfd, 0xcf, 0x18, 0xab, 0x15, 0x92, 0x92, 0xfa, 0x07, 0x49, 0x07, 0x7a, 0x17, 0x0a, 0xfe,
	0x91, 0x7c, 0x8e, 0x6b, 0x5e, 0xcd, 0xd3, 0xdc, 0x3f, 0x4a, 0x08, 0x15, 0xfc, 0x23, 0xe5, 0x57,
	0x09, 0xce, 0x27, 0x8d, 0xa8, 0x02, 0x73, 0x9d, 0xc0, 0xb2, 0x6c, 0xad, 0x87, 0x65, 0x69, 0x4d,
	0x5a, 0x2f, 0x35, 0xe3, 0x6f, 0xf4, 0x08, 0xe6, 0xb5, 0xc0, 0xef, 0xaa, 0xa2, 0xc0, 0x70, 0xf7,
	0x36, 0xf3, 0x62, 0x36, 0x02, 0xbf, 0x2b, 0xd6, 0x2a, 0x11, 0x1b, 0xb4, 0xd8, 0x8a, 0x1a, 0x30,
	0xdd, 0xa3, 0x26, 0x95, 0x8b, 0x6b, 0xc5, 0xf5, 0xf9, 0x8d, 0x6b, 0x79, 0x7a, 0xbb, 0x34, 0x29,
	0xc4, 0xa9, 0x8a, 0x07, 0x4b, 0x59, 0x61, 0xd0, 0x13, 0x28, 0x53, 0x62, 0xda, 0xc4, 0x36, 0xd5,
	0x9e, 0x63, 0x60, 0x2a, 0x4b, 0x3c, 0xc6, 0xad, 0xbc, 0x18, 0x2d, 0x41, 0xda, 0x75, 0x0c, 0x9c,
	0x88, 0x75, 0x9e, 0x0e, 0xcc, 0x54, 0x79, 0x03, 0x2e, 0x65, 0xc2, 0x10, 0x82, 0xe9, 0xc4, 0xf2,
	0xf1, 0xff, 0x95, 0x97, 0x61, 0x71, 0xa8, 0x8b, 0xd1, 0x02, 0x14, 0x88, 0x11, 0x82, 0x0a, 0xc4,
	0x50, 0x3a, 0xb0, 0x38, 0xd4, 0xa1, 0xa8, 0x05, 0x40, 0x6c, 0x1f, 0x7b, 0x1d, 0x4d, 0x8f, 0x73,
	0xbf, 0x99, 0x97, 0xfb, 0x83, 0x88, 0x91, 0x5c, 0xee, 0x81, 0x8c, 0xf2, 0x53, 0x01, 0x2e, 0x66,
	0x60, 0xc6, 0xee, 0xfc, 0xd7, 0xb0, 0x12, 0x2b, 0xa8, 0x9a, 0xae, 0x63, 0xd7, 0x67, 0x6b, 0xea,
	0xf7, 0x5d, 0x4c, 0xe5, 0x02, 0xcf, 0xeb, 0xee, 0xc4, 0x79, 0x35, 0x22, 0xfe, 0x7e, 0xdf, 0x4d,
	0x26, 0xb9, 0x4c, 0x32, 0x11, 0x14, 0x05, 0x70, 0x79, 0x10, 0x9d, 0xf4, 0x5c, 0x0b, 0xf7, 0x30,
	0xfb, 0x8e, 0x5a, 0xe6, 0xbd, 0x89, 0x43, 0x3f, 0x18, 0x90, 0x13, 0x81, 0x2f, 0x91, 0x0c, 0x3f,
	0x55, 0x1e, 0x43, 0x75, 0x3c, 0x71, 0xec, 0x92, 0xad, 0xc0, 0x1c, 0x5b, 0x1e, 0x35, 0xf0, 0x2c,
	0x7e, 0x52, 0x4a, 0xcd, 0x59, 0xf6, 0xfd, 0xc8, 0xb3, 0x14, 0x1f, 0xd6, 0xf2, 0x16, 0x63, 0xac,
	0xf4, 0x26, 0x5c, 0xee, 0x10, 0x6c, 0x19, 0xaa, 0x11, 0xe3, 0x55, 0xe6, 0x10, 0x5b, 0x51, 0x6a,
	0x2e, 0x71, 0xef, 0x40, 0xec, 0x13, 0xe6, 0x53, 0xfe, 0x9c, 0x86, 0xe5, 0x11, 0x77, 0x16, 0x6a,
	0xc0, 0xff, 0xdb, 0x58, 0xef, 0xde, 0xdc, 0x60, 0x9b, 0xeb, 0x04, 0xb6, 0xaf, 0x6a, 0x86, 0xe1,
	0x61, 0x4a, 0x55, 0xd7, 0xc3, 0x1d, 0x72, 0x14, 0xa6, 0x50, 0x11, 0xa0, 0x86, 0xc0, 0x34, 0x04,
	0x64, 0x8f, 0x23, 0xd0, 0x7d, 0x78, 0x29, 0x94, 0x38, 0xd4, 0x2c, 0x62, 0x68, 0x2c, 0xa9, 0x21,
	0x11, 0xb1, 0x0c, 0xab, 0x02, 0xf6, 0x79, 0x84, 0x1a, 0x25, 0xa3, 0x3b, 0x36, 0xc5, 0x36, 0x0d,
	0xe8, 0xb0, 0x4c, 0x31, 0x29, 0xb3, 0x1d, 0xa1, 0xd2, 0x32, 0x5b, 0xb0, 0x9a, 0xca, 0x75, 0x2f,
	0x68, 0x5b, 0x44, 0x7f, 0x88, 0xfb, 0xc2, 0xcf, 0xef, 0xf8, 0x58, 0x23, 0x1b, 0x83, 0x3e, 0x06,
	0xe5, 0x54, 0x45, 0x2e, 0xc7, 0xa8, 0xcf, 0x70, 0x3f, 0xca, 0x66, 0x86, 0x2b, 0x55, 0x87, 0x8a,
	0x1a, 0xad, 0x35, 0x28, 0xeb, 0xb4, 0xd6, 0xb9, 0xa4, 0x56, 0x5c, 0xd9, 0xb0, 0x96, 0x0c, 0xb3,
	0x6e, 0xe0, 0xb9, 0x0e, 0xc5, 0xf2, 0xec, 0x9a, 0xb4, 0x5e, 0x6e, 0x46, 0x9f, 0xe8, 0x0a, 0x94,
	0x74, 0x87, 0xd8, 0xfc, 0x5c, 0xca, 0x73, 0xdc, 0x37, 0xc7, 0x0c, 0xac, 0xb7, 0xd0, 0x75, 0x58,
	0x62, 0x1d, 0xa4, 0x76, 0x02, 0xdb, 0xf0, 0x34, 0x42, 0xb1, 0xa7, 0xba, 0x9a, 0xdf, 0x95, 0x4b,
	0x3c, 0x28, 0x62, 0xbe, 0x0f, 0x62, 0xd7, 0x9e, 0xe6, 0x77, 0xd1, 0xab, 0xb0, 0xc8, 0x19, 0x6d,
	0xe2, 0x6e, 0x6e, 0x0a, 0x30, 0x70, 0x70, 0x99, 0x99, 0xb7, 0x98, 0x95, 0xe1, 0x94, 0xdf, 0x24,
	0x28, 0xa7, 0x6e, 0x65, 0xf4, 0x18, 0xe6, 0xc3, 0x71, 0xa7, 0xf6, 0xa8, 0xc9, 0xbb, 0x67, 0x82,
	0x49, 0x11, 0xce, 0xb4, 0x94, 0xd4, 0x47, 0x53, 0x4d, 0xa0, 0xb1, 0x1d, 0xed, 0x03, 0x58, 0xd8,
	0xd4, 0xf4, 0x3e, 0xd7, 0x15, 0x13, 0x28, 0xf7, 0x46, 0xdc, 0xe1, 0x8c, 0x61, 0xd9, 0x92, 0x15,
	0x99, 0xb7, 0x66, 0xa0, 0xd8, 0xa3, 0xa6, 0xa2, 0xc3, 0x52, 0x56, 0x0a, 0x63, 0xcf, 0xe2, 0x12,
	0xcc, 0x78, 0x4e, 0xe0, 0xe3, 0xb0, 0xb9, 0xc5, 0x47, 0xea, 0xf0, 0x17, 0xd3, 0x87, 0x7f, 0x07,
	0x2e, 0x66, 0xe4, 0x73, 0xd6, 0xab, 0x64, 0x05, 0x96, 0x3f, 0xc4, 0x7e, 0xea, 0x79, 0xd5, 0xc4,
	0x07, 0x01, 0xa6, 0xbe, 0xf2, 0x05, 0xc8, 0xa7, 0x5d, 0xd4, 0x65, 0x5d, 0x85, 0xde, 0x87, 0xa2,
	0xe6, 0xba, 0xe1, 0xbe, 0xe4, 0x4e, 0xdc, 0xb4, 0x06, 0x63, 0x2a, 0x47, 0xb0, 0x3c, 0xe2, 0x7d,
	0x82, 0x9e, 0x9e, 0x7a, 0xf0, 0x88, 0xc1, 0x75, 0xfb, 0x45, 0x1e, 0x3c, 0x23, 0xdf, 0x3b, 0xca,
	0x77, 0x12, 0x5c, 0xce, 0x46, 0x8e, 0x5d, 0xc3, 0x4f, 0x61, 0xb6, 0x87, 0xfd, 0xae, 0x63, 0x44,
	0xf3, 0xea, 0xd6, 0x44, 0xe9, 0xec, 0x72, 0x4e, 0x22, 0x9b, 0x48, 0x45, 0x69, 0xc1, 0xa5, 0x4c,
	0x44, 0xd6, 0xf8, 0x8f, 0x4f, 0x92, 0x58, 0x18, 0x7e, 0x92, 0x0a, 0x83, 0x93, 0xc4, 0x75, 0xf8,
	0x49, 0xaa, 0x80, 0xbc, 0x43, 0xa8, 0xdf, 0xb0, 0xac, 0x78, 0x40, 0xd0, 0x68, 0x3f, 0xef, 0xc1,
	0x4a, 0x86, 0x2f, 0xdc, 0xd0, 0xd7, 0x60, 0x71, 0x30, 0x22, 0xc5, 0x2c, 0x90, 0xf8, 0x2c, 0x58,
	0x88, 0xcd, 0x62, 0x0a, 0x6c, 0x43, 0x85, 0xa9, 0xc4, 0xf3, 0x4c, 0x3c, 0xd5, 0xc3, 0x18, 0xe8,
	0x15, 0x58, 0x48, 0xcb, 0x84, 0x55, 0x94, 0x53, 0x2a, 0x8a, 0x0a, 0x57, 0x32, 0x45, 0xc2, 0x64,
	0xee, 0xc2, 0x2a, 0x49, 0xb9, 0xd4, 0x1e, 0xa6, 0x54, 0x33, 0xd3, 0x99, 0x55, 0xd2, 0x98, 0x5d,
	0x01, 0xe1, 0x59, 0x6e, 0xfc, 0x3b, 0x0d, 0x17, 0x9a, 0xf1, 0x96, 0x84, 0x3b, 0x8d, 0x7e, 0x91,
	0xe0, 0x7f, 0xc3, 0x2d, 0x8d, 0x72, 0xdf, 0xd1, 0x23, 0xce, 0x47, 0xe5, 0xad, 0x17, 0x27, 0x8a,
	0xfa, 0x94, 0xdb, 0xdf, 0xfe, 0xf1, 0xcf, 0x0f, 0x85, 0xeb, 0xa8, 0x96, 0xf7, 0x4b, 0x4a, 0x73,
	0xdd, 0xc4, 0x8c, 0x46, 0x3f, 0x4b, 0x70, 0xe1, 0xd4, 0x16, 0xa2, 0xdc, 0x3c, 0x46, 0x75, 0x44,
	0xe5, 0xce, 0x19, 0x98, 0x61, 0x09, 0x1b, 0xbc, 0x84, 0xab, 0xe8, 0xf5, 0xbc, 0x12, 0x06, 0x0f,
	0x47, 0x74, 0x22, 0xc1, 0xc5, 0x8c, 0x6d, 0x47, 0x6f, 0x4f, 0x92, 0x46, 0x76, 0xc3, 0x55, 0xde,
	0x39, 0x13, 0x37, 0x2c, 0xa2, 0xc5, 0x8b, 0xd8, 0x45, 0x0f, 0x27, 0x2f, 0xa2, 0xfe, 0x55, 0xba,
	0xbf, 0xbf, 0xa9, 0xa7, 0xbb, 0x90, 0x6e, 0xb5, 0x7e, 0x3f, 0xae, 0x4a, 0xcf, 0x8f, 0xab, 0xd2,
	0xdf, 0xc7, 0x55, 0xe9, 0xfb, 0x93, 0xea, 0xd4, 0xf3, 0x93, 0xea, 0xd4, 0x5f, 0x27, 0xd5, 0xa9,
	0x27, 0x77, 0x4c, 0xe2, 0x77, 0x83, 0x76, 0x4d, 0x77, 0x7a, 0x51, 0x40, 0xf1, 0xe7, 0x1a, 0x35,
	0x9e, 0xd5, 0xd9, 0x6d, 0x87, 0xbd, 0xba, 0xe9, 0xb9, 0x7a, 0x68, 0x1e, 0x24, 0xd2, 0x3e, 0xc7,
	0x7f, 0x0a, 0xdf, 0xfc, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xed, 0xf0, 0xac, 0x45, 0x7b, 0x0f, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReflectionServiceClient is the client API for ReflectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReflectionServiceClient interface {
	// GetAppDescriptor returns the full cosmos application descriptor
	GetAppDescriptor(ctx context.Context, in *GetAppDescriptorRequest, opts ...grpc.CallOption) (*GetAppDescriptorResponse, error)
	// ListAllInterfaces lists all the interfaces registered in the interface
	// registry.
	ListAllInterfaces(ctx context.Context, in *ListAllInterfacesRequest, opts ...grpc.CallOption) (*ListAllInterfacesResponse, error)
	// ListImplementations list all the concrete types that implement a given
	// interface.
	ListImplementations(ctx context.Context, in *ListImplementationsRequest, opts ...grpc.CallOption) (*ListImplementationsResponse, error)
}

type reflectionServiceClient struct {
	cc grpc1.ClientConn
}

func NewReflectionServiceClient(cc grpc1.ClientConn) ReflectionServiceClient {
	return &reflectionServiceClient{cc}
}

func (c *reflectionServiceClient) GetAppDescriptor(ctx context.Context, in *GetAppDescriptorRequest, opts ...grpc.CallOption) (*GetAppDescriptorResponse, error) {
	out := new(GetAppDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/GetAppDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) ListAllInterfaces(ctx context.Context, in *ListAllInterfacesRequest, opts ...grpc.CallOption) (*ListAllInterfacesResponse, error) {
	out := new(ListAllInterfacesResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/ListAllInterfaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) ListImplementations(ctx context.Context, in *ListImplementationsRequest, opts ...grpc.CallOption) (*ListImplementationsResponse, error) {
	out := new(ListImplementationsResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v1beta1.ReflectionService/ListImplementations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReflectionServiceServer is the server API for ReflectionService service.
type ReflectionServiceServer interface {
	// GetAppDescriptor returns the full cosmos application descriptor
	GetAppDescriptor(context.Context, *GetAppDescriptorRequest) (*GetAppDescriptorResponse, error)
	// ListAllInterfaces lists all the interfaces registered in the interface
	// registry.
	ListAllInterfaces(context.Context, *ListAllInterfacesRequest) (*ListAllInterfacesResponse, error)
	// ListImplementations list all the concrete types that implement a given
	// interface.
	ListImplementations(context.Context, *ListImplementationsRequest) (*ListImplementationsResponse, error)
}

// UnimplementedReflectionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReflectionServiceServer struct {
}

func (*UnimplementedReflectionServiceServer) GetAppDescriptor(ctx context.Context, req *GetAppDescriptorRequest) (*GetAppDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) ListAllInterfaces(ctx context.Context, req *ListAllInterfacesRequest) (*ListAllInterfacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllInterfaces not implemented")
}
func (*UnimplementedReflectionServiceServer) ListImplementations(ctx context.Context, req *ListImplementationsRequest) (*ListImplementationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImplementations not implemented")
}

func RegisterReflectionServiceServer(s grpc1.Server, srv ReflectionServiceServer) {
	s.RegisterService(&_ReflectionService_serviceDesc, srv)
}

func _ReflectionService_GetAppDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetAppDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/GetAppDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetAppDescriptor(ctx, req.(*GetAppDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_ListAllInterfaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllInterfacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).ListAllInterfaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/ListAllInterfaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).ListAllInterfaces(ctx, req.(*ListAllInterfacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_ListImplementations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImplementationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).ListImplementations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v1beta1.ReflectionService/ListImplementations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).ListImplementations(ctx, req.(*ListImplementationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReflectionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cosmos.base.reflection.v1beta1.ReflectionService",
	HandlerType: (*ReflectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAppDescriptor",
			Handler:    _ReflectionService_GetAppDescriptor_Handler,
		},
		{
			MethodName: "ListAllInterfaces",
			Handler:    _ReflectionService_ListAllInterfaces_Handler,
		},
		{
			MethodName: "ListImplementations",
			Handler:    _ReflectionService_ListImplementations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cosmos/base/reflection/v1beta1/reflection.proto",
}

func (m *AppDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.QueryServices != nil {
		{
			size, err := m.QueryServices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Codec != nil {
		{
			size, err := m.Codec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TxDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AuthConfig != nil {
		{
			size, err := m.AuthConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthConfigDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfigDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthConfigDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningModes) > 0 {
		for iNdEx := len(m.SigningModes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SigningModes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SigningModeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningModeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningModeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodecDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceImplementers) > 0 {
		for iNdEx := len(m.InterfaceImplementers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceImplementers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InterfaceAcceptingTypes) > 0 {
		for iNdEx := len(m.InterfaceAcceptingTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceAcceptingTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceImplementerDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceImplementerDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceImplementerDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeUrl) > 0 {
		i -= len(m.TypeUrl)
		copy(dAtA[i:], m.TypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.TypeUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceAcceptingTypeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceAcceptingTypeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceAcceptingTypeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FieldDescriptorNames) > 0 {
		for iNdEx := len(m.FieldDescriptorNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldDescriptorNames[iNdEx])
			copy(dAtA[i:], m.FieldDescriptorNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.FieldDescriptorNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigurationDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FullBip44Path) > 0 {
		i -= len(m.FullBip44Path)
		copy(dAtA[i:], m.FullBip44Path)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.FullBip44Path)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FullFundraiserPath) > 0 {
		i -= len(m.FullFundraiserPath)
		copy(dAtA[i:], m.FullFundraiserPath)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.FullFundraiserPath)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CoinType != 0 {
		i = encodeVarintReflection(dAtA, i, uint64(m.CoinType))
		i--
		dAtA[i] = 0x40
	}
	if m.Purpose != 0 {
		i = encodeVarintReflection(dAtA, i, uint64(m.Purpose))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Bech32ConsensusPublicKeyPrefix) > 0 {
		i -= len(m.Bech32ConsensusPublicKeyPrefix)
		copy(dAtA[i:], m.Bech32ConsensusPublicKeyPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32ConsensusPublicKeyPrefix)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Bech32ValidatorPublicKeyPrefix) > 0 {
		i -= len(m.Bech32ValidatorPublicKeyPrefix)
		copy(dAtA[i:], m.Bech32ValidatorPublicKeyPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32ValidatorPublicKeyPrefix)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bech32AccountPublicKeyPrefix) > 0 {
		i -= len(m.Bech32AccountPublicKeyPrefix)
		copy(dAtA[i:], m.Bech32AccountPublicKeyPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32AccountPublicKeyPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Bech32ConsensusAddressPrefix) > 0 {
		i -= len(m.Bech32ConsensusAddressPrefix)
		copy(dAtA[i:], m.Bech32ConsensusAddressPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32ConsensusAddressPrefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bech32ValidatorAddressPrefix) > 0 {
		i -= len(m.Bech32ValidatorAddressPrefix)
		copy(dAtA[i:], m.Bech32ValidatorAddressPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32ValidatorAddressPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bech32AccountAddressPrefix) > 0 {
		i -= len(m.Bech32AccountAddressPrefix)
		copy(dAtA[i:], m.Bech32AccountAddressPrefix)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Bech32AccountAddressPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgDescriptor_ServiceMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor_ServiceMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceMsg != nil {
		{
			size, err := m.ServiceMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MsgDescriptor_LegacyMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor_LegacyMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyMsg != nil {
		{
			size, err := m.LegacyMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ServiceMsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceMsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceMsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeUrl) > 0 {
		i -= len(m.TypeUrl)
		copy(dAtA[i:], m.TypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.TypeUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Route) > 0 {
		i -= len(m.Route)
		copy(dAtA[i:], m.Route)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Route)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LegacyMsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyMsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyMsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeUrl) > 0 {
		i -= len(m.TypeUrl)
		copy(dAtA[i:], m.TypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.TypeUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAppDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetAppDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryServicesDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServicesDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServicesDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for iNdEx := len(m.QueryServices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryServices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryServiceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServiceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServiceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Methods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMethodDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMethodDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMethodDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FullQueryPath) > 0 {
		i -= len(m.FullQueryPath)
		copy(dAtA[i:], m.FullQueryPath)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.FullQueryPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAllInterfacesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllInterfacesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllInterfacesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListAllInterfacesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAllInterfacesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAllInterfacesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceNames) > 0 {
		for iNdEx := len(m.InterfaceNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InterfaceNames[iNdEx])
			copy(dAtA[i:], m.InterfaceNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.InterfaceNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListImplementationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListImplementationsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListImplementationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceName) > 0 {
		i -= len(m.InterfaceName)
		copy(dAtA[i:], m.InterfaceName)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.InterfaceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListImplementationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListImplementationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListImplementationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImplementationMessageNames) > 0 {
		for iNdEx := len(m.ImplementationMessageNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImplementationMessageNames[iNdEx])
			copy(dAtA[i:], m.ImplementationMessageNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.ImplementationMessageNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintReflection(dAtA []byte, offset int, v uint64) int {
	offset -= sovReflection(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Codec != nil {
		l = m.Codec.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.QueryServices != nil {
		l = m.QueryServices.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *TxDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.AuthConfig != nil {
		l = m.AuthConfig.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *AuthConfigDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningModes) > 0 {
		for _, e := range m.SigningModes {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *SigningModeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ChainDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *CodecDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.InterfaceAcceptingTypes) > 0 {
		for _, e := range m.InterfaceAcceptingTypes {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	if len(m.InterfaceImplementers) > 0 {
		for _, e := range m.InterfaceImplementers {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceImplementerDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.TypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *InterfaceAcceptingTypeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.FieldDescriptorNames) > 0 {
		for _, s := range m.FieldDescriptorNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *ConfigurationDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bech32AccountAddressPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Bech32ValidatorAddressPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Bech32ConsensusAddressPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Bech32AccountPublicKeyPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Bech32ValidatorPublicKeyPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Bech32ConsensusPublicKeyPrefix)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Purpose != 0 {
		n += 1 + sovReflection(uint64(m.Purpose))
	}
	if m.CoinType != 0 {
		n += 1 + sovReflection(uint64(m.CoinType))
	}
	l = len(m.FullFundraiserPath)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.FullBip44Path)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *MsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	return n
}

func (m *MsgDescriptor_ServiceMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceMsg != nil {
		l = m.ServiceMsg.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}
func (m *MsgDescriptor_LegacyMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyMsg != nil {
		l = m.LegacyMsg.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}
func (m *ServiceMsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.TypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *LegacyMsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.TypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetAppDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetAppDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *QueryServicesDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for _, e := range m.QueryServices {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryServiceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.Methods) > 0 {
		for _, e := range m.Methods {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryMethodDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.FullQueryPath)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ListAllInterfacesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListAllInterfacesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceNames) > 0 {
		for _, s := range m.InterfaceNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *ListImplementationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InterfaceName)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ListImplementationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ImplementationMessageNames) > 0 {
		for _, s := range m.ImplementationMessageNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func sovReflection(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReflection(x uint64) (n int) {
	return sovReflection(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &ChainDescriptor{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Codec == nil {
				m.Codec = &CodecDescriptor{}
			}
			if err := m.Codec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationDescriptor{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryServices == nil {
				m.QueryServices = &QueryServicesDescriptor{}
			}
			if err := m.QueryServices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfig == nil {
				m.AuthConfig = &AuthConfigDescriptor{}
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &MsgDescriptor{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfigDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfigDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfigDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningModes = append(m.SigningModes, &SigningModeDescriptor{})
			if err := m.SigningModes[len(m.SigningModes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningModeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningModeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningModeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodecDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodecDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &InterfaceDescriptor{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceAcceptingTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceAcceptingTypes = append(m.InterfaceAcceptingTypes, &InterfaceAcceptingTypeDescriptor{})
			if err := m.InterfaceAcceptingTypes[len(m.InterfaceAcceptingTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceImplementers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceImplementers = append(m.InterfaceImplementers, &InterfaceImplementerDescriptor{})
			if err := m.InterfaceImplementers[len(m.InterfaceImplementers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceImplementerDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceAcceptingTypeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceAcceptingTypeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceAcceptingTypeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldDescriptorNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldDescriptorNames = append(m.FieldDescriptorNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32AccountAddressPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32AccountAddressPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32ValidatorAddressPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32ValidatorAddressPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32ConsensusAddressPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32ConsensusAddressPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32AccountPublicKeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32AccountPublicKeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32ValidatorPublicKeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32ValidatorPublicKeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32ConsensusPublicKeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32ConsensusPublicKeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			m.Purpose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Purpose |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			m.CoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullFundraiserPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullFundraiserPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullBip44Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullBip44Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceMsgDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgDescriptor_ServiceMsg{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyMsgDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &MsgDescriptor_LegacyMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceMsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceMsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceMsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyMsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyMsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyMsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppDescriptor{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServicesDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServicesDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServicesDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryServices = append(m.QueryServices, &QueryServiceDescriptor{})
			if err := m.QueryServices[len(m.QueryServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServiceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServiceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServiceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, &QueryMethodDescriptor{})
			if err := m.Methods[len(m.Methods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMethodDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMethodDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMethodDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullQueryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullQueryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllInterfacesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllInterfacesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllInterfacesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAllInterfacesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAllInterfacesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAllInterfacesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceNames = append(m.InterfaceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListImplementationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListImplementationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListImplementationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListImplementationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListImplementationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListImplementationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplementationMessageNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImplementationMessageNames = append(m.ImplementationMessageNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReflection(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReflection
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReflection
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReflection
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReflection        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReflection          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReflection = fmt.Errorf("proto: unexpected end of group")
)
