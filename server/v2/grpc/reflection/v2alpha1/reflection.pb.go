// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/base/reflection/v2alpha1/reflection.proto

package v2alpha1

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AppDescriptor describes a cosmos-sdk based application
type AppDescriptor struct {
	// AuthnDescriptor provides information on how to authenticate transactions on the application
	// NOTE: experimental and subject to change in future releases.
	Authn *AuthnDescriptor `protobuf:"bytes,1,opt,name=authn,proto3" json:"authn,omitempty"`
	// chain provides the chain descriptor
	Chain *ChainDescriptor `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	// codec provides metadata information regarding codec related types
	Codec *CodecDescriptor `protobuf:"bytes,3,opt,name=codec,proto3" json:"codec,omitempty"`
	// query_services provides metadata information regarding the available queryable endpoints
	QueryServices *QueryServicesDescriptor `protobuf:"bytes,5,opt,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
	// tx provides metadata information regarding how to send transactions to the given application
	Tx *TxDescriptor `protobuf:"bytes,6,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *AppDescriptor) Reset()         { *m = AppDescriptor{} }
func (m *AppDescriptor) String() string { return proto.CompactTextString(m) }
func (*AppDescriptor) ProtoMessage()    {}
func (*AppDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{0}
}
func (m *AppDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppDescriptor.Merge(m, src)
}
func (m *AppDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AppDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AppDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AppDescriptor proto.InternalMessageInfo

func (m *AppDescriptor) GetAuthn() *AuthnDescriptor {
	if m != nil {
		return m.Authn
	}
	return nil
}

func (m *AppDescriptor) GetChain() *ChainDescriptor {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *AppDescriptor) GetCodec() *CodecDescriptor {
	if m != nil {
		return m.Codec
	}
	return nil
}

func (m *AppDescriptor) GetQueryServices() *QueryServicesDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

func (m *AppDescriptor) GetTx() *TxDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

// TxDescriptor describes the accepted transaction type
type TxDescriptor struct {
	// fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
	// it is not meant to support polymorphism of transaction types, it is supposed to be used by
	// reflection clients to understand if they can handle a specific transaction type in an application.
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// msgs lists the accepted application messages (sdk.Msg)
	Msgs []*MsgDescriptor `protobuf:"bytes,2,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *TxDescriptor) Reset()         { *m = TxDescriptor{} }
func (m *TxDescriptor) String() string { return proto.CompactTextString(m) }
func (*TxDescriptor) ProtoMessage()    {}
func (*TxDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{1}
}
func (m *TxDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDescriptor.Merge(m, src)
}
func (m *TxDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TxDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TxDescriptor proto.InternalMessageInfo

func (m *TxDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *TxDescriptor) GetMsgs() []*MsgDescriptor {
	if m != nil {
		return m.Msgs
	}
	return nil
}

// AuthnDescriptor provides information on how to sign transactions without relying
// on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
type AuthnDescriptor struct {
	// sign_modes defines the supported signature algorithm
	SignModes []*SigningModeDescriptor `protobuf:"bytes,1,rep,name=sign_modes,json=signModes,proto3" json:"sign_modes,omitempty"`
}

func (m *AuthnDescriptor) Reset()         { *m = AuthnDescriptor{} }
func (m *AuthnDescriptor) String() string { return proto.CompactTextString(m) }
func (*AuthnDescriptor) ProtoMessage()    {}
func (*AuthnDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{2}
}
func (m *AuthnDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthnDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthnDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnDescriptor.Merge(m, src)
}
func (m *AuthnDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *AuthnDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnDescriptor proto.InternalMessageInfo

func (m *AuthnDescriptor) GetSignModes() []*SigningModeDescriptor {
	if m != nil {
		return m.SignModes
	}
	return nil
}

// SigningModeDescriptor provides information on a signing flow of the application
// NOTE(fdymylja): here we could go as far as providing an entire flow on how
// to sign a message given a SigningModeDescriptor, but it's better to think about
// this another time
type SigningModeDescriptor struct {
	// name defines the unique name of the signing mode
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// number is the unique int32 identifier for the sign_mode enum
	Number int32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	// authn_info_provider_method_fullname defines the fullname of the method to call to get
	// the metadata required to authenticate using the provided sign_modes
	AuthnInfoProviderMethodFullname string `protobuf:"bytes,3,opt,name=authn_info_provider_method_fullname,json=authnInfoProviderMethodFullname,proto3" json:"authn_info_provider_method_fullname,omitempty"`
}

func (m *SigningModeDescriptor) Reset()         { *m = SigningModeDescriptor{} }
func (m *SigningModeDescriptor) String() string { return proto.CompactTextString(m) }
func (*SigningModeDescriptor) ProtoMessage()    {}
func (*SigningModeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{3}
}
func (m *SigningModeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningModeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningModeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningModeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningModeDescriptor.Merge(m, src)
}
func (m *SigningModeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SigningModeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningModeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SigningModeDescriptor proto.InternalMessageInfo

func (m *SigningModeDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SigningModeDescriptor) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *SigningModeDescriptor) GetAuthnInfoProviderMethodFullname() string {
	if m != nil {
		return m.AuthnInfoProviderMethodFullname
	}
	return ""
}

// ChainDescriptor describes chain information of the application
type ChainDescriptor struct {
	// id is the chain id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ChainDescriptor) Reset()         { *m = ChainDescriptor{} }
func (m *ChainDescriptor) String() string { return proto.CompactTextString(m) }
func (*ChainDescriptor) ProtoMessage()    {}
func (*ChainDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{4}
}
func (m *ChainDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainDescriptor.Merge(m, src)
}
func (m *ChainDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ChainDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ChainDescriptor proto.InternalMessageInfo

func (m *ChainDescriptor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// CodecDescriptor describes the registered interfaces and provides metadata information on the types
type CodecDescriptor struct {
	// interfaces is a list of the registerted interfaces descriptors
	Interfaces []*InterfaceDescriptor `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces,omitempty"`
}

func (m *CodecDescriptor) Reset()         { *m = CodecDescriptor{} }
func (m *CodecDescriptor) String() string { return proto.CompactTextString(m) }
func (*CodecDescriptor) ProtoMessage()    {}
func (*CodecDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{5}
}
func (m *CodecDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CodecDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CodecDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CodecDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodecDescriptor.Merge(m, src)
}
func (m *CodecDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CodecDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CodecDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CodecDescriptor proto.InternalMessageInfo

func (m *CodecDescriptor) GetInterfaces() []*InterfaceDescriptor {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// InterfaceDescriptor describes the implementation of an interface
type InterfaceDescriptor struct {
	// fullname is the name of the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// interface_accepting_messages contains information regarding the proto messages which contain the interface as
	// google.protobuf.Any field
	InterfaceAcceptingMessages []*InterfaceAcceptingMessageDescriptor `protobuf:"bytes,2,rep,name=interface_accepting_messages,json=interfaceAcceptingMessages,proto3" json:"interface_accepting_messages,omitempty"`
	// interface_implementers is a list of the descriptors of the interface implementers
	InterfaceImplementers []*InterfaceImplementerDescriptor `protobuf:"bytes,3,rep,name=interface_implementers,json=interfaceImplementers,proto3" json:"interface_implementers,omitempty"`
}

func (m *InterfaceDescriptor) Reset()         { *m = InterfaceDescriptor{} }
func (m *InterfaceDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceDescriptor) ProtoMessage()    {}
func (*InterfaceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{6}
}
func (m *InterfaceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceDescriptor.Merge(m, src)
}
func (m *InterfaceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceDescriptor proto.InternalMessageInfo

func (m *InterfaceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceDescriptor) GetInterfaceAcceptingMessages() []*InterfaceAcceptingMessageDescriptor {
	if m != nil {
		return m.InterfaceAcceptingMessages
	}
	return nil
}

func (m *InterfaceDescriptor) GetInterfaceImplementers() []*InterfaceImplementerDescriptor {
	if m != nil {
		return m.InterfaceImplementers
	}
	return nil
}

// InterfaceImplementerDescriptor describes an interface implementer
type InterfaceImplementerDescriptor struct {
	// fullname is the protobuf queryable name of the interface implementer
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// type_url defines the type URL used when marshalling the type as any
	// this is required so we can provide type safe google.protobuf.Any marshalling and
	// unmarshalling, making sure that we don't accept just 'any' type
	// in our interface fields
	TypeUrl string `protobuf:"bytes,2,opt,name=type_url,json=typeUrl,proto3" json:"type_url,omitempty"`
}

func (m *InterfaceImplementerDescriptor) Reset()         { *m = InterfaceImplementerDescriptor{} }
func (m *InterfaceImplementerDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceImplementerDescriptor) ProtoMessage()    {}
func (*InterfaceImplementerDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{7}
}
func (m *InterfaceImplementerDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceImplementerDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceImplementerDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceImplementerDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceImplementerDescriptor.Merge(m, src)
}
func (m *InterfaceImplementerDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceImplementerDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceImplementerDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceImplementerDescriptor proto.InternalMessageInfo

func (m *InterfaceImplementerDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceImplementerDescriptor) GetTypeUrl() string {
	if m != nil {
		return m.TypeUrl
	}
	return ""
}

// InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
// an interface represented as a google.protobuf.Any
type InterfaceAcceptingMessageDescriptor struct {
	// fullname is the protobuf fullname of the type containing the interface
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// field_descriptor_names is a list of the protobuf name (not fullname) of the field
	// which contains the interface as google.protobuf.Any (the interface is the same, but
	// it can be in multiple fields of the same proto message)
	FieldDescriptorNames []string `protobuf:"bytes,2,rep,name=field_descriptor_names,json=fieldDescriptorNames,proto3" json:"field_descriptor_names,omitempty"`
}

func (m *InterfaceAcceptingMessageDescriptor) Reset()         { *m = InterfaceAcceptingMessageDescriptor{} }
func (m *InterfaceAcceptingMessageDescriptor) String() string { return proto.CompactTextString(m) }
func (*InterfaceAcceptingMessageDescriptor) ProtoMessage()    {}
func (*InterfaceAcceptingMessageDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{8}
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InterfaceAcceptingMessageDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceAcceptingMessageDescriptor.Merge(m, src)
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceAcceptingMessageDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceAcceptingMessageDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceAcceptingMessageDescriptor proto.InternalMessageInfo

func (m *InterfaceAcceptingMessageDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *InterfaceAcceptingMessageDescriptor) GetFieldDescriptorNames() []string {
	if m != nil {
		return m.FieldDescriptorNames
	}
	return nil
}

// MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
type MsgDescriptor struct {
	// msg_type_url contains the TypeURL of a sdk.Msg.
	MsgTypeUrl string `protobuf:"bytes,1,opt,name=msg_type_url,json=msgTypeUrl,proto3" json:"msg_type_url,omitempty"`
}

func (m *MsgDescriptor) Reset()         { *m = MsgDescriptor{} }
func (m *MsgDescriptor) String() string { return proto.CompactTextString(m) }
func (*MsgDescriptor) ProtoMessage()    {}
func (*MsgDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{9}
}
func (m *MsgDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDescriptor.Merge(m, src)
}
func (m *MsgDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *MsgDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDescriptor proto.InternalMessageInfo

func (m *MsgDescriptor) GetMsgTypeUrl() string {
	if m != nil {
		return m.MsgTypeUrl
	}
	return ""
}

// GetAuthnDescriptorRequest is the request used for the GetAuthnDescriptor RPC
type GetAuthnDescriptorRequest struct {
}

func (m *GetAuthnDescriptorRequest) Reset()         { *m = GetAuthnDescriptorRequest{} }
func (m *GetAuthnDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetAuthnDescriptorRequest) ProtoMessage()    {}
func (*GetAuthnDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{10}
}
func (m *GetAuthnDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthnDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthnDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthnDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthnDescriptorRequest.Merge(m, src)
}
func (m *GetAuthnDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthnDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthnDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthnDescriptorRequest proto.InternalMessageInfo

// GetAuthnDescriptorResponse is the response returned by the GetAuthnDescriptor RPC
type GetAuthnDescriptorResponse struct {
	// authn describes how to authenticate to the application when sending transactions
	Authn *AuthnDescriptor `protobuf:"bytes,1,opt,name=authn,proto3" json:"authn,omitempty"`
}

func (m *GetAuthnDescriptorResponse) Reset()         { *m = GetAuthnDescriptorResponse{} }
func (m *GetAuthnDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetAuthnDescriptorResponse) ProtoMessage()    {}
func (*GetAuthnDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{11}
}
func (m *GetAuthnDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAuthnDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAuthnDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAuthnDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAuthnDescriptorResponse.Merge(m, src)
}
func (m *GetAuthnDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAuthnDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAuthnDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAuthnDescriptorResponse proto.InternalMessageInfo

func (m *GetAuthnDescriptorResponse) GetAuthn() *AuthnDescriptor {
	if m != nil {
		return m.Authn
	}
	return nil
}

// GetChainDescriptorRequest is the request used for the GetChainDescriptor RPC
type GetChainDescriptorRequest struct {
}

func (m *GetChainDescriptorRequest) Reset()         { *m = GetChainDescriptorRequest{} }
func (m *GetChainDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetChainDescriptorRequest) ProtoMessage()    {}
func (*GetChainDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{12}
}
func (m *GetChainDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetChainDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetChainDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetChainDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChainDescriptorRequest.Merge(m, src)
}
func (m *GetChainDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetChainDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChainDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetChainDescriptorRequest proto.InternalMessageInfo

// GetChainDescriptorResponse is the response returned by the GetChainDescriptor RPC
type GetChainDescriptorResponse struct {
	// chain describes application chain information
	Chain *ChainDescriptor `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
}

func (m *GetChainDescriptorResponse) Reset()         { *m = GetChainDescriptorResponse{} }
func (m *GetChainDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetChainDescriptorResponse) ProtoMessage()    {}
func (*GetChainDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{13}
}
func (m *GetChainDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetChainDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetChainDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetChainDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChainDescriptorResponse.Merge(m, src)
}
func (m *GetChainDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetChainDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChainDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetChainDescriptorResponse proto.InternalMessageInfo

func (m *GetChainDescriptorResponse) GetChain() *ChainDescriptor {
	if m != nil {
		return m.Chain
	}
	return nil
}

// GetCodecDescriptorRequest is the request used for the GetCodecDescriptor RPC
type GetCodecDescriptorRequest struct {
}

func (m *GetCodecDescriptorRequest) Reset()         { *m = GetCodecDescriptorRequest{} }
func (m *GetCodecDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetCodecDescriptorRequest) ProtoMessage()    {}
func (*GetCodecDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{14}
}
func (m *GetCodecDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCodecDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCodecDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCodecDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCodecDescriptorRequest.Merge(m, src)
}
func (m *GetCodecDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCodecDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCodecDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCodecDescriptorRequest proto.InternalMessageInfo

// GetCodecDescriptorResponse is the response returned by the GetCodecDescriptor RPC
type GetCodecDescriptorResponse struct {
	// codec describes the application codec such as registered interfaces and implementations
	Codec *CodecDescriptor `protobuf:"bytes,1,opt,name=codec,proto3" json:"codec,omitempty"`
}

func (m *GetCodecDescriptorResponse) Reset()         { *m = GetCodecDescriptorResponse{} }
func (m *GetCodecDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetCodecDescriptorResponse) ProtoMessage()    {}
func (*GetCodecDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{15}
}
func (m *GetCodecDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCodecDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCodecDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCodecDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCodecDescriptorResponse.Merge(m, src)
}
func (m *GetCodecDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCodecDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCodecDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCodecDescriptorResponse proto.InternalMessageInfo

func (m *GetCodecDescriptorResponse) GetCodec() *CodecDescriptor {
	if m != nil {
		return m.Codec
	}
	return nil
}

// GetQueryServicesDescriptorRequest is the request used for the GetQueryServicesDescriptor RPC
type GetQueryServicesDescriptorRequest struct {
}

func (m *GetQueryServicesDescriptorRequest) Reset()         { *m = GetQueryServicesDescriptorRequest{} }
func (m *GetQueryServicesDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetQueryServicesDescriptorRequest) ProtoMessage()    {}
func (*GetQueryServicesDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{16}
}
func (m *GetQueryServicesDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetQueryServicesDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetQueryServicesDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetQueryServicesDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetQueryServicesDescriptorRequest.Merge(m, src)
}
func (m *GetQueryServicesDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetQueryServicesDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetQueryServicesDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetQueryServicesDescriptorRequest proto.InternalMessageInfo

// GetQueryServicesDescriptorResponse is the response returned by the GetQueryServicesDescriptor RPC
type GetQueryServicesDescriptorResponse struct {
	// queries provides information on the available queryable services
	Queries *QueryServicesDescriptor `protobuf:"bytes,1,opt,name=queries,proto3" json:"queries,omitempty"`
}

func (m *GetQueryServicesDescriptorResponse) Reset()         { *m = GetQueryServicesDescriptorResponse{} }
func (m *GetQueryServicesDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetQueryServicesDescriptorResponse) ProtoMessage()    {}
func (*GetQueryServicesDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{17}
}
func (m *GetQueryServicesDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetQueryServicesDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetQueryServicesDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetQueryServicesDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetQueryServicesDescriptorResponse.Merge(m, src)
}
func (m *GetQueryServicesDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetQueryServicesDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetQueryServicesDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetQueryServicesDescriptorResponse proto.InternalMessageInfo

func (m *GetQueryServicesDescriptorResponse) GetQueries() *QueryServicesDescriptor {
	if m != nil {
		return m.Queries
	}
	return nil
}

// GetTxDescriptorRequest is the request used for the GetTxDescriptor RPC
type GetTxDescriptorRequest struct {
}

func (m *GetTxDescriptorRequest) Reset()         { *m = GetTxDescriptorRequest{} }
func (m *GetTxDescriptorRequest) String() string { return proto.CompactTextString(m) }
func (*GetTxDescriptorRequest) ProtoMessage()    {}
func (*GetTxDescriptorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{18}
}
func (m *GetTxDescriptorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxDescriptorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxDescriptorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxDescriptorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxDescriptorRequest.Merge(m, src)
}
func (m *GetTxDescriptorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTxDescriptorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxDescriptorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxDescriptorRequest proto.InternalMessageInfo

// GetTxDescriptorResponse is the response returned by the GetTxDescriptor RPC
type GetTxDescriptorResponse struct {
	// tx provides information on msgs that can be forwarded to the application
	// alongside the accepted transaction protobuf type
	Tx *TxDescriptor `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *GetTxDescriptorResponse) Reset()         { *m = GetTxDescriptorResponse{} }
func (m *GetTxDescriptorResponse) String() string { return proto.CompactTextString(m) }
func (*GetTxDescriptorResponse) ProtoMessage()    {}
func (*GetTxDescriptorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{19}
}
func (m *GetTxDescriptorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxDescriptorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxDescriptorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxDescriptorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxDescriptorResponse.Merge(m, src)
}
func (m *GetTxDescriptorResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTxDescriptorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxDescriptorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxDescriptorResponse proto.InternalMessageInfo

func (m *GetTxDescriptorResponse) GetTx() *TxDescriptor {
	if m != nil {
		return m.Tx
	}
	return nil
}

// QueryServicesDescriptor contains the list of cosmos-sdk queryable services
type QueryServicesDescriptor struct {
	// query_services is a list of cosmos-sdk QueryServiceDescriptor
	QueryServices []*QueryServiceDescriptor `protobuf:"bytes,1,rep,name=query_services,json=queryServices,proto3" json:"query_services,omitempty"`
}

func (m *QueryServicesDescriptor) Reset()         { *m = QueryServicesDescriptor{} }
func (m *QueryServicesDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServicesDescriptor) ProtoMessage()    {}
func (*QueryServicesDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{20}
}
func (m *QueryServicesDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServicesDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServicesDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServicesDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServicesDescriptor.Merge(m, src)
}
func (m *QueryServicesDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServicesDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServicesDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServicesDescriptor proto.InternalMessageInfo

func (m *QueryServicesDescriptor) GetQueryServices() []*QueryServiceDescriptor {
	if m != nil {
		return m.QueryServices
	}
	return nil
}

// QueryServiceDescriptor describes a cosmos-sdk queryable service
type QueryServiceDescriptor struct {
	// fullname is the protobuf fullname of the service descriptor
	Fullname string `protobuf:"bytes,1,opt,name=fullname,proto3" json:"fullname,omitempty"`
	// is_module describes if this service is actually exposed by an application's module
	IsModule bool `protobuf:"varint,2,opt,name=is_module,json=isModule,proto3" json:"is_module,omitempty"`
	// methods provides a list of query service methods
	Methods []*QueryMethodDescriptor `protobuf:"bytes,3,rep,name=methods,proto3" json:"methods,omitempty"`
}

func (m *QueryServiceDescriptor) Reset()         { *m = QueryServiceDescriptor{} }
func (m *QueryServiceDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryServiceDescriptor) ProtoMessage()    {}
func (*QueryServiceDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{21}
}
func (m *QueryServiceDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryServiceDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryServiceDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryServiceDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryServiceDescriptor.Merge(m, src)
}
func (m *QueryServiceDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryServiceDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryServiceDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryServiceDescriptor proto.InternalMessageInfo

func (m *QueryServiceDescriptor) GetFullname() string {
	if m != nil {
		return m.Fullname
	}
	return ""
}

func (m *QueryServiceDescriptor) GetIsModule() bool {
	if m != nil {
		return m.IsModule
	}
	return false
}

func (m *QueryServiceDescriptor) GetMethods() []*QueryMethodDescriptor {
	if m != nil {
		return m.Methods
	}
	return nil
}

// QueryMethodDescriptor describes a queryable method of a query service
// no other info is provided beside method name and tendermint queryable path
// because it would be redundant with the grpc reflection service
type QueryMethodDescriptor struct {
	// name is the protobuf name (not fullname) of the method
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// full_query_path is the path that can be used to query
	// this method via tendermint abci.Query
	FullQueryPath string `protobuf:"bytes,2,opt,name=full_query_path,json=fullQueryPath,proto3" json:"full_query_path,omitempty"`
}

func (m *QueryMethodDescriptor) Reset()         { *m = QueryMethodDescriptor{} }
func (m *QueryMethodDescriptor) String() string { return proto.CompactTextString(m) }
func (*QueryMethodDescriptor) ProtoMessage()    {}
func (*QueryMethodDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_15c91f0b8d6bf3d0, []int{22}
}
func (m *QueryMethodDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMethodDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMethodDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMethodDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMethodDescriptor.Merge(m, src)
}
func (m *QueryMethodDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *QueryMethodDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMethodDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMethodDescriptor proto.InternalMessageInfo

func (m *QueryMethodDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryMethodDescriptor) GetFullQueryPath() string {
	if m != nil {
		return m.FullQueryPath
	}
	return ""
}

func init() {
	proto.RegisterType((*AppDescriptor)(nil), "cosmos.base.reflection.v2alpha1.AppDescriptor")
	proto.RegisterType((*TxDescriptor)(nil), "cosmos.base.reflection.v2alpha1.TxDescriptor")
	proto.RegisterType((*AuthnDescriptor)(nil), "cosmos.base.reflection.v2alpha1.AuthnDescriptor")
	proto.RegisterType((*SigningModeDescriptor)(nil), "cosmos.base.reflection.v2alpha1.SigningModeDescriptor")
	proto.RegisterType((*ChainDescriptor)(nil), "cosmos.base.reflection.v2alpha1.ChainDescriptor")
	proto.RegisterType((*CodecDescriptor)(nil), "cosmos.base.reflection.v2alpha1.CodecDescriptor")
	proto.RegisterType((*InterfaceDescriptor)(nil), "cosmos.base.reflection.v2alpha1.InterfaceDescriptor")
	proto.RegisterType((*InterfaceImplementerDescriptor)(nil), "cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor")
	proto.RegisterType((*InterfaceAcceptingMessageDescriptor)(nil), "cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor")
	proto.RegisterType((*MsgDescriptor)(nil), "cosmos.base.reflection.v2alpha1.MsgDescriptor")
	proto.RegisterType((*GetAuthnDescriptorRequest)(nil), "cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest")
	proto.RegisterType((*GetAuthnDescriptorResponse)(nil), "cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse")
	proto.RegisterType((*GetChainDescriptorRequest)(nil), "cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest")
	proto.RegisterType((*GetChainDescriptorResponse)(nil), "cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse")
	proto.RegisterType((*GetCodecDescriptorRequest)(nil), "cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest")
	proto.RegisterType((*GetCodecDescriptorResponse)(nil), "cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse")
	proto.RegisterType((*GetQueryServicesDescriptorRequest)(nil), "cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest")
	proto.RegisterType((*GetQueryServicesDescriptorResponse)(nil), "cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse")
	proto.RegisterType((*GetTxDescriptorRequest)(nil), "cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest")
	proto.RegisterType((*GetTxDescriptorResponse)(nil), "cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse")
	proto.RegisterType((*QueryServicesDescriptor)(nil), "cosmos.base.reflection.v2alpha1.QueryServicesDescriptor")
	proto.RegisterType((*QueryServiceDescriptor)(nil), "cosmos.base.reflection.v2alpha1.QueryServiceDescriptor")
	proto.RegisterType((*QueryMethodDescriptor)(nil), "cosmos.base.reflection.v2alpha1.QueryMethodDescriptor")
}

func init() {
	proto.RegisterFile("cosmos/base/reflection/v2alpha1/reflection.proto", fileDescriptor_15c91f0b8d6bf3d0)
}

var fileDescriptor_15c91f0b8d6bf3d0 = []byte{
	// 1053 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0xff, 0xec, 0xd7, 0xa6, 0x86, 0x81, 0xb8, 0xae, 0x5b, 0xb9, 0xe9, 0x46, 0x42,
	0xbd, 0xd4, 0xdb, 0x84, 0x28, 0xad, 0x20, 0xa5, 0x4a, 0x1a, 0x1a, 0x05, 0x61, 0x14, 0x9c, 0x14,
	0x10, 0x07, 0x56, 0xeb, 0xdd, 0xf1, 0x7a, 0xc4, 0xfe, 0xcb, 0xce, 0x38, 0x38, 0x57, 0x0e, 0xdc,
	0x90, 0x40, 0x7c, 0x04, 0xbe, 0x01, 0x37, 0xbe, 0x01, 0x82, 0x4b, 0x25, 0x2e, 0x1c, 0x51, 0xc2,
	0x91, 0x0f, 0x81, 0x66, 0x76, 0xd7, 0x1e, 0x6f, 0xd6, 0xf6, 0x26, 0xe1, 0x94, 0xcc, 0xbe, 0xf7,
	0x7e, 0xf3, 0xfb, 0xcd, 0xbe, 0xfd, 0xbd, 0x31, 0x3c, 0x36, 0x7d, 0xea, 0xfa, 0x54, 0x6b, 0x1b,
	0x14, 0x6b, 0x21, 0xee, 0x38, 0xd8, 0x64, 0xc4, 0xf7, 0xb4, 0x93, 0x75, 0xc3, 0x09, 0xba, 0xc6,
	0x9a, 0xf4, 0xac, 0x11, 0x84, 0x3e, 0xf3, 0xd1, 0xfd, 0xa8, 0xa2, 0xc1, 0x2b, 0x1a, 0x52, 0x34,
	0xa9, 0xa8, 0xdd, 0xb3, 0x7d, 0xdf, 0x76, 0xb0, 0x66, 0x04, 0x44, 0x33, 0x3c, 0xcf, 0x67, 0x06,
	0x8f, 0xd3, 0xa8, 0x5c, 0xfd, 0x7e, 0x16, 0x96, 0xb6, 0x83, 0x60, 0x17, 0x53, 0x33, 0x24, 0x01,
	0xf3, 0x43, 0xf4, 0x12, 0xe6, 0x8d, 0x1e, 0xeb, 0x7a, 0x55, 0x65, 0x45, 0x79, 0x78, 0x63, 0xfd,
	0x71, 0x63, 0xca, 0x06, 0x8d, 0x6d, 0x9e, 0x3d, 0x04, 0x68, 0x45, 0xe5, 0x1c, 0xc7, 0xec, 0x1a,
	0xc4, 0xab, 0x16, 0x72, 0xe2, 0xbc, 0xe0, 0xd9, 0x32, 0x8e, 0x28, 0x17, 0x38, 0xbe, 0x85, 0xcd,
	0xea, 0x6c, 0x5e, 0x1c, 0x9e, 0x3d, 0x82, 0xc3, 0x1f, 0x20, 0x1d, 0x6e, 0x1d, 0xf7, 0x70, 0x78,
	0xaa, 0x53, 0x1c, 0x9e, 0x10, 0x13, 0xd3, 0xea, 0xbc, 0x00, 0x7c, 0x3a, 0x15, 0xf0, 0x53, 0x5e,
	0x76, 0x18, 0x57, 0x49, 0xc0, 0x4b, 0xc7, 0x72, 0x00, 0x3d, 0x83, 0x02, 0xeb, 0x57, 0x17, 0x04,
	0xe8, 0xa3, 0xa9, 0xa0, 0x47, 0x7d, 0x09, 0xa9, 0xc0, 0xfa, 0x1f, 0xcd, 0x15, 0xe7, 0xde, 0x98,
	0x57, 0x3d, 0xb8, 0x29, 0x47, 0x50, 0x0d, 0x8a, 0x9d, 0x9e, 0xe3, 0x78, 0x86, 0x8b, 0xc5, 0x0b,
	0x29, 0xb5, 0x06, 0x6b, 0xb4, 0x03, 0x73, 0x2e, 0xb5, 0x69, 0xb5, 0xb0, 0x32, 0xfb, 0xf0, 0xc6,
	0x7a, 0x63, 0xea, 0x96, 0x4d, 0x6a, 0x4b, 0x7b, 0x8a, 0x5a, 0xb5, 0x0b, 0xe5, 0xd4, 0xfb, 0x43,
	0xaf, 0x00, 0x28, 0xb1, 0x3d, 0xdd, 0xf5, 0x2d, 0x4c, 0xab, 0x8a, 0x00, 0xdf, 0x9c, 0x0a, 0x7e,
	0x48, 0x6c, 0x8f, 0x78, 0x76, 0xd3, 0xb7, 0xb0, 0xb4, 0x49, 0x89, 0x23, 0xf1, 0x67, 0x54, 0xfd,
	0x51, 0x81, 0xe5, 0xcc, 0x24, 0x84, 0x60, 0x4e, 0xd2, 0x27, 0xfe, 0x47, 0x15, 0x58, 0xf0, 0x7a,
	0x6e, 0x1b, 0x87, 0xa2, 0x7d, 0xe6, 0x5b, 0xf1, 0x0a, 0x7d, 0x0c, 0xab, 0xa2, 0xbd, 0x74, 0xe2,
	0x75, 0x7c, 0x3d, 0x08, 0xfd, 0x13, 0x62, 0xe1, 0x50, 0x77, 0x31, 0xeb, 0xfa, 0x96, 0x3e, 0x38,
	0xaa, 0x59, 0x01, 0x75, 0x5f, 0xa4, 0xee, 0x7b, 0x1d, 0xff, 0x20, 0x4e, 0x6c, 0x8a, 0xbc, 0x97,
	0x71, 0x9a, 0xfa, 0x00, 0xca, 0xa9, 0xae, 0x43, 0xb7, 0xa0, 0x40, 0xac, 0x98, 0x4a, 0x81, 0x58,
	0xaa, 0x0d, 0xe5, 0x54, 0x43, 0xa1, 0x23, 0x00, 0xe2, 0x31, 0x1c, 0x76, 0x0c, 0x73, 0x70, 0x40,
	0x1b, 0x53, 0x0f, 0x68, 0x3f, 0x29, 0x91, 0x8e, 0x47, 0xc2, 0x51, 0x7f, 0x29, 0xc0, 0x5b, 0x19,
	0x39, 0x13, 0x3b, 0xe0, 0x3b, 0x05, 0xee, 0x0d, 0x20, 0x74, 0xc3, 0x34, 0x71, 0xc0, 0x88, 0x67,
	0xeb, 0x2e, 0xa6, 0xd4, 0xb0, 0x71, 0xd2, 0x1a, 0xbb, 0xf9, 0xc9, 0x6d, 0x27, 0x18, 0xcd, 0x08,
	0x42, 0x22, 0x5b, 0x23, 0xe3, 0x92, 0x28, 0x3a, 0x81, 0xca, 0x90, 0x07, 0x71, 0x03, 0x07, 0xbb,
	0x98, 0xaf, 0x69, 0x75, 0x56, 0x30, 0x78, 0x9e, 0x9f, 0xc1, 0xfe, 0xb0, 0x5a, 0xda, 0x7c, 0x99,
	0x64, 0xc4, 0xa9, 0xfa, 0x39, 0xd4, 0x27, 0x17, 0x4e, 0x3c, 0xbe, 0x3b, 0x50, 0x64, 0xa7, 0x01,
	0xd6, 0x7b, 0xa1, 0x23, 0xda, 0xac, 0xd4, 0x5a, 0xe4, 0xeb, 0x57, 0xa1, 0xa3, 0x7e, 0x03, 0xab,
	0x39, 0xce, 0x64, 0x22, 0xfa, 0x06, 0x54, 0x3a, 0x04, 0x3b, 0x96, 0x6e, 0x0d, 0xf2, 0x75, 0x1e,
	0x88, 0xde, 0x4a, 0xa9, 0xf5, 0xb6, 0x88, 0x0e, 0xc1, 0x3e, 0xe1, 0x31, 0x75, 0x0d, 0x96, 0x46,
	0xbe, 0x53, 0xb4, 0x02, 0x37, 0x5d, 0x6a, 0xeb, 0x03, 0xa2, 0xd1, 0x36, 0xe0, 0x52, 0xfb, 0x28,
	0xe6, 0x7a, 0x17, 0xee, 0xec, 0x61, 0x96, 0xb6, 0x61, 0x7c, 0xdc, 0xc3, 0x94, 0xa9, 0x16, 0xd4,
	0xb2, 0x82, 0x34, 0xf0, 0x3d, 0x8a, 0xff, 0x2f, 0xb3, 0x8f, 0x29, 0xa4, 0x1d, 0x7c, 0x84, 0xc2,
	0x85, 0xe0, 0x90, 0x42, 0x34, 0x27, 0x94, 0x6b, 0xcd, 0x89, 0x84, 0x42, 0xca, 0xfc, 0x47, 0x29,
	0xa4, 0x83, 0x12, 0x05, 0x31, 0x62, 0x94, 0x6b, 0x8d, 0x18, 0x75, 0x15, 0x1e, 0xec, 0x61, 0x36,
	0x6e, 0x5c, 0xc4, 0x54, 0xfa, 0xa0, 0x4e, 0x4a, 0x8a, 0x29, 0xb5, 0x60, 0x91, 0x4f, 0x17, 0x22,
	0x0c, 0xe6, 0x7a, 0x63, 0x2a, 0x01, 0x52, 0xab, 0x50, 0xd9, 0xc3, 0x6c, 0x64, 0xf0, 0xc4, 0x9c,
	0xbe, 0x80, 0xdb, 0x17, 0x22, 0x31, 0x91, 0x68, 0xaa, 0x29, 0x57, 0x9c, 0x6a, 0xea, 0x29, 0xdc,
	0x1e, 0xc3, 0x0b, 0x7d, 0x75, 0x61, 0x20, 0x47, 0x56, 0xfa, 0xe4, 0x52, 0x4a, 0xc7, 0xce, 0x63,
	0xf5, 0x67, 0x05, 0x2a, 0xd9, 0x99, 0x13, 0x3f, 0xdb, 0xbb, 0x50, 0x22, 0x94, 0x0f, 0xbf, 0x9e,
	0x83, 0x85, 0x2b, 0x14, 0x5b, 0x45, 0x42, 0x9b, 0x62, 0x8d, 0x0e, 0x60, 0x31, 0x1a, 0x35, 0x89,
	0xb1, 0x6d, 0xe6, 0x23, 0x1b, 0xcd, 0x1d, 0xf9, 0xa5, 0xc4, 0x30, 0xea, 0x21, 0x2c, 0x67, 0x66,
	0x64, 0x4e, 0xc5, 0x77, 0xa0, 0xcc, 0x79, 0xea, 0xd1, 0xb9, 0x05, 0x06, 0xeb, 0xc6, 0xbe, 0xb5,
	0xc4, 0x1f, 0x0b, 0x9c, 0x03, 0x83, 0x75, 0xd7, 0x7f, 0x2d, 0xc2, 0x9b, 0xad, 0x01, 0x97, 0x58,
	0x3f, 0xfa, 0x43, 0x01, 0x74, 0xd1, 0x0b, 0xd0, 0x7b, 0x53, 0x25, 0x8c, 0x75, 0x97, 0xda, 0xfb,
	0x57, 0xaa, 0x8d, 0x5a, 0x4b, 0xdd, 0xfa, 0xf6, 0xcf, 0x7f, 0x7e, 0x2a, 0x6c, 0xa2, 0x0d, 0x6d,
	0xdc, 0xad, 0x77, 0xad, 0x8d, 0x99, 0xb1, 0xa6, 0x19, 0x41, 0x20, 0x99, 0xa8, 0x16, 0xdd, 0x2f,
	0x63, 0x35, 0xe9, 0xf9, 0x9d, 0x4b, 0x4d, 0xb6, 0x51, 0xe5, 0x53, 0x33, 0xc6, 0xc7, 0xae, 0xac,
	0x26, 0xba, 0xe5, 0x26, 0x6a, 0x52, 0x57, 0x8d, 0x7c, 0x6a, 0x32, 0x3d, 0x2f, 0xa7, 0x9a, 0x6c,
	0x4b, 0xbc, 0xba, 0x1a, 0x71, 0xd7, 0xfe, 0x57, 0x11, 0x7e, 0x3b, 0xee, 0xcb, 0xdf, 0xc9, 0xc3,
	0x6c, 0xb2, 0x8d, 0xd6, 0x5e, 0x5c, 0x0b, 0x23, 0x56, 0xf9, 0xa1, 0x50, 0xf9, 0x1c, 0x3d, 0xbb,
	0xa4, 0xca, 0x51, 0xdf, 0x42, 0xbf, 0x2b, 0x50, 0x4e, 0xf9, 0x27, 0x7a, 0x92, 0x87, 0x5f, 0x86,
	0x17, 0xd7, 0x9e, 0x5e, 0xbe, 0x30, 0x56, 0xb3, 0x2b, 0xd4, 0x7c, 0x80, 0xb6, 0x2e, 0xa9, 0x86,
	0xf5, 0xa5, 0xd5, 0xce, 0x67, 0xbf, 0x9d, 0xd5, 0x95, 0xd7, 0x67, 0x75, 0xe5, 0xef, 0xb3, 0xba,
	0xf2, 0xc3, 0x79, 0x7d, 0xe6, 0xf5, 0x79, 0x7d, 0xe6, 0xaf, 0xf3, 0xfa, 0xcc, 0x97, 0x5b, 0x36,
	0x61, 0xdd, 0x5e, 0xbb, 0x61, 0xfa, 0x6e, 0xb2, 0x43, 0xf4, 0xe7, 0x11, 0xb5, 0xbe, 0xd6, 0xf8,
	0x69, 0xe0, 0x50, 0xb3, 0xc3, 0xc0, 0xcc, 0xfa, 0xe5, 0xda, 0x5e, 0x10, 0x3f, 0x38, 0xdf, 0xfd,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0x21, 0x8d, 0xad, 0x5a, 0xe3, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ReflectionServiceClient is the client API for ReflectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ReflectionServiceClient interface {
	// GetAuthnDescriptor returns information on how to authenticate transactions in the application
	// NOTE: this RPC is still experimental and might be subject to breaking changes or removal in
	// future releases of the cosmos-sdk.
	GetAuthnDescriptor(ctx context.Context, in *GetAuthnDescriptorRequest, opts ...grpc.CallOption) (*GetAuthnDescriptorResponse, error)
	// GetChainDescriptor returns the description of the chain
	GetChainDescriptor(ctx context.Context, in *GetChainDescriptorRequest, opts ...grpc.CallOption) (*GetChainDescriptorResponse, error)
	// GetCodecDescriptor returns the descriptor of the codec of the application
	GetCodecDescriptor(ctx context.Context, in *GetCodecDescriptorRequest, opts ...grpc.CallOption) (*GetCodecDescriptorResponse, error)
	// GetQueryServicesDescriptor returns the available gRPC queryable services of the application
	GetQueryServicesDescriptor(ctx context.Context, in *GetQueryServicesDescriptorRequest, opts ...grpc.CallOption) (*GetQueryServicesDescriptorResponse, error)
	// GetTxDescriptor returns information on the used transaction object and available msgs that can be used
	GetTxDescriptor(ctx context.Context, in *GetTxDescriptorRequest, opts ...grpc.CallOption) (*GetTxDescriptorResponse, error)
}

type reflectionServiceClient struct {
	cc grpc1.ClientConn
}

func NewReflectionServiceClient(cc grpc1.ClientConn) ReflectionServiceClient {
	return &reflectionServiceClient{cc}
}

func (c *reflectionServiceClient) GetAuthnDescriptor(ctx context.Context, in *GetAuthnDescriptorRequest, opts ...grpc.CallOption) (*GetAuthnDescriptorResponse, error) {
	out := new(GetAuthnDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v2alpha1.ReflectionService/GetAuthnDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) GetChainDescriptor(ctx context.Context, in *GetChainDescriptorRequest, opts ...grpc.CallOption) (*GetChainDescriptorResponse, error) {
	out := new(GetChainDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v2alpha1.ReflectionService/GetChainDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) GetCodecDescriptor(ctx context.Context, in *GetCodecDescriptorRequest, opts ...grpc.CallOption) (*GetCodecDescriptorResponse, error) {
	out := new(GetCodecDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v2alpha1.ReflectionService/GetCodecDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) GetQueryServicesDescriptor(ctx context.Context, in *GetQueryServicesDescriptorRequest, opts ...grpc.CallOption) (*GetQueryServicesDescriptorResponse, error) {
	out := new(GetQueryServicesDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v2alpha1.ReflectionService/GetQueryServicesDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reflectionServiceClient) GetTxDescriptor(ctx context.Context, in *GetTxDescriptorRequest, opts ...grpc.CallOption) (*GetTxDescriptorResponse, error) {
	out := new(GetTxDescriptorResponse)
	err := c.cc.Invoke(ctx, "/cosmos.base.reflection.v2alpha1.ReflectionService/GetTxDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReflectionServiceServer is the server API for ReflectionService service.
type ReflectionServiceServer interface {
	// GetAuthnDescriptor returns information on how to authenticate transactions in the application
	// NOTE: this RPC is still experimental and might be subject to breaking changes or removal in
	// future releases of the cosmos-sdk.
	GetAuthnDescriptor(context.Context, *GetAuthnDescriptorRequest) (*GetAuthnDescriptorResponse, error)
	// GetChainDescriptor returns the description of the chain
	GetChainDescriptor(context.Context, *GetChainDescriptorRequest) (*GetChainDescriptorResponse, error)
	// GetCodecDescriptor returns the descriptor of the codec of the application
	GetCodecDescriptor(context.Context, *GetCodecDescriptorRequest) (*GetCodecDescriptorResponse, error)
	// GetQueryServicesDescriptor returns the available gRPC queryable services of the application
	GetQueryServicesDescriptor(context.Context, *GetQueryServicesDescriptorRequest) (*GetQueryServicesDescriptorResponse, error)
	// GetTxDescriptor returns information on the used transaction object and available msgs that can be used
	GetTxDescriptor(context.Context, *GetTxDescriptorRequest) (*GetTxDescriptorResponse, error)
}

// UnimplementedReflectionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedReflectionServiceServer struct {
}

func (*UnimplementedReflectionServiceServer) GetAuthnDescriptor(ctx context.Context, req *GetAuthnDescriptorRequest) (*GetAuthnDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthnDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) GetChainDescriptor(ctx context.Context, req *GetChainDescriptorRequest) (*GetChainDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) GetCodecDescriptor(ctx context.Context, req *GetCodecDescriptorRequest) (*GetCodecDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCodecDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) GetQueryServicesDescriptor(ctx context.Context, req *GetQueryServicesDescriptorRequest) (*GetQueryServicesDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueryServicesDescriptor not implemented")
}
func (*UnimplementedReflectionServiceServer) GetTxDescriptor(ctx context.Context, req *GetTxDescriptorRequest) (*GetTxDescriptorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxDescriptor not implemented")
}

func RegisterReflectionServiceServer(s grpc1.Server, srv ReflectionServiceServer) {
	s.RegisterService(&_ReflectionService_serviceDesc, srv)
}

func _ReflectionService_GetAuthnDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthnDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetAuthnDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v2alpha1.ReflectionService/GetAuthnDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetAuthnDescriptor(ctx, req.(*GetAuthnDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_GetChainDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChainDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetChainDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v2alpha1.ReflectionService/GetChainDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetChainDescriptor(ctx, req.(*GetChainDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_GetCodecDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodecDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetCodecDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v2alpha1.ReflectionService/GetCodecDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetCodecDescriptor(ctx, req.(*GetCodecDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_GetQueryServicesDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQueryServicesDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetQueryServicesDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v2alpha1.ReflectionService/GetQueryServicesDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetQueryServicesDescriptor(ctx, req.(*GetQueryServicesDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReflectionService_GetTxDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReflectionServiceServer).GetTxDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cosmos.base.reflection.v2alpha1.ReflectionService/GetTxDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReflectionServiceServer).GetTxDescriptor(ctx, req.(*GetTxDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReflectionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cosmos.base.reflection.v2alpha1.ReflectionService",
	HandlerType: (*ReflectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthnDescriptor",
			Handler:    _ReflectionService_GetAuthnDescriptor_Handler,
		},
		{
			MethodName: "GetChainDescriptor",
			Handler:    _ReflectionService_GetChainDescriptor_Handler,
		},
		{
			MethodName: "GetCodecDescriptor",
			Handler:    _ReflectionService_GetCodecDescriptor_Handler,
		},
		{
			MethodName: "GetQueryServicesDescriptor",
			Handler:    _ReflectionService_GetQueryServicesDescriptor_Handler,
		},
		{
			MethodName: "GetTxDescriptor",
			Handler:    _ReflectionService_GetTxDescriptor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cosmos/base/reflection/v2alpha1/reflection.proto",
}

func (m *AppDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.QueryServices != nil {
		{
			size, err := m.QueryServices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Codec != nil {
		{
			size, err := m.Codec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Authn != nil {
		{
			size, err := m.Authn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignModes) > 0 {
		for iNdEx := len(m.SignModes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SignModes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SigningModeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningModeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningModeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthnInfoProviderMethodFullname) > 0 {
		i -= len(m.AuthnInfoProviderMethodFullname)
		copy(dAtA[i:], m.AuthnInfoProviderMethodFullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.AuthnInfoProviderMethodFullname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != 0 {
		i = encodeVarintReflection(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodecDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodecDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CodecDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceImplementers) > 0 {
		for iNdEx := len(m.InterfaceImplementers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceImplementers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InterfaceAcceptingMessages) > 0 {
		for iNdEx := len(m.InterfaceAcceptingMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceAcceptingMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceImplementerDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceImplementerDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceImplementerDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TypeUrl) > 0 {
		i -= len(m.TypeUrl)
		copy(dAtA[i:], m.TypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.TypeUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceAcceptingMessageDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceAcceptingMessageDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceAcceptingMessageDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FieldDescriptorNames) > 0 {
		for iNdEx := len(m.FieldDescriptorNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FieldDescriptorNames[iNdEx])
			copy(dAtA[i:], m.FieldDescriptorNames[iNdEx])
			i = encodeVarintReflection(dAtA, i, uint64(len(m.FieldDescriptorNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgTypeUrl) > 0 {
		i -= len(m.MsgTypeUrl)
		copy(dAtA[i:], m.MsgTypeUrl)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.MsgTypeUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAuthnDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthnDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthnDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetAuthnDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthnDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAuthnDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Authn != nil {
		{
			size, err := m.Authn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetChainDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChainDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetChainDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetChainDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChainDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetChainDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCodecDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCodecDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCodecDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetCodecDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCodecDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCodecDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Codec != nil {
		{
			size, err := m.Codec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetQueryServicesDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetQueryServicesDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetQueryServicesDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetQueryServicesDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetQueryServicesDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetQueryServicesDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Queries != nil {
		{
			size, err := m.Queries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTxDescriptorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxDescriptorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxDescriptorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTxDescriptorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxDescriptorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxDescriptorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReflection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryServicesDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServicesDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServicesDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for iNdEx := len(m.QueryServices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryServices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryServiceDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryServiceDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryServiceDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Methods) > 0 {
		for iNdEx := len(m.Methods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Methods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintReflection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsModule {
		i--
		if m.IsModule {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Fullname) > 0 {
		i -= len(m.Fullname)
		copy(dAtA[i:], m.Fullname)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Fullname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMethodDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMethodDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMethodDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FullQueryPath) > 0 {
		i -= len(m.FullQueryPath)
		copy(dAtA[i:], m.FullQueryPath)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.FullQueryPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintReflection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReflection(dAtA []byte, offset int, v uint64) int {
	offset -= sovReflection(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authn != nil {
		l = m.Authn.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Codec != nil {
		l = m.Codec.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.QueryServices != nil {
		l = m.QueryServices.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *TxDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *AuthnDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SignModes) > 0 {
		for _, e := range m.SignModes {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *SigningModeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovReflection(uint64(m.Number))
	}
	l = len(m.AuthnInfoProviderMethodFullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *ChainDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *CodecDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.InterfaceAcceptingMessages) > 0 {
		for _, e := range m.InterfaceAcceptingMessages {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	if len(m.InterfaceImplementers) > 0 {
		for _, e := range m.InterfaceImplementers {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *InterfaceImplementerDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.TypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *InterfaceAcceptingMessageDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if len(m.FieldDescriptorNames) > 0 {
		for _, s := range m.FieldDescriptorNames {
			l = len(s)
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *MsgDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MsgTypeUrl)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetAuthnDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetAuthnDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authn != nil {
		l = m.Authn.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetChainDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetChainDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetCodecDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetCodecDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Codec != nil {
		l = m.Codec.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetQueryServicesDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetQueryServicesDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Queries != nil {
		l = m.Queries.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *GetTxDescriptorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTxDescriptorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func (m *QueryServicesDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryServices) > 0 {
		for _, e := range m.QueryServices {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryServiceDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fullname)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	if m.IsModule {
		n += 2
	}
	if len(m.Methods) > 0 {
		for _, e := range m.Methods {
			l = e.Size()
			n += 1 + l + sovReflection(uint64(l))
		}
	}
	return n
}

func (m *QueryMethodDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	l = len(m.FullQueryPath)
	if l > 0 {
		n += 1 + l + sovReflection(uint64(l))
	}
	return n
}

func sovReflection(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReflection(x uint64) (n int) {
	return sovReflection(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authn == nil {
				m.Authn = &AuthnDescriptor{}
			}
			if err := m.Authn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &ChainDescriptor{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Codec == nil {
				m.Codec = &CodecDescriptor{}
			}
			if err := m.Codec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryServices == nil {
				m.QueryServices = &QueryServicesDescriptor{}
			}
			if err := m.QueryServices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &MsgDescriptor{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignModes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignModes = append(m.SignModes, &SigningModeDescriptor{})
			if err := m.SignModes[len(m.SignModes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningModeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningModeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningModeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthnInfoProviderMethodFullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthnInfoProviderMethodFullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodecDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodecDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodecDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &InterfaceDescriptor{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceAcceptingMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceAcceptingMessages = append(m.InterfaceAcceptingMessages, &InterfaceAcceptingMessageDescriptor{})
			if err := m.InterfaceAcceptingMessages[len(m.InterfaceAcceptingMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceImplementers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceImplementers = append(m.InterfaceImplementers, &InterfaceImplementerDescriptor{})
			if err := m.InterfaceImplementers[len(m.InterfaceImplementers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceImplementerDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceImplementerDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceAcceptingMessageDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceAcceptingMessageDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceAcceptingMessageDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldDescriptorNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldDescriptorNames = append(m.FieldDescriptorNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTypeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTypeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthnDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthnDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthnDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthnDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthnDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthnDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authn == nil {
				m.Authn = &AuthnDescriptor{}
			}
			if err := m.Authn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChainDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChainDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChainDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChainDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChainDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChainDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &ChainDescriptor{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCodecDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCodecDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCodecDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCodecDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCodecDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCodecDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Codec == nil {
				m.Codec = &CodecDescriptor{}
			}
			if err := m.Codec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetQueryServicesDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetQueryServicesDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetQueryServicesDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetQueryServicesDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetQueryServicesDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetQueryServicesDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Queries == nil {
				m.Queries = &QueryServicesDescriptor{}
			}
			if err := m.Queries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxDescriptorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxDescriptorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxDescriptorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxDescriptorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxDescriptorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxDescriptorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxDescriptor{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServicesDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServicesDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServicesDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryServices = append(m.QueryServices, &QueryServiceDescriptor{})
			if err := m.QueryServices[len(m.QueryServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryServiceDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryServiceDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryServiceDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsModule", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsModule = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, &QueryMethodDescriptor{})
			if err := m.Methods[len(m.Methods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMethodDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMethodDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMethodDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullQueryPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReflection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReflection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullQueryPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReflection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReflection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReflection(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReflection
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReflection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReflection
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReflection
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReflection
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReflection        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReflection          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReflection = fmt.Errorf("proto: unexpected end of group")
)
