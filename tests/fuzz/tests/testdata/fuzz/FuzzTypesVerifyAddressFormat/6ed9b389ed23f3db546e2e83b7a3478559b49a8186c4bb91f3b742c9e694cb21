go test fuzz v1
[]byte("# This is a TOML config file.\n# For more information, see https://github.com/toml-lang/toml\n\n# NOTE: Any path below can be absolute (e.g. \"/var/myawesomeapp/data\") or\n# relative to the home directory (e.g. \"data\"). The home directory is\n# \"$HOME/.tendermint\" by default, but could be changed via $TMHOME env variable\n# or --home cmd flag.\n\n#######################################################################\n###                   Main Base Config Options                      ###\n#######################################################################\n\n# TCP or UNIX socket address of the ABCI application,\n# or the name of an ABCI application compiled in with the Tendermint binary\nproxy_app = \"{{ .BaseConfig.ProxyApp }}\"\n\n# A custom human readable name for this node\nmoniker = \"{{ .BaseConfig.Moniker }}\"\n\n# If this node is many blocks behind the tip of the chain, FastSync\n# allows them to catchup quickly by downloading blocks in parallel\n# and verifying their commits\nfast_sync = {{ .BaseConfig.FastSyncMode }}\n\n# Database backend: goleveldb | cleveldb | boltdb | rocksdb | badgerdb\n# * goleveldb (github.com/syndtr/goleveldb - most popular implementation)\n#   - pure go\n#   - stable\n# * cleveldb (uses levigo wrapper)\n#   - fast\n#   - requires gcc\n#   - use cleveldb build tag (go build -tags cleveldb)\n# * boltdb (uses etcd's fork of bolt - github.com/etcd-io/bbolt)\n#   - EXPERIMENTAL\n#   - may be faster is some use-cases (random reads - indexer)\n#   - use boltdb build tag (go build -tags boltdb)\n# * rocksdb (uses github.com/tecbot/gorocksdb)\n#   - EXPERIMENTAL\n#   - requires gcc\n#   - use rocksdb build tag (go build -tags rocksdb)\n# * badgerdb (uses github.com/dgraph-io/badger)\n#   - EXPERIMENTAL\n#   - use badgerdb build tag (go build -tags badgerdb)\ndb_backend = \"{{ .BaseConfig.DBBackend }}\"\n\n# Database directory\ndb_dir = \"{{ js .BaseConfig.DBPath }}\"\n\n# Output level for logging, including package level options\nlog_level = \"{{ .BaseConfig.LogLevel }}\"\n\n# Output format: 'plain' (colored text) or 'json'\nlog_format = \"{{ .BaseConfig.LogFormat }}\"\n\n##### additional base config options #####\n\n# Path to the JSON file containing the initial validator set and other meta data\ngenesis_file = \"{{ js .BaseConfig.Genesis }}\"\n\n# Path to the JSON file containing the private key to use as a validator in the consensus protocol\npriv_validator_key_file = \"{{ js .BaseConfig.PrivValidatorKey }}\"\n\n# Path to the JSON file containing the last sign state of a validator\npriv_validator_state_file = \"{{ js .BaseConfig.PrivValidatorState }}\"\n\n# TCP or UNIX socket address for Tendermint to listen on for\n# connections from an external PrivValidator process\npriv_validator_laddr = \"{{ .BaseConfig.PrivValidatorListenAddr }}\"\n\n# Path to the JSON file containing the private key to use for node authentication in the p2p protocol\nnode_key_file = \"{{ js .BaseConfig.NodeKey }}\"\n\n# Mechanism to connect to the ABCI application: socket | grpc\nabci = \"{{ .BaseConfig.ABCI }}\"\n\n# If true, query the ABCI app on connecting to a new peer\n# so the app can decide if we should keep the connection or not\nfilter_peers = {{ .BaseConfig.FilterPeers }}\n\n\n#######################################################################\n###                 Advanced Configuration Options                  ###\n#######################################################################\n\n#######################################################\n###       RPC Server Configuration Options          ###\n#######################################################\n[rpc]\n\n# TCP or UNIX socket address for the RPC server to listen on\nladdr = \"{{ .RPC.ListenAddress }}\"\n\n# A list of origins a cross-domain request can be executed from\n# Default value '[]' disables cors support\n# Use '[\"*\"]' to allow any origin\ncors_allowed_origins = [{{ range .RPC.CORSAllowedOrigins }}{{ printf \"%q, \" . }}{{end}}]\n\n# A list of methods the client is allowed to use with cross-domain requests\ncors_allowed_methods = [{{ range .RPC.CORSAllowedMethods }}{{ printf \"%q, \" . }}{{end}}]\n\n# A list of non simple headers the client is allowed to use with cross-domain requests\ncors_allowed_headers = [{{ range .RPC.CORSAllowedHeaders }}{{ printf \"%q, \" . }}{{end}}]\n\n# TCP or UNIX socket address for the gRPC server to listen on\n# NOTE: This server only supports /broadcast_tx_commit\ngrpc_laddr = \"{{ .RPC.GRPCListenAddress }}\"\n\n# Maximum number of simultaneous connections.\n# Does not include RPC (HTTP&WebSocket) connections. See max_open_connections\n# If you want to accept a larger number than the default, make sure\n# you increase your OS limits.\n# 0 - unlimited.\n# Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}\n# 1024 - 40 - 10 - 50 = 924 = ~900\ngrpc_max_open_connections = {{ .RPC.GRPCMaxOpenConnections }}\n\n# Activate unsafe RPC commands like /dial_seeds and /unsafe_flush_mempool\nunsafe = {{ .RPC.Unsafe }}\n\n# Maximum number of simultaneous connections (including WebSocket).\n# Does not include gRPC connections. See grpc_max_open_connections\n# If you want to accept a larger number than the default, make sure\n# you increase your OS limits.\n# 0 - unlimited.\n# Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}\n# 1024 - 40 - 10 - 50 = 924 = ~900\nmax_open_connections = {{ .RPC.MaxOpenConnections }}\n\n# Maximum number of unique clientIDs that can /subscribe\n# If you're using /broadcast_tx_commit, set to the estimated maximum number\n# of broadcast_tx_commit calls per block.\nmax_subscription_clients = {{ .RPC.MaxSubscriptionClients }}\n\n# Maximum number of unique queries a given client can /subscribe to\n# If you're using GRPC (or Local RPC client) and /broadcast_tx_commit, set to\n# the estimated # maximum number of broadcast_tx_commit calls per block.\nmax_subscriptions_per_client = {{ .RPC.MaxSubscriptionsPerClient }}\n\n# How long to wait for a tx to be committed during /broadcast_tx_commit.\n# WARNING: Using a value larger than 10s will result in increasing the\n# global HTTP write timeout, which applies to all connections and endpoints.\n# See https://github.com/tendermint/tendermint/issues/3435\ntimeout_broadcast_tx_commit = \"{{ .RPC.TimeoutBroadcastTxCommit }}\"\n\n# Maximum size of request body, in bytes\nmax_body_bytes = {{ .RPC.MaxBodyBytes }}\n\n# Maximum size of request header, in bytes\nmax_header_bytes = {{ .RPC.MaxHeaderBytes }}\n\n# The path to a file containing certificate that is used to create the HTTPS server.\n# Migth be either absolute path or path related to tendermint's config directory.\n# If the certificate is signed by a certificate authority,\n# the certFile should be the concatenation of the server's certificate, any intermediates,\n# and the CA's certificate.\n# NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server.\n# Otherwise, HTTP server is run.\ntls_cert_file = \"{{ .RPC.TLSCertFile }}\"\n\n# The path to a file containing matching private key that is used to create the HTTPS server.\n# Migth be either absolute path or path related to tendermint's config directory.\n# NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server.\n# Otherwise, HTTP server is run.\ntls_key_file = \"{{ .RPC.TLSKeyFile }}\"\n\n# pprof listen address (https://golang.org/pkg/net/http/pprof)\npprof_laddr = \"{{ .RPC.PprofListenAddress }}\"\n\n#######################################################\n###           P2P Configuration Options             ###\n#######################################################\n[p2p]\n\n# Address to listen for incoming connections\nladdr = \"{{ .P2P.ListenAddress }}\"\n\n# Address to advertise to peers for them to dial\n# If empty, will use the same port as the laddr,\n# and will introspect on the listener or use UPnP\n# to figure out the address.\nexternal_address = \"{{ .P2P.ExternalAddress }}\"\n\n# Comma separated list of seed nodes to connect to\nseeds = \"{{ .P2P.Seeds }}\"\n\n# Comma separated list of nodes to keep persistent connections to\npersistent_peers = \"{{ .P2P.PersistentPeers }}\"\n\n# UPNP port forwarding\nupnp = {{ .P2P.UPNP }}\n\n# Path to address book\naddr_book_file = \"{{ js .P2P.AddrBook }}\"\n\n# Set true for strict address routability rules\n# Set false for private or local networks\naddr_book_strict = {{ .P2P.AddrBookStrict }}\n\n# Maximum number of inbound peers\nmax_num_inbound_peers = {{ .P2P.MaxNumInboundPeers }}\n\n# Maximum number of outbound peers to connect to, excluding persistent peers\nmax_num_outbound_peers = {{ .P2P.MaxNumOutboundPeers }}\n\n# List of node IDs, to which a connection will be (re)established ignoring any existing limits\nunconditional_peer_ids = \"{{ .P2P.UnconditionalPeerIDs }}\"\n\n# Maximum pause when redialing a persistent peer (if zero, exponential backoff is used)\npersistent_peers_max_dial_period = \"{{ .P2P.PersistentPeersMaxDialPeriod }}\"\n\n# Time to wait before flushing messages out on the connection\nflush_throttle_timeout = \"{{ .P2P.FlushThrottleTimeout }}\"\n\n# Maximum size of a message packet payload, in bytes\nmax_packet_msg_payload_size = {{ .P2P.MaxPacketMsgPayloadSize }}\n\n# Rate at which packets can be sent, in bytes/second\nsend_rate = {{ .P2P.SendRate }}\n\n# Rate at which packets can be received, in bytes/second\nrecv_rate = {{ .P2P.RecvRate }}\n\n# Set true to enable the peer-exchange reactor\npex = {{ .P2P.PexReactor }}\n\n# Seed mode, in which node constantly crawls the network and looks for\n# peers. If another node asks it for addresses, it responds and disconnects.\n#\n# Does not work if the peer-exchange reactor is disabled.\nseed_mode = {{ .P2P.SeedMode }}\n\n# Comma separated list of peer IDs to keep private (will not be gossiped to other peers)\nprivate_peer_ids = \"{{ .P2P.PrivatePeerIDs }}\"\n\n# Toggle to disable guard against peers connecting from the same ip.\nallow_duplicate_ip = {{ .P2P.AllowDuplicateIP }}\n\n# Peer connection configuration.\nhandshake_timeout = \"{{ .P2P.HandshakeTimeout }}\"\ndial_timeout = \"{{ .P2P.DialTimeout }}\"\n\n#################")