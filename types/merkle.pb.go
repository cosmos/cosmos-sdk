// Code generated by protoc-gen-go. DO NOT EDIT.
// source: merkle.proto

/*
Package types is a generated protocol buffer package.

It is generated from these files:
	merkle.proto

It has these top-level messages:
	Node
	Data
	Branch
	MerkleProof
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HashOp is the hashing algorithm we use at each level
type HashOp int32

const (
	HashOp_RIPEMD160 HashOp = 0
	HashOp_SHA224    HashOp = 1
	HashOp_SHA256    HashOp = 2
	HashOp_SHA384    HashOp = 3
	HashOp_SHA512    HashOp = 4
	HashOp_SHA3_224  HashOp = 5
	HashOp_SHA3_256  HashOp = 6
	HashOp_SHA3_384  HashOp = 7
	HashOp_SHA3_512  HashOp = 8
	HashOp_SHA256_X2 HashOp = 9
)

var HashOp_name = map[int32]string{
	0: "RIPEMD160",
	1: "SHA224",
	2: "SHA256",
	3: "SHA384",
	4: "SHA512",
	5: "SHA3_224",
	6: "SHA3_256",
	7: "SHA3_384",
	8: "SHA3_512",
	9: "SHA256_X2",
}
var HashOp_value = map[string]int32{
	"RIPEMD160": 0,
	"SHA224":    1,
	"SHA256":    2,
	"SHA384":    3,
	"SHA512":    4,
	"SHA3_224":  5,
	"SHA3_256":  6,
	"SHA3_384":  7,
	"SHA3_512":  8,
	"SHA256_X2": 9,
}

func (x HashOp) String() string {
	return proto.EnumName(HashOp_name, int32(x))
}
func (HashOp) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// If it is KeyValue, this is the data we want
// If it is SubTree, key is name of the tree,
//   value is root hash
type Data_DataType int32

const (
	Data_KeyValue Data_DataType = 0
	Data_SubTree  Data_DataType = 1
)

var Data_DataType_name = map[int32]string{
	0: "KeyValue",
	1: "SubTree",
}
var Data_DataType_value = map[string]int32{
	"KeyValue": 0,
	"SubTree":  1,
}

func (x Data_DataType) String() string {
	return proto.EnumName(Data_DataType_name, int32(x))
}
func (Data_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// Op represents one hash in a chain of hashes.
// An operation takes the output of the last level and returns
// a hash for the next level:
// Op(last) => Operation(prefix + last + sufix)
//
// A simple left/right hash would simply set prefix=left or
// suffix=right and leave the other blank. However, one could
// also represent the a Patricia trie proof by setting
// prefix to the rlp encoding of all nodes before the branch
// we select, and suffix to all those after the one we select.
type Node struct {
	Prefix []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Suffix []byte `protobuf:"bytes,2,opt,name=suffix,proto3" json:"suffix,omitempty"`
	Op     HashOp `protobuf:"varint,3,opt,name=op,enum=types.HashOp" json:"op,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Node) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Node) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *Node) GetOp() HashOp {
	if m != nil {
		return m.Op
	}
	return HashOp_RIPEMD160
}

// Data is the end value stored,
// used to generate the initial hash store
type Data struct {
	// optional prefix allows second preimage resistance
	Prefix   []byte        `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Key      []byte        `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value    []byte        `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Op       HashOp        `protobuf:"varint,4,opt,name=op,enum=types.HashOp" json:"op,omitempty"`
	DataType Data_DataType `protobuf:"varint,5,opt,name=dataType,enum=types.Data_DataType" json:"dataType,omitempty"`
}

func (m *Data) Reset()                    { *m = Data{} }
func (m *Data) String() string            { return proto.CompactTextString(m) }
func (*Data) ProtoMessage()               {}
func (*Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Data) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Data) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Data) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Data) GetOp() HashOp {
	if m != nil {
		return m.Op
	}
	return HashOp_RIPEMD160
}

func (m *Data) GetDataType() Data_DataType {
	if m != nil {
		return m.DataType
	}
	return Data_KeyValue
}

// Branch will hash data and then pass it through operations
// from first to last in order to calculate the root node.
//
// Visualize Branch as representing the data closest to
// root as the first item, and the leaf as the last item.
type Branch struct {
	// if either are non-empty, enforce this prefix on all
	// leaf/inner nodes to provide second preimage resistence
	PrefixLeaf  []byte `protobuf:"bytes,1,opt,name=prefixLeaf,proto3" json:"prefixLeaf,omitempty"`
	PrefixInner []byte `protobuf:"bytes,2,opt,name=prefixInner,proto3" json:"prefixInner,omitempty"`
	// this is the data to get the original hash,
	// and a set of operations to calculate the root hash
	Data  *Data   `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	Nodes []*Node `protobuf:"bytes,4,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *Branch) Reset()                    { *m = Branch{} }
func (m *Branch) String() string            { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()               {}
func (*Branch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Branch) GetPrefixLeaf() []byte {
	if m != nil {
		return m.PrefixLeaf
	}
	return nil
}

func (m *Branch) GetPrefixInner() []byte {
	if m != nil {
		return m.PrefixInner
	}
	return nil
}

func (m *Branch) GetData() *Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Branch) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type MerkleProof struct {
	// branches start from the value, and then may
	// include multiple subtree branches to embed it
	//
	// The first branch must have dataType KeyValue
	// Following branches must have dataType SubTree
	Branches []*Branch `protobuf:"bytes,1,rep,name=branches" json:"branches,omitempty"`
}

func (m *MerkleProof) Reset()                    { *m = MerkleProof{} }
func (m *MerkleProof) String() string            { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()               {}
func (*MerkleProof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MerkleProof) GetBranches() []*Branch {
	if m != nil {
		return m.Branches
	}
	return nil
}

func init() {
	proto.RegisterType((*Node)(nil), "types.Node")
	proto.RegisterType((*Data)(nil), "types.Data")
	proto.RegisterType((*Branch)(nil), "types.Branch")
	proto.RegisterType((*MerkleProof)(nil), "types.MerkleProof")
	proto.RegisterEnum("types.HashOp", HashOp_name, HashOp_value)
	proto.RegisterEnum("types.Data_DataType", Data_DataType_name, Data_DataType_value)
}

func init() { proto.RegisterFile("merkle.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x5d, 0xab, 0xd3, 0x40,
	0x10, 0xbd, 0x9b, 0xaf, 0x9b, 0x3b, 0xc9, 0x95, 0x65, 0xb9, 0x48, 0x5e, 0xd4, 0x18, 0x10, 0xae,
	0x3e, 0x94, 0x36, 0xfd, 0xa0, 0xaf, 0x4a, 0x85, 0x16, 0xad, 0x96, 0x6d, 0x15, 0xdf, 0xca, 0xd6,
	0x6e, 0xa8, 0xb4, 0x66, 0x43, 0x92, 0x8a, 0xf9, 0x13, 0xfe, 0x24, 0x7f, 0x9b, 0xec, 0x47, 0x63,
	0x5e, 0xfa, 0x12, 0xe6, 0x9c, 0x99, 0x39, 0x67, 0x66, 0x36, 0x10, 0xfe, 0xe4, 0xe5, 0xf1, 0xc4,
	0x7b, 0x45, 0x29, 0x6a, 0x41, 0xdc, 0xba, 0x29, 0x78, 0x95, 0x7c, 0x01, 0xe7, 0x93, 0xd8, 0x73,
	0xf2, 0x14, 0xbc, 0xa2, 0xe4, 0xd9, 0x8f, 0xdf, 0x11, 0x8a, 0xd1, 0x63, 0x48, 0x0d, 0x92, 0x7c,
	0x75, 0xce, 0x24, 0x6f, 0x69, 0x5e, 0x23, 0xf2, 0x0c, 0x2c, 0x51, 0x44, 0x76, 0x8c, 0x1e, 0x9f,
	0xa4, 0xf7, 0x3d, 0xa5, 0xd5, 0x9b, 0xb3, 0xea, 0xf0, 0xb9, 0xa0, 0x96, 0x28, 0x92, 0xbf, 0x08,
	0x9c, 0x19, 0xab, 0xd9, 0x55, 0x5d, 0x0c, 0xf6, 0x91, 0x37, 0x46, 0x54, 0x86, 0xe4, 0x01, 0xdc,
	0x5f, 0xec, 0x74, 0xe6, 0x4a, 0x34, 0xa4, 0x1a, 0x18, 0x1f, 0xe7, 0x8a, 0x0f, 0xe9, 0x83, 0xbf,
	0x67, 0x35, 0xdb, 0x34, 0x05, 0x8f, 0x5c, 0x55, 0xf4, 0x60, 0x8a, 0xa4, 0xbb, 0xfa, 0xc8, 0x1c,
	0x6d, 0xab, 0x92, 0x57, 0xe0, 0x5f, 0x58, 0x12, 0x82, 0xff, 0x81, 0x37, 0x5f, 0xa5, 0x11, 0xbe,
	0x21, 0x01, 0xdc, 0xae, 0xcf, 0xbb, 0x4d, 0xc9, 0x39, 0x46, 0xc9, 0x1f, 0x04, 0xde, 0xbb, 0x92,
	0xe5, 0xdf, 0x0f, 0xe4, 0x39, 0x80, 0x1e, 0xfa, 0x23, 0x67, 0x99, 0x59, 0xa3, 0xc3, 0x90, 0x18,
	0x02, 0x8d, 0x16, 0x79, 0xce, 0x4b, 0xb3, 0x52, 0x97, 0x22, 0x2f, 0xc0, 0x91, 0xfe, 0x6a, 0xb3,
	0x20, 0x0d, 0x3a, 0x13, 0x52, 0x95, 0x20, 0x2f, 0xc1, 0xcd, 0xc5, 0x9e, 0x57, 0x91, 0x13, 0xdb,
	0x9d, 0x0a, 0xf9, 0x32, 0x54, 0x67, 0x92, 0x29, 0x04, 0x4b, 0xf5, 0x7e, 0xab, 0x52, 0x88, 0x8c,
	0xbc, 0x06, 0x7f, 0xa7, 0xc6, 0xe3, 0x55, 0x84, 0x54, 0xd3, 0xe5, 0x3a, 0x7a, 0x6a, 0xda, 0xa6,
	0xdf, 0xc8, 0x55, 0xf4, 0xc9, 0xc8, 0x3d, 0xdc, 0xd1, 0xc5, 0xea, 0xfd, 0x72, 0x36, 0x98, 0xf4,
	0xf1, 0x0d, 0x01, 0xf0, 0xd6, 0xf3, 0xb7, 0x69, 0x3a, 0xc2, 0xe8, 0x12, 0x8f, 0x27, 0xd8, 0x32,
	0xf1, 0x70, 0x3a, 0xc2, 0xb6, 0x89, 0xc7, 0x83, 0x14, 0x3b, 0xf2, 0x5e, 0x92, 0xdf, 0xca, 0x0e,
	0xf7, 0x3f, 0x1a, 0x4f, 0xb0, 0xd7, 0x22, 0xd9, 0x75, 0xdb, 0x22, 0xd9, 0xe7, 0x4b, 0x5b, 0xad,
	0xbd, 0xfd, 0x96, 0xe2, 0xbb, 0x9d, 0xa7, 0xfe, 0xc0, 0xe1, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xfb, 0x8f, 0x51, 0x66, 0x91, 0x02, 0x00, 0x00,
}
