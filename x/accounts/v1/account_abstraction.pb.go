// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accounts/v1/account_abstraction.proto

package v1

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserOperation defines the type used to define a state transition that
// an account wants to make.
type UserOperation struct {
	// sender defines the account that is sending the UserOperation.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// authentication_method defines the authentication strategy the account wants to use.
	// since accounts can have multiple authentication methods, this field is used to
	// instruct the account on what auth method to use.
	AuthenticationMethod string `protobuf:"bytes,2,opt,name=authentication_method,json=authenticationMethod,proto3" json:"authentication_method,omitempty"`
	// authentication_data defines the authentication data associated with the authentication method.
	// It is the account implementer duty to assess that the UserOperation is properly signed.
	AuthenticationData []byte `protobuf:"bytes,3,opt,name=authentication_data,json=authenticationData,proto3" json:"authentication_data,omitempty"`
	// authentication_gas_limit expresses the gas limit to be used for the authentication part of the
	// UserOperation.
	AuthenticationGasLimit uint64 `protobuf:"varint,4,opt,name=authentication_gas_limit,json=authenticationGasLimit,proto3" json:"authentication_gas_limit,omitempty"`
	// bundler_payment_messages expresses a list of messages that the account
	// executes to pay the bundler for submitting the UserOperation.
	// It can be empty if the bundler does not need any form of payment,
	// the handshake for submitting the UserOperation might have happened off-chain.
	// Bundlers and accounts are free to use any form of payment, in fact the payment can
	// either be empty or be expressed as:
	// - NFT payment
	// - IBC Token payment.
	// - Payment through delegations.
	BundlerPaymentMessages []*types.Any `protobuf:"bytes,5,rep,name=bundler_payment_messages,json=bundlerPaymentMessages,proto3" json:"bundler_payment_messages,omitempty"`
	// bundler_payment_gas_limit defines the gas limit to be used for the bundler payment.
	// This ensures that, since the bundler executes a list of UserOperations and there needs to
	// be minimal trust between bundler and UserOperation sender, the sender cannot consume
	// the whole bundle gas.
	BundlerPaymentGasLimit uint64 `protobuf:"varint,6,opt,name=bundler_payment_gas_limit,json=bundlerPaymentGasLimit,proto3" json:"bundler_payment_gas_limit,omitempty"`
	// execution_messages expresses a list of messages that the account wants to execute.
	// This concretely is the intent of the transaction expressed as a UserOperation.
	ExecutionMessages []*types.Any `protobuf:"bytes,7,rep,name=execution_messages,json=executionMessages,proto3" json:"execution_messages,omitempty"`
	// execution_gas_limit defines the gas limit to be used for the execution of the UserOperation's
	// execution messages.
	ExecutionGasLimit uint64 `protobuf:"varint,8,opt,name=execution_gas_limit,json=executionGasLimit,proto3" json:"execution_gas_limit,omitempty"`
}

func (m *UserOperation) Reset()         { *m = UserOperation{} }
func (m *UserOperation) String() string { return proto.CompactTextString(m) }
func (*UserOperation) ProtoMessage()    {}
func (*UserOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f9bcc910ad46d4b, []int{0}
}
func (m *UserOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOperation.Merge(m, src)
}
func (m *UserOperation) XXX_Size() int {
	return m.Size()
}
func (m *UserOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UserOperation proto.InternalMessageInfo

func (m *UserOperation) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *UserOperation) GetAuthenticationMethod() string {
	if m != nil {
		return m.AuthenticationMethod
	}
	return ""
}

func (m *UserOperation) GetAuthenticationData() []byte {
	if m != nil {
		return m.AuthenticationData
	}
	return nil
}

func (m *UserOperation) GetAuthenticationGasLimit() uint64 {
	if m != nil {
		return m.AuthenticationGasLimit
	}
	return 0
}

func (m *UserOperation) GetBundlerPaymentMessages() []*types.Any {
	if m != nil {
		return m.BundlerPaymentMessages
	}
	return nil
}

func (m *UserOperation) GetBundlerPaymentGasLimit() uint64 {
	if m != nil {
		return m.BundlerPaymentGasLimit
	}
	return 0
}

func (m *UserOperation) GetExecutionMessages() []*types.Any {
	if m != nil {
		return m.ExecutionMessages
	}
	return nil
}

func (m *UserOperation) GetExecutionGasLimit() uint64 {
	if m != nil {
		return m.ExecutionGasLimit
	}
	return 0
}

// UserOperationResponse defines the response of a UserOperation.
// If the operation fails the error field will be populated.
type UserOperationResponse struct {
	// authentication_gas_used defines the gas used for the authentication part of the UserOperation.
	AuthenticationGasUsed uint64 `protobuf:"varint,1,opt,name=authentication_gas_used,json=authenticationGasUsed,proto3" json:"authentication_gas_used,omitempty"`
	// bundler_payment_gas_used defines the gas used for the bundler payment part of the UserOperation.
	BundlerPaymentGasUsed uint64 `protobuf:"varint,2,opt,name=bundler_payment_gas_used,json=bundlerPaymentGasUsed,proto3" json:"bundler_payment_gas_used,omitempty"`
	// bundler_payment_responses defines the responses of the bundler payment messages.
	// It can be empty if the bundler does not need any form of payment.
	BundlerPaymentResponses []*types.Any `protobuf:"bytes,3,rep,name=bundler_payment_responses,json=bundlerPaymentResponses,proto3" json:"bundler_payment_responses,omitempty"`
	// execution_gas_used defines the gas used for the execution part of the UserOperation.
	ExecutionGasUsed uint64 `protobuf:"varint,4,opt,name=execution_gas_used,json=executionGasUsed,proto3" json:"execution_gas_used,omitempty"`
	// execution_responses defines the responses of the execution messages.
	ExecutionResponses []*types.Any `protobuf:"bytes,5,rep,name=execution_responses,json=executionResponses,proto3" json:"execution_responses,omitempty"`
	// error defines the error that occurred during the execution of the UserOperation.
	// If the error is not empty, the UserOperation failed.
	// Other fields might be populated even if the error is not empty, for example
	// if the operation fails after the authentication step, the authentication_gas_used
	// field will be populated.
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *UserOperationResponse) Reset()         { *m = UserOperationResponse{} }
func (m *UserOperationResponse) String() string { return proto.CompactTextString(m) }
func (*UserOperationResponse) ProtoMessage()    {}
func (*UserOperationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f9bcc910ad46d4b, []int{1}
}
func (m *UserOperationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOperationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOperationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOperationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOperationResponse.Merge(m, src)
}
func (m *UserOperationResponse) XXX_Size() int {
	return m.Size()
}
func (m *UserOperationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOperationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserOperationResponse proto.InternalMessageInfo

func (m *UserOperationResponse) GetAuthenticationGasUsed() uint64 {
	if m != nil {
		return m.AuthenticationGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetBundlerPaymentGasUsed() uint64 {
	if m != nil {
		return m.BundlerPaymentGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetBundlerPaymentResponses() []*types.Any {
	if m != nil {
		return m.BundlerPaymentResponses
	}
	return nil
}

func (m *UserOperationResponse) GetExecutionGasUsed() uint64 {
	if m != nil {
		return m.ExecutionGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetExecutionResponses() []*types.Any {
	if m != nil {
		return m.ExecutionResponses
	}
	return nil
}

func (m *UserOperationResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*UserOperation)(nil), "cosmos.accounts.v1.UserOperation")
	proto.RegisterType((*UserOperationResponse)(nil), "cosmos.accounts.v1.UserOperationResponse")
}

func init() {
	proto.RegisterFile("cosmos/accounts/v1/account_abstraction.proto", fileDescriptor_9f9bcc910ad46d4b)
}

var fileDescriptor_9f9bcc910ad46d4b = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0xe3, 0x24, 0x0d, 0x74, 0x00, 0x09, 0xa6, 0x49, 0xea, 0x76, 0x61, 0x45, 0x5d, 0x65,
	0x51, 0x8d, 0x55, 0x8a, 0xf8, 0x59, 0xf2, 0x27, 0x36, 0x14, 0x2a, 0x4b, 0xdd, 0xb0, 0xb1, 0x26,
	0xf6, 0x25, 0xb5, 0x88, 0x67, 0xa2, 0xb9, 0xe3, 0xaa, 0x79, 0x0b, 0xde, 0x0a, 0x96, 0x5d, 0xb2,
	0x44, 0x89, 0x78, 0x0f, 0x94, 0x19, 0xff, 0xc4, 0x71, 0x95, 0x5d, 0xac, 0x7b, 0xce, 0x3d, 0x27,
	0xdf, 0xcc, 0x90, 0xd3, 0x48, 0x62, 0x2a, 0xd1, 0xe7, 0x51, 0x24, 0x33, 0xa1, 0xd1, 0xbf, 0x39,
	0x2b, 0x7e, 0x87, 0x7c, 0x82, 0x5a, 0xf1, 0x48, 0x27, 0x52, 0xb0, 0xb9, 0x92, 0x5a, 0x52, 0x6a,
	0xd5, 0xac, 0x50, 0xb3, 0x9b, 0xb3, 0xe3, 0xa3, 0xa9, 0x94, 0xd3, 0x19, 0xf8, 0x46, 0x31, 0xc9,
	0xbe, 0xfb, 0x5c, 0x2c, 0xac, 0xfc, 0xe4, 0x57, 0x87, 0x3c, 0xb9, 0x42, 0x50, 0x5f, 0xe7, 0xa0,
	0xf8, 0x7a, 0x0d, 0x1d, 0x92, 0x1e, 0x82, 0x88, 0x41, 0xb9, 0xce, 0xc8, 0x19, 0xef, 0x07, 0xf9,
	0x17, 0x3d, 0x27, 0x03, 0x9e, 0xe9, 0x6b, 0x10, 0x3a, 0x89, 0x8c, 0x32, 0x4c, 0x41, 0x5f, 0xcb,
	0xd8, 0x6d, 0x1b, 0x59, 0xbf, 0x3e, 0xbc, 0x30, 0x33, 0xea, 0x93, 0x83, 0x2d, 0x53, 0xcc, 0x35,
	0x77, 0x3b, 0x23, 0x67, 0xfc, 0x38, 0xa0, 0xf5, 0xd1, 0x07, 0xae, 0x39, 0x7d, 0x4d, 0xdc, 0x2d,
	0xc3, 0x94, 0x63, 0x38, 0x4b, 0xd2, 0x44, 0xbb, 0xdd, 0x91, 0x33, 0xee, 0x06, 0xc3, 0xfa, 0xfc,
	0x13, 0xc7, 0xcf, 0xeb, 0x29, 0xfd, 0x42, 0xdc, 0x49, 0x26, 0xe2, 0x19, 0xa8, 0x70, 0xce, 0x17,
	0x29, 0x08, 0x1d, 0xa6, 0x80, 0xc8, 0xa7, 0x80, 0xee, 0xde, 0xa8, 0x33, 0x7e, 0xf4, 0xbc, 0xcf,
	0x2c, 0x07, 0x56, 0x70, 0x60, 0x6f, 0xc5, 0x22, 0x18, 0xe6, 0xae, 0x4b, 0x6b, 0xba, 0xc8, 0x3d,
	0xf4, 0x0d, 0x39, 0xda, 0xde, 0x57, 0x55, 0xe9, 0xd9, 0x2a, 0x75, 0x6b, 0x59, 0xe5, 0x3d, 0xa1,
	0x70, 0x0b, 0x51, 0x96, 0x53, 0xca, 0x4b, 0x3c, 0xd8, 0x51, 0xe2, 0x59, 0xa9, 0x2f, 0xf3, 0x19,
	0x39, 0xa8, 0x96, 0x54, 0xc9, 0x0f, 0x4d, 0x72, 0xa5, 0x2f, 0x42, 0x4f, 0xfe, 0xb5, 0xc9, 0xa0,
	0x76, 0x92, 0x01, 0xe0, 0x5c, 0x0a, 0x04, 0xfa, 0x92, 0x1c, 0xde, 0xc3, 0x34, 0x43, 0x88, 0xcd,
	0x11, 0x77, 0x83, 0x41, 0x03, 0xe9, 0x15, 0x42, 0x4c, 0x5f, 0x35, 0x89, 0x96, 0xc6, 0xb6, 0x35,
	0x36, 0x00, 0x18, 0xe3, 0x65, 0x13, 0x9d, 0xca, 0xcb, 0xa0, 0xdb, 0xd9, 0x81, 0xe1, 0xb0, 0xbe,
	0xaf, 0xf8, 0x07, 0x48, 0x4f, 0x37, 0x89, 0x96, 0x25, 0xec, 0x85, 0x78, 0xba, 0xc9, 0xc2, 0xe4,
	0x7f, 0xdc, 0x44, 0x57, 0x25, 0xef, 0xba, 0x05, 0xd5, 0xfa, 0x2a, 0xb4, 0x4f, 0xf6, 0x40, 0x29,
	0xa9, 0xcc, 0x69, 0xef, 0x07, 0xf6, 0xe3, 0xdd, 0x8b, 0xdf, 0x4b, 0xcf, 0xb9, 0x5b, 0x7a, 0xce,
	0xdf, 0xa5, 0xe7, 0xfc, 0x5c, 0x79, 0xad, 0xbb, 0x95, 0xd7, 0xfa, 0xb3, 0xf2, 0x5a, 0xdf, 0x8e,
	0xed, 0xd3, 0xc3, 0xf8, 0x07, 0x4b, 0xa4, 0x7f, 0xbb, 0xf9, 0x60, 0x27, 0x3d, 0x93, 0x76, 0xfe,
	0x3f, 0x00, 0x00, 0xff, 0xff, 0xf6, 0xb6, 0x1b, 0x5c, 0xcd, 0x03, 0x00, 0x00,
}

func (m *UserOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutionGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.ExecutionGasLimit))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ExecutionMessages) > 0 {
		for iNdEx := len(m.ExecutionMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.BundlerPaymentGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.BundlerPaymentGasLimit))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BundlerPaymentMessages) > 0 {
		for iNdEx := len(m.BundlerPaymentMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BundlerPaymentMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AuthenticationGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.AuthenticationGasLimit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AuthenticationData) > 0 {
		i -= len(m.AuthenticationData)
		copy(dAtA[i:], m.AuthenticationData)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.AuthenticationData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthenticationMethod) > 0 {
		i -= len(m.AuthenticationMethod)
		copy(dAtA[i:], m.AuthenticationMethod)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.AuthenticationMethod)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOperationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOperationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOperationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExecutionResponses) > 0 {
		for iNdEx := len(m.ExecutionResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ExecutionGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.ExecutionGasUsed))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BundlerPaymentResponses) > 0 {
		for iNdEx := len(m.BundlerPaymentResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BundlerPaymentResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BundlerPaymentGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.BundlerPaymentGasUsed))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthenticationGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.AuthenticationGasUsed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAccountAbstraction(dAtA []byte, offset int, v uint64) int {
	offset -= sovAccountAbstraction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	l = len(m.AuthenticationMethod)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	l = len(m.AuthenticationData)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	if m.AuthenticationGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.AuthenticationGasLimit))
	}
	if len(m.BundlerPaymentMessages) > 0 {
		for _, e := range m.BundlerPaymentMessages {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.BundlerPaymentGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.BundlerPaymentGasLimit))
	}
	if len(m.ExecutionMessages) > 0 {
		for _, e := range m.ExecutionMessages {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.ExecutionGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.ExecutionGasLimit))
	}
	return n
}

func (m *UserOperationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthenticationGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.AuthenticationGasUsed))
	}
	if m.BundlerPaymentGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.BundlerPaymentGasUsed))
	}
	if len(m.BundlerPaymentResponses) > 0 {
		for _, e := range m.BundlerPaymentResponses {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.ExecutionGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.ExecutionGasUsed))
	}
	if len(m.ExecutionResponses) > 0 {
		for _, e := range m.ExecutionResponses {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	return n
}

func sovAccountAbstraction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAccountAbstraction(x uint64) (n int) {
	return sovAccountAbstraction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationData = append(m.AuthenticationData[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthenticationData == nil {
				m.AuthenticationData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationGasLimit", wireType)
			}
			m.AuthenticationGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundlerPaymentMessages = append(m.BundlerPaymentMessages, &types.Any{})
			if err := m.BundlerPaymentMessages[len(m.BundlerPaymentMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentGasLimit", wireType)
			}
			m.BundlerPaymentGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundlerPaymentGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionMessages = append(m.ExecutionMessages, &types.Any{})
			if err := m.ExecutionMessages[len(m.ExecutionMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionGasLimit", wireType)
			}
			m.ExecutionGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccountAbstraction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOperationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOperationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOperationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationGasUsed", wireType)
			}
			m.AuthenticationGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentGasUsed", wireType)
			}
			m.BundlerPaymentGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundlerPaymentGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundlerPaymentResponses = append(m.BundlerPaymentResponses, &types.Any{})
			if err := m.BundlerPaymentResponses[len(m.BundlerPaymentResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionGasUsed", wireType)
			}
			m.ExecutionGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionResponses = append(m.ExecutionResponses, &types.Any{})
			if err := m.ExecutionResponses[len(m.ExecutionResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountAbstraction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccountAbstraction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccountAbstraction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAccountAbstraction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAccountAbstraction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAccountAbstraction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccountAbstraction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAccountAbstraction = fmt.Errorf("proto: unexpected end of group")
)
