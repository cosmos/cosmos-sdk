// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/accounts/v1/account_abstraction.proto

package v1

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserOperation defines the type used to define a state transition that
// an account wants to make.
type UserOperation struct {
	// sender defines the account that is sending the UserOperation.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// authentication_method defines the authentication strategy the account wants to use.
	// since accounts can have multiple authentication methods, this field is used to
	// instruct the account on what auth method to use.
	AuthenticationMethod string `protobuf:"bytes,2,opt,name=authentication_method,json=authenticationMethod,proto3" json:"authentication_method,omitempty"`
	// authentication_data defines the authentication data associated with the authentication method.
	// It is the account implementer duty to assess that the UserOperation is properly signed.
	AuthenticationData *types.Any `protobuf:"bytes,3,opt,name=authentication_data,json=authenticationData,proto3" json:"authentication_data,omitempty"`
	// authentication_gas_limit expresses the gas limit to be used for the authentication part of the
	// UserOperation.
	AuthenticationGasLimit uint64 `protobuf:"varint,4,opt,name=authentication_gas_limit,json=authenticationGasLimit,proto3" json:"authentication_gas_limit,omitempty"`
	// bundler_payment_messages expresses a list of messages that the account
	// executes to pay the bundler for submitting the UserOperation.
	// It can be empty if the bundler does not need any form of payment,
	// the handshake for submitting the UserOperation might have happened off-chain.
	// Bundlers and accounts are free to use any form of payment, in fact the payment can
	// either be empty or be expressed as:
	// - NFT payment
	// - IBC Token payment.
	// - Payment through delegations.
	BundlerPaymentMessages []*types.Any `protobuf:"bytes,5,rep,name=bundler_payment_messages,json=bundlerPaymentMessages,proto3" json:"bundler_payment_messages,omitempty"`
	// bundler_payment_gas_limit defines the gas limit to be used for the bundler payment.
	// This ensures that, since the bundler executes a list of UserOperations and there needs to
	// be minimal trust between bundler and UserOperation sender, the sender cannot consume
	// the whole bundle gas.
	BundlerPaymentGasLimit uint64 `protobuf:"varint,6,opt,name=bundler_payment_gas_limit,json=bundlerPaymentGasLimit,proto3" json:"bundler_payment_gas_limit,omitempty"`
	// execution_messages expresses a list of messages that the account wants to execute.
	// This concretely is the intent of the transaction expressed as a UserOperation.
	ExecutionMessages []*types.Any `protobuf:"bytes,7,rep,name=execution_messages,json=executionMessages,proto3" json:"execution_messages,omitempty"`
	// execution_gas_limit defines the gas limit to be used for the execution of the UserOperation's
	// execution messages.
	ExecutionGasLimit uint64 `protobuf:"varint,8,opt,name=execution_gas_limit,json=executionGasLimit,proto3" json:"execution_gas_limit,omitempty"`
	// tx_compat is populated only when the operation is composed from a raw tx.
	// In fact if a TX comes and the sender of the TX is an abstracted account,
	// we convert the TX into a user operation, and try to authenticate using the
	// x/accounts authenticate method. If a bundler tries to send a UserOperation
	// with a populated tx_compat, the operation will immediately yield a failure.
	TxCompat *TxCompat `protobuf:"bytes,9,opt,name=tx_compat,json=txCompat,proto3" json:"tx_compat,omitempty"`
}

func (m *UserOperation) Reset()         { *m = UserOperation{} }
func (m *UserOperation) String() string { return proto.CompactTextString(m) }
func (*UserOperation) ProtoMessage()    {}
func (*UserOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f9bcc910ad46d4b, []int{0}
}
func (m *UserOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOperation.Merge(m, src)
}
func (m *UserOperation) XXX_Size() int {
	return m.Size()
}
func (m *UserOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UserOperation proto.InternalMessageInfo

func (m *UserOperation) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *UserOperation) GetAuthenticationMethod() string {
	if m != nil {
		return m.AuthenticationMethod
	}
	return ""
}

func (m *UserOperation) GetAuthenticationData() *types.Any {
	if m != nil {
		return m.AuthenticationData
	}
	return nil
}

func (m *UserOperation) GetAuthenticationGasLimit() uint64 {
	if m != nil {
		return m.AuthenticationGasLimit
	}
	return 0
}

func (m *UserOperation) GetBundlerPaymentMessages() []*types.Any {
	if m != nil {
		return m.BundlerPaymentMessages
	}
	return nil
}

func (m *UserOperation) GetBundlerPaymentGasLimit() uint64 {
	if m != nil {
		return m.BundlerPaymentGasLimit
	}
	return 0
}

func (m *UserOperation) GetExecutionMessages() []*types.Any {
	if m != nil {
		return m.ExecutionMessages
	}
	return nil
}

func (m *UserOperation) GetExecutionGasLimit() uint64 {
	if m != nil {
		return m.ExecutionGasLimit
	}
	return 0
}

func (m *UserOperation) GetTxCompat() *TxCompat {
	if m != nil {
		return m.TxCompat
	}
	return nil
}

// TxCompat provides compatibility for x/accounts abstracted account with the cosmos-sdk's Txs.
// In fact TxCompat contains fields coming from the Tx in raw and decoded format. The Raw format
// is mainly needed for proper sig verification.
type TxCompat struct {
	// auth_info_bytes contains the auth info bytes of the tx.
	// Must not be modified.
	AuthInfoBytes []byte `protobuf:"bytes,1,opt,name=auth_info_bytes,json=authInfoBytes,proto3" json:"auth_info_bytes,omitempty"`
	// body_bytes contains the body bytes of the tx.
	// must not be modified.
	BodyBytes []byte `protobuf:"bytes,2,opt,name=body_bytes,json=bodyBytes,proto3" json:"body_bytes,omitempty"`
}

func (m *TxCompat) Reset()         { *m = TxCompat{} }
func (m *TxCompat) String() string { return proto.CompactTextString(m) }
func (*TxCompat) ProtoMessage()    {}
func (*TxCompat) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f9bcc910ad46d4b, []int{1}
}
func (m *TxCompat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxCompat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxCompat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxCompat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxCompat.Merge(m, src)
}
func (m *TxCompat) XXX_Size() int {
	return m.Size()
}
func (m *TxCompat) XXX_DiscardUnknown() {
	xxx_messageInfo_TxCompat.DiscardUnknown(m)
}

var xxx_messageInfo_TxCompat proto.InternalMessageInfo

func (m *TxCompat) GetAuthInfoBytes() []byte {
	if m != nil {
		return m.AuthInfoBytes
	}
	return nil
}

func (m *TxCompat) GetBodyBytes() []byte {
	if m != nil {
		return m.BodyBytes
	}
	return nil
}

// UserOperationResponse defines the response of a UserOperation.
// If the operation fails the error field will be populated.
type UserOperationResponse struct {
	// authentication_gas_used defines the gas used for the authentication part of the UserOperation.
	AuthenticationGasUsed uint64 `protobuf:"varint,1,opt,name=authentication_gas_used,json=authenticationGasUsed,proto3" json:"authentication_gas_used,omitempty"`
	// bundler_payment_gas_used defines the gas used for the bundler payment part of the UserOperation.
	BundlerPaymentGasUsed uint64 `protobuf:"varint,2,opt,name=bundler_payment_gas_used,json=bundlerPaymentGasUsed,proto3" json:"bundler_payment_gas_used,omitempty"`
	// bundler_payment_responses defines the responses of the bundler payment messages.
	// It can be empty if the bundler does not need any form of payment.
	BundlerPaymentResponses []*types.Any `protobuf:"bytes,3,rep,name=bundler_payment_responses,json=bundlerPaymentResponses,proto3" json:"bundler_payment_responses,omitempty"`
	// execution_gas_used defines the gas used for the execution part of the UserOperation.
	ExecutionGasUsed uint64 `protobuf:"varint,4,opt,name=execution_gas_used,json=executionGasUsed,proto3" json:"execution_gas_used,omitempty"`
	// execution_responses defines the responses of the execution messages.
	ExecutionResponses []*types.Any `protobuf:"bytes,5,rep,name=execution_responses,json=executionResponses,proto3" json:"execution_responses,omitempty"`
	// error defines the error that occurred during the execution of the UserOperation.
	// If the error is not empty, the UserOperation failed.
	// Other fields might be populated even if the error is not empty, for example
	// if the operation fails after the authentication step, the authentication_gas_used
	// field will be populated.
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *UserOperationResponse) Reset()         { *m = UserOperationResponse{} }
func (m *UserOperationResponse) String() string { return proto.CompactTextString(m) }
func (*UserOperationResponse) ProtoMessage()    {}
func (*UserOperationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f9bcc910ad46d4b, []int{2}
}
func (m *UserOperationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOperationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOperationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOperationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOperationResponse.Merge(m, src)
}
func (m *UserOperationResponse) XXX_Size() int {
	return m.Size()
}
func (m *UserOperationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOperationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserOperationResponse proto.InternalMessageInfo

func (m *UserOperationResponse) GetAuthenticationGasUsed() uint64 {
	if m != nil {
		return m.AuthenticationGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetBundlerPaymentGasUsed() uint64 {
	if m != nil {
		return m.BundlerPaymentGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetBundlerPaymentResponses() []*types.Any {
	if m != nil {
		return m.BundlerPaymentResponses
	}
	return nil
}

func (m *UserOperationResponse) GetExecutionGasUsed() uint64 {
	if m != nil {
		return m.ExecutionGasUsed
	}
	return 0
}

func (m *UserOperationResponse) GetExecutionResponses() []*types.Any {
	if m != nil {
		return m.ExecutionResponses
	}
	return nil
}

func (m *UserOperationResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*UserOperation)(nil), "cosmos.accounts.v1.UserOperation")
	proto.RegisterType((*TxCompat)(nil), "cosmos.accounts.v1.TxCompat")
	proto.RegisterType((*UserOperationResponse)(nil), "cosmos.accounts.v1.UserOperationResponse")
}

func init() {
	proto.RegisterFile("cosmos/accounts/v1/account_abstraction.proto", fileDescriptor_9f9bcc910ad46d4b)
}

var fileDescriptor_9f9bcc910ad46d4b = []byte{
	// 536 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcf, 0x6f, 0xd3, 0x30,
	0x18, 0x6d, 0xda, 0xae, 0xb4, 0x86, 0x09, 0xf0, 0xda, 0x2e, 0x9b, 0x20, 0xaa, 0x7a, 0x40, 0x3d,
	0x4c, 0x8e, 0xc6, 0x10, 0xb0, 0x23, 0x1b, 0x13, 0x42, 0x62, 0x30, 0x22, 0x76, 0xe1, 0x12, 0x39,
	0x89, 0xdb, 0x45, 0x34, 0x76, 0x64, 0x3b, 0x53, 0xf3, 0x5f, 0x70, 0xe4, 0x4f, 0xe2, 0xb8, 0x23,
	0x47, 0xd4, 0x8a, 0xff, 0x03, 0xc5, 0xf9, 0xd5, 0x34, 0xd0, 0x9b, 0xfd, 0x7d, 0xef, 0x7d, 0xef,
	0xc5, 0xef, 0x53, 0xc0, 0x91, 0xcb, 0x44, 0xc0, 0x84, 0x89, 0x5d, 0x97, 0x45, 0x54, 0x0a, 0xf3,
	0xf6, 0x38, 0x3f, 0xdb, 0xd8, 0x11, 0x92, 0x63, 0x57, 0xfa, 0x8c, 0xa2, 0x90, 0x33, 0xc9, 0x20,
	0x4c, 0xd1, 0x28, 0x47, 0xa3, 0xdb, 0xe3, 0xc3, 0x83, 0x19, 0x63, 0xb3, 0x39, 0x31, 0x15, 0xc2,
	0x89, 0xa6, 0x26, 0xa6, 0x71, 0x0a, 0x1f, 0xff, 0x68, 0x83, 0xdd, 0x6b, 0x41, 0xf8, 0xa7, 0x90,
	0x70, 0x9c, 0x8c, 0x81, 0x43, 0xd0, 0x11, 0x84, 0x7a, 0x84, 0xeb, 0xda, 0x48, 0x9b, 0xf4, 0xac,
	0xec, 0x06, 0x4f, 0xc0, 0x00, 0x47, 0xf2, 0x86, 0x50, 0xe9, 0xbb, 0x0a, 0x69, 0x07, 0x44, 0xde,
	0x30, 0x4f, 0x6f, 0x2a, 0x58, 0xbf, 0xda, 0xbc, 0x54, 0x3d, 0x78, 0x01, 0xf6, 0x36, 0x48, 0x1e,
	0x96, 0x58, 0x6f, 0x8d, 0xb4, 0xc9, 0xfd, 0xe7, 0x7d, 0x94, 0xfa, 0x42, 0xb9, 0x2f, 0xf4, 0x86,
	0xc6, 0x16, 0xac, 0x12, 0xde, 0x62, 0x89, 0xe1, 0x6b, 0xa0, 0x6f, 0x8c, 0x99, 0x61, 0x61, 0xcf,
	0xfd, 0xc0, 0x97, 0x7a, 0x7b, 0xa4, 0x4d, 0xda, 0xd6, 0xb0, 0xda, 0x7f, 0x87, 0xc5, 0x87, 0xa4,
	0x0b, 0x3f, 0x02, 0xdd, 0x89, 0xa8, 0x37, 0x27, 0xdc, 0x0e, 0x71, 0x1c, 0x10, 0x2a, 0xed, 0x80,
	0x08, 0x81, 0x67, 0x44, 0xe8, 0x3b, 0xa3, 0xd6, 0x7f, 0x5d, 0x0c, 0x33, 0xd6, 0x55, 0x4a, 0xba,
	0xcc, 0x38, 0xf0, 0x14, 0x1c, 0x6c, 0xce, 0x2b, 0xad, 0x74, 0x52, 0x2b, 0x55, 0x6a, 0x61, 0xe5,
	0x1c, 0x40, 0xb2, 0x20, 0x6e, 0x94, 0xbd, 0x5d, 0x66, 0xe2, 0xde, 0x16, 0x13, 0x8f, 0x0b, 0x7c,
	0xa1, 0x8f, 0xc0, 0x5e, 0x39, 0xa4, 0x54, 0xee, 0x2a, 0xe5, 0x12, 0x5f, 0x88, 0x9e, 0x82, 0x9e,
	0x5c, 0xd8, 0x2e, 0x0b, 0x42, 0x2c, 0xf5, 0x9e, 0x7a, 0xf6, 0x27, 0xa8, 0xbe, 0x22, 0xe8, 0xcb,
	0xe2, 0x5c, 0x61, 0xac, 0xae, 0xcc, 0x4e, 0xe3, 0xcf, 0xa0, 0x9b, 0x57, 0xe1, 0x33, 0xf0, 0x30,
	0x79, 0x60, 0xdb, 0xa7, 0x53, 0x66, 0x3b, 0xb1, 0x24, 0x42, 0x6d, 0xc7, 0x03, 0x6b, 0x37, 0x29,
	0xbf, 0xa7, 0x53, 0x76, 0x96, 0x14, 0xe1, 0x53, 0x00, 0x1c, 0xe6, 0xc5, 0x19, 0xa4, 0xa9, 0x20,
	0xbd, 0xa4, 0xa2, 0xda, 0xe3, 0x3f, 0x4d, 0x30, 0xa8, 0x6c, 0x9b, 0x45, 0x44, 0xc8, 0xa8, 0x20,
	0xf0, 0x25, 0xd8, 0xff, 0x47, 0xc2, 0x91, 0x20, 0x9e, 0x12, 0x6a, 0x5b, 0x83, 0x5a, 0xc0, 0xd7,
	0x82, 0x78, 0xf0, 0x55, 0x3d, 0xdf, 0x82, 0xd8, 0x4c, 0x89, 0xb5, 0x38, 0x14, 0xf1, 0xaa, 0x1e,
	0x24, 0xcf, 0xcc, 0x08, 0xbd, 0xb5, 0x25, 0x94, 0xfd, 0xea, 0xbc, 0xfc, 0x0b, 0x04, 0x3c, 0x5a,
	0xcf, 0xb7, 0x30, 0x91, 0xae, 0xe7, 0xa3, 0xf5, 0x64, 0x94, 0xfe, 0xc5, 0x7a, 0x90, 0xa5, 0xf2,
	0xb6, 0x9d, 0x2c, 0xc7, 0x97, 0xa2, 0x7d, 0xb0, 0x43, 0x38, 0x67, 0x5c, 0xed, 0x5e, 0xcf, 0x4a,
	0x2f, 0x67, 0x2f, 0x7e, 0x2e, 0x0d, 0xed, 0x6e, 0x69, 0x68, 0xbf, 0x97, 0x86, 0xf6, 0x7d, 0x65,
	0x34, 0xee, 0x56, 0x46, 0xe3, 0xd7, 0xca, 0x68, 0x7c, 0x3d, 0x4c, 0xb3, 0x17, 0xde, 0x37, 0xe4,
	0x33, 0x73, 0xb1, 0xfe, 0x53, 0x71, 0x3a, 0x4a, 0xed, 0xe4, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb2, 0x84, 0x4a, 0x05, 0x71, 0x04, 0x00, 0x00,
}

func (m *UserOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxCompat != nil {
		{
			size, err := m.TxCompat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ExecutionGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.ExecutionGasLimit))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ExecutionMessages) > 0 {
		for iNdEx := len(m.ExecutionMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.BundlerPaymentGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.BundlerPaymentGasLimit))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BundlerPaymentMessages) > 0 {
		for iNdEx := len(m.BundlerPaymentMessages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BundlerPaymentMessages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AuthenticationGasLimit != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.AuthenticationGasLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthenticationData != nil {
		{
			size, err := m.AuthenticationData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthenticationMethod) > 0 {
		i -= len(m.AuthenticationMethod)
		copy(dAtA[i:], m.AuthenticationMethod)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.AuthenticationMethod)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxCompat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCompat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxCompat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BodyBytes) > 0 {
		i -= len(m.BodyBytes)
		copy(dAtA[i:], m.BodyBytes)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.BodyBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AuthInfoBytes) > 0 {
		i -= len(m.AuthInfoBytes)
		copy(dAtA[i:], m.AuthInfoBytes)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.AuthInfoBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOperationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOperationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOperationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExecutionResponses) > 0 {
		for iNdEx := len(m.ExecutionResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ExecutionGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.ExecutionGasUsed))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BundlerPaymentResponses) > 0 {
		for iNdEx := len(m.BundlerPaymentResponses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BundlerPaymentResponses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccountAbstraction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BundlerPaymentGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.BundlerPaymentGasUsed))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthenticationGasUsed != 0 {
		i = encodeVarintAccountAbstraction(dAtA, i, uint64(m.AuthenticationGasUsed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAccountAbstraction(dAtA []byte, offset int, v uint64) int {
	offset -= sovAccountAbstraction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	l = len(m.AuthenticationMethod)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	if m.AuthenticationData != nil {
		l = m.AuthenticationData.Size()
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	if m.AuthenticationGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.AuthenticationGasLimit))
	}
	if len(m.BundlerPaymentMessages) > 0 {
		for _, e := range m.BundlerPaymentMessages {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.BundlerPaymentGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.BundlerPaymentGasLimit))
	}
	if len(m.ExecutionMessages) > 0 {
		for _, e := range m.ExecutionMessages {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.ExecutionGasLimit != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.ExecutionGasLimit))
	}
	if m.TxCompat != nil {
		l = m.TxCompat.Size()
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	return n
}

func (m *TxCompat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthInfoBytes)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	l = len(m.BodyBytes)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	return n
}

func (m *UserOperationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthenticationGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.AuthenticationGasUsed))
	}
	if m.BundlerPaymentGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.BundlerPaymentGasUsed))
	}
	if len(m.BundlerPaymentResponses) > 0 {
		for _, e := range m.BundlerPaymentResponses {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	if m.ExecutionGasUsed != 0 {
		n += 1 + sovAccountAbstraction(uint64(m.ExecutionGasUsed))
	}
	if len(m.ExecutionResponses) > 0 {
		for _, e := range m.ExecutionResponses {
			l = e.Size()
			n += 1 + l + sovAccountAbstraction(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAccountAbstraction(uint64(l))
	}
	return n
}

func sovAccountAbstraction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAccountAbstraction(x uint64) (n int) {
	return sovAccountAbstraction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticationMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticationData == nil {
				m.AuthenticationData = &types.Any{}
			}
			if err := m.AuthenticationData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationGasLimit", wireType)
			}
			m.AuthenticationGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundlerPaymentMessages = append(m.BundlerPaymentMessages, &types.Any{})
			if err := m.BundlerPaymentMessages[len(m.BundlerPaymentMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentGasLimit", wireType)
			}
			m.BundlerPaymentGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundlerPaymentGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionMessages = append(m.ExecutionMessages, &types.Any{})
			if err := m.ExecutionMessages[len(m.ExecutionMessages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionGasLimit", wireType)
			}
			m.ExecutionGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCompat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxCompat == nil {
				m.TxCompat = &TxCompat{}
			}
			if err := m.TxCompat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountAbstraction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCompat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCompat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCompat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthInfoBytes = append(m.AuthInfoBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthInfoBytes == nil {
				m.AuthInfoBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyBytes = append(m.BodyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyBytes == nil {
				m.BodyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountAbstraction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOperationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOperationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOperationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationGasUsed", wireType)
			}
			m.AuthenticationGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthenticationGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentGasUsed", wireType)
			}
			m.BundlerPaymentGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundlerPaymentGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundlerPaymentResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundlerPaymentResponses = append(m.BundlerPaymentResponses, &types.Any{})
			if err := m.BundlerPaymentResponses[len(m.BundlerPaymentResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionGasUsed", wireType)
			}
			m.ExecutionGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionGasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionResponses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionResponses = append(m.ExecutionResponses, &types.Any{})
			if err := m.ExecutionResponses[len(m.ExecutionResponses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountAbstraction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccountAbstraction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccountAbstraction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccountAbstraction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountAbstraction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccountAbstraction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAccountAbstraction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAccountAbstraction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAccountAbstraction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccountAbstraction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAccountAbstraction = fmt.Errorf("proto: unexpected end of group")
)
