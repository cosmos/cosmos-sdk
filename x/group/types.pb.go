// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/group/v1/types.proto

package group

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VoteOption enumerates the valid vote options for a given proposal.
type VoteOption int32

const (
	// VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
	// return an error.
	VOTE_OPTION_UNSPECIFIED VoteOption = 0
	// VOTE_OPTION_YES defines a yes vote option.
	VOTE_OPTION_YES VoteOption = 1
	// VOTE_OPTION_ABSTAIN defines an abstain vote option.
	VOTE_OPTION_ABSTAIN VoteOption = 2
	// VOTE_OPTION_NO defines a no vote option.
	VOTE_OPTION_NO VoteOption = 3
	// VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
	VOTE_OPTION_NO_WITH_VETO VoteOption = 4
)

var VoteOption_name = map[int32]string{
	0: "VOTE_OPTION_UNSPECIFIED",
	1: "VOTE_OPTION_YES",
	2: "VOTE_OPTION_ABSTAIN",
	3: "VOTE_OPTION_NO",
	4: "VOTE_OPTION_NO_WITH_VETO",
}

var VoteOption_value = map[string]int32{
	"VOTE_OPTION_UNSPECIFIED":  0,
	"VOTE_OPTION_YES":          1,
	"VOTE_OPTION_ABSTAIN":      2,
	"VOTE_OPTION_NO":           3,
	"VOTE_OPTION_NO_WITH_VETO": 4,
}

func (x VoteOption) String() string {
	return proto.EnumName(VoteOption_name, int32(x))
}

func (VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{0}
}

// ProposalStatus defines proposal statuses.
type ProposalStatus int32

const (
	// An empty value is invalid and not allowed.
	PROPOSAL_STATUS_UNSPECIFIED ProposalStatus = 0
	// Initial status of a proposal when submitted.
	PROPOSAL_STATUS_SUBMITTED ProposalStatus = 1
	// Final status of a proposal when the final tally is done and the outcome
	// passes the group policy's decision policy.
	PROPOSAL_STATUS_ACCEPTED ProposalStatus = 2
	// Final status of a proposal when the final tally is done and the outcome
	// is rejected by the group policy's decision policy.
	PROPOSAL_STATUS_REJECTED ProposalStatus = 3
	// Final status of a proposal when the group policy is modified before the
	// final tally.
	PROPOSAL_STATUS_ABORTED ProposalStatus = 4
	// A proposal can be withdrawn before the voting start time by the owner.
	// When this happens the final status is Withdrawn.
	PROPOSAL_STATUS_WITHDRAWN ProposalStatus = 5
)

var ProposalStatus_name = map[int32]string{
	0: "PROPOSAL_STATUS_UNSPECIFIED",
	1: "PROPOSAL_STATUS_SUBMITTED",
	2: "PROPOSAL_STATUS_ACCEPTED",
	3: "PROPOSAL_STATUS_REJECTED",
	4: "PROPOSAL_STATUS_ABORTED",
	5: "PROPOSAL_STATUS_WITHDRAWN",
}

var ProposalStatus_value = map[string]int32{
	"PROPOSAL_STATUS_UNSPECIFIED": 0,
	"PROPOSAL_STATUS_SUBMITTED":   1,
	"PROPOSAL_STATUS_ACCEPTED":    2,
	"PROPOSAL_STATUS_REJECTED":    3,
	"PROPOSAL_STATUS_ABORTED":     4,
	"PROPOSAL_STATUS_WITHDRAWN":   5,
}

func (x ProposalStatus) String() string {
	return proto.EnumName(ProposalStatus_name, int32(x))
}

func (ProposalStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{1}
}

// ProposalExecutorResult defines types of proposal executor results.
type ProposalExecutorResult int32

const (
	// An empty value is not allowed.
	PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED ProposalExecutorResult = 0
	// We have not yet run the executor.
	PROPOSAL_EXECUTOR_RESULT_NOT_RUN ProposalExecutorResult = 1
	// The executor was successful and proposed action updated state.
	PROPOSAL_EXECUTOR_RESULT_SUCCESS ProposalExecutorResult = 2
	// The executor returned an error and proposed action didn't update state.
	PROPOSAL_EXECUTOR_RESULT_FAILURE ProposalExecutorResult = 3
)

var ProposalExecutorResult_name = map[int32]string{
	0: "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED",
	1: "PROPOSAL_EXECUTOR_RESULT_NOT_RUN",
	2: "PROPOSAL_EXECUTOR_RESULT_SUCCESS",
	3: "PROPOSAL_EXECUTOR_RESULT_FAILURE",
}

var ProposalExecutorResult_value = map[string]int32{
	"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED": 0,
	"PROPOSAL_EXECUTOR_RESULT_NOT_RUN":     1,
	"PROPOSAL_EXECUTOR_RESULT_SUCCESS":     2,
	"PROPOSAL_EXECUTOR_RESULT_FAILURE":     3,
}

func (x ProposalExecutorResult) String() string {
	return proto.EnumName(ProposalExecutorResult_name, int32(x))
}

func (ProposalExecutorResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{2}
}

// Member represents a group member with an account address,
// non-zero weight, metadata and added_at timestamp.
type Member struct {
	// address is the member's account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// weight is the member's voting weight that should be greater than 0.
	Weight string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// metadata is any arbitrary metadata attached to the member.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// added_at is a timestamp specifying when a member was added.
	AddedAt time.Time `protobuf:"bytes,4,opt,name=added_at,json=addedAt,proto3,stdtime" json:"added_at"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{0}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

func (m *Member) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Member) GetAddedAt() time.Time {
	if m != nil {
		return m.AddedAt
	}
	return time.Time{}
}

// MemberRequest represents a group member to be used in Msg server requests.
// Contrary to `Member`, it doesn't have any `added_at` field
// since this field cannot be set as part of requests.
type MemberRequest struct {
	// address is the member's account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// weight is the member's voting weight that should be greater than 0.
	Weight string `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// metadata is any arbitrary metadata attached to the member.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MemberRequest) Reset()         { *m = MemberRequest{} }
func (m *MemberRequest) String() string { return proto.CompactTextString(m) }
func (*MemberRequest) ProtoMessage()    {}
func (*MemberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{1}
}
func (m *MemberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberRequest.Merge(m, src)
}
func (m *MemberRequest) XXX_Size() int {
	return m.Size()
}
func (m *MemberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MemberRequest proto.InternalMessageInfo

func (m *MemberRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MemberRequest) GetWeight() string {
	if m != nil {
		return m.Weight
	}
	return ""
}

func (m *MemberRequest) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// ThresholdDecisionPolicy is a decision policy where a proposal passes when it
// satisfies the two following conditions:
//  1. The sum of all `YES` voter's weights is greater or equal than the defined
//     `threshold`.
//  2. The voting and execution periods of the proposal respect the parameters
//     given by `windows`.
type ThresholdDecisionPolicy struct {
	// threshold is the minimum weighted sum of `YES` votes that must be met or
	// exceeded for a proposal to succeed.
	Threshold string `protobuf:"bytes,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// windows defines the different windows for voting and execution.
	Windows *DecisionPolicyWindows `protobuf:"bytes,2,opt,name=windows,proto3" json:"windows,omitempty"`
}

func (m *ThresholdDecisionPolicy) Reset()         { *m = ThresholdDecisionPolicy{} }
func (m *ThresholdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*ThresholdDecisionPolicy) ProtoMessage()    {}
func (*ThresholdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{2}
}
func (m *ThresholdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdDecisionPolicy.Merge(m, src)
}
func (m *ThresholdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdDecisionPolicy proto.InternalMessageInfo

func (m *ThresholdDecisionPolicy) GetThreshold() string {
	if m != nil {
		return m.Threshold
	}
	return ""
}

func (m *ThresholdDecisionPolicy) GetWindows() *DecisionPolicyWindows {
	if m != nil {
		return m.Windows
	}
	return nil
}

// PercentageDecisionPolicy is a decision policy where a proposal passes when
// it satisfies the two following conditions:
//  1. The percentage of all `YES` voters' weights out of the total group weight
//     is greater or equal than the given `percentage`.
//  2. The voting and execution periods of the proposal respect the parameters
//     given by `windows`.
type PercentageDecisionPolicy struct {
	// percentage is the minimum percentage of the weighted sum of `YES` votes must
	// meet for a proposal to succeed.
	Percentage string `protobuf:"bytes,1,opt,name=percentage,proto3" json:"percentage,omitempty"`
	// windows defines the different windows for voting and execution.
	Windows *DecisionPolicyWindows `protobuf:"bytes,2,opt,name=windows,proto3" json:"windows,omitempty"`
}

func (m *PercentageDecisionPolicy) Reset()         { *m = PercentageDecisionPolicy{} }
func (m *PercentageDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*PercentageDecisionPolicy) ProtoMessage()    {}
func (*PercentageDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{3}
}
func (m *PercentageDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PercentageDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PercentageDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PercentageDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PercentageDecisionPolicy.Merge(m, src)
}
func (m *PercentageDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PercentageDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PercentageDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PercentageDecisionPolicy proto.InternalMessageInfo

func (m *PercentageDecisionPolicy) GetPercentage() string {
	if m != nil {
		return m.Percentage
	}
	return ""
}

func (m *PercentageDecisionPolicy) GetWindows() *DecisionPolicyWindows {
	if m != nil {
		return m.Windows
	}
	return nil
}

// DecisionPolicyWindows defines the different windows for voting and execution.
type DecisionPolicyWindows struct {
	// voting_period is the duration from submission of a proposal to the end of voting period
	// Within this times votes can be submitted with MsgVote.
	VotingPeriod time.Duration `protobuf:"bytes,1,opt,name=voting_period,json=votingPeriod,proto3,stdduration" json:"voting_period"`
	// min_execution_period is the minimum duration after the proposal submission
	// where members can start sending MsgExec. This means that the window for
	// sending a MsgExec transaction is:
	// `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
	// where max_execution_period is a app-specific config, defined in the keeper.
	// If not set, min_execution_period will default to 0.
	//
	// Please make sure to set a `min_execution_period` that is smaller than
	// `voting_period + max_execution_period`, or else the above execution window
	// is empty, meaning that all proposals created with this decision policy
	// won't be able to be executed.
	MinExecutionPeriod time.Duration `protobuf:"bytes,2,opt,name=min_execution_period,json=minExecutionPeriod,proto3,stdduration" json:"min_execution_period"`
}

func (m *DecisionPolicyWindows) Reset()         { *m = DecisionPolicyWindows{} }
func (m *DecisionPolicyWindows) String() string { return proto.CompactTextString(m) }
func (*DecisionPolicyWindows) ProtoMessage()    {}
func (*DecisionPolicyWindows) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{4}
}
func (m *DecisionPolicyWindows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecisionPolicyWindows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecisionPolicyWindows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecisionPolicyWindows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionPolicyWindows.Merge(m, src)
}
func (m *DecisionPolicyWindows) XXX_Size() int {
	return m.Size()
}
func (m *DecisionPolicyWindows) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionPolicyWindows.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionPolicyWindows proto.InternalMessageInfo

func (m *DecisionPolicyWindows) GetVotingPeriod() time.Duration {
	if m != nil {
		return m.VotingPeriod
	}
	return 0
}

func (m *DecisionPolicyWindows) GetMinExecutionPeriod() time.Duration {
	if m != nil {
		return m.MinExecutionPeriod
	}
	return 0
}

// TallyResult represents the sum of weighted votes for each vote option.
type TallyResult struct {
	// yes_count is the weighted sum of yes votes.
	YesCount string `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3" json:"yes_count,omitempty"`
	// abstain_count is the weighted sum of abstainers.
	AbstainCount string `protobuf:"bytes,2,opt,name=abstain_count,json=abstainCount,proto3" json:"abstain_count,omitempty"`
	// no_count is the weighted sum of no votes.
	NoCount string `protobuf:"bytes,3,opt,name=no_count,json=noCount,proto3" json:"no_count,omitempty"`
	// no_with_veto_count is the weighted sum of veto.
	NoWithVetoCount string `protobuf:"bytes,4,opt,name=no_with_veto_count,json=noWithVetoCount,proto3" json:"no_with_veto_count,omitempty"`
}

func (m *TallyResult) Reset()         { *m = TallyResult{} }
func (m *TallyResult) String() string { return proto.CompactTextString(m) }
func (*TallyResult) ProtoMessage()    {}
func (*TallyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f5bddd15d7a54a9d, []int{5}
}
func (m *TallyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyResult.Merge(m, src)
}
func (m *TallyResult) XXX_Size() int {
	return m.Size()
}
func (m *TallyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyResult.DiscardUnknown(m)
}

var xxx_messageInfo_TallyResult proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cosmos.group.v1.VoteOption", VoteOption_name, VoteOption_value)
	proto.RegisterEnum("cosmos.group.v1.ProposalStatus", ProposalStatus_name, ProposalStatus_value)
	proto.RegisterEnum("cosmos.group.v1.ProposalExecutorResult", ProposalExecutorResult_name, ProposalExecutorResult_value)
	proto.RegisterType((*Member)(nil), "cosmos.group.v1.Member")
	proto.RegisterType((*MemberRequest)(nil), "cosmos.group.v1.MemberRequest")
	proto.RegisterType((*ThresholdDecisionPolicy)(nil), "cosmos.group.v1.ThresholdDecisionPolicy")
	proto.RegisterType((*PercentageDecisionPolicy)(nil), "cosmos.group.v1.PercentageDecisionPolicy")
	proto.RegisterType((*DecisionPolicyWindows)(nil), "cosmos.group.v1.DecisionPolicyWindows")
	proto.RegisterType((*TallyResult)(nil), "cosmos.group.v1.TallyResult")
}

func init() { proto.RegisterFile("cosmos/group/v1/types.proto", fileDescriptor_f5bddd15d7a54a9d) }

var fileDescriptor_f5bddd15d7a54a9d = []byte{
	// 883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0xcf, 0x6f, 0xdb, 0x64,
	0x18, 0xc7, 0xf3, 0xa6, 0xa1, 0x3f, 0x9e, 0xae, 0xab, 0x79, 0x57, 0xd6, 0x34, 0x1d, 0x4e, 0x95,
	0x55, 0xa8, 0x2a, 0x6a, 0xac, 0x95, 0xdb, 0x0e, 0x08, 0x27, 0xf1, 0x44, 0xa6, 0x36, 0xb6, 0x6c,
	0xa7, 0x85, 0x5d, 0x2c, 0x27, 0x7e, 0x71, 0x2c, 0x62, 0xbf, 0xc1, 0x7e, 0xdd, 0x2c, 0xff, 0xc1,
	0xc4, 0x85, 0x1d, 0xb9, 0x20, 0x21, 0x71, 0xe1, 0xb8, 0xc3, 0xc4, 0x81, 0x23, 0xe2, 0x50, 0x71,
	0x40, 0x13, 0x27, 0x4e, 0x80, 0xda, 0xc3, 0xfe, 0x0d, 0x64, 0xbf, 0x76, 0xc9, 0xb2, 0xb6, 0x02,
	0x09, 0xed, 0x12, 0xe5, 0x7d, 0x3e, 0xdf, 0xe7, 0xc7, 0xd7, 0x7e, 0x5e, 0x19, 0x36, 0xfb, 0x34,
	0xf2, 0x69, 0x24, 0xb9, 0x21, 0x8d, 0x47, 0xd2, 0xc9, 0x3d, 0x89, 0x4d, 0x46, 0x24, 0xaa, 0x8f,
	0x42, 0xca, 0x28, 0x5e, 0xe5, 0xb0, 0x9e, 0xc2, 0xfa, 0xc9, 0xbd, 0xca, 0x9a, 0x4b, 0x5d, 0x9a,
	0x32, 0x29, 0xf9, 0xc7, 0x65, 0x15, 0xd1, 0xa5, 0xd4, 0x1d, 0x12, 0x29, 0x3d, 0xf5, 0xe2, 0xcf,
	0x24, 0x27, 0x0e, 0x6d, 0xe6, 0xd1, 0x20, 0xe3, 0xd5, 0x59, 0xce, 0x3c, 0x9f, 0x44, 0xcc, 0xf6,
	0x47, 0x99, 0x60, 0x83, 0xf7, 0xb1, 0x78, 0xe5, 0xac, 0x29, 0x47, 0x6f, 0xdb, 0xbe, 0x17, 0x50,
	0x29, 0xfd, 0xe5, 0xa1, 0xda, 0x0f, 0x08, 0xe6, 0x0f, 0x89, 0xdf, 0x23, 0x21, 0xde, 0x87, 0x05,
	0xdb, 0x71, 0x42, 0x12, 0x45, 0x65, 0xb4, 0x85, 0x76, 0x96, 0x1a, 0xe5, 0xdf, 0x9e, 0xef, 0xad,
	0x65, 0x05, 0x64, 0x4e, 0x0c, 0x16, 0x7a, 0x81, 0xab, 0xe7, 0x42, 0x7c, 0x1b, 0xe6, 0xc7, 0xc4,
	0x73, 0x07, 0xac, 0x5c, 0x4c, 0x52, 0xf4, 0xec, 0x84, 0x2b, 0xb0, 0xe8, 0x13, 0x66, 0x3b, 0x36,
	0xb3, 0xcb, 0x73, 0x29, 0xb9, 0x38, 0xe3, 0x16, 0x2c, 0xda, 0x8e, 0x43, 0x1c, 0xcb, 0x66, 0xe5,
	0xd2, 0x16, 0xda, 0x59, 0xde, 0xaf, 0xd4, 0xb9, 0xa9, 0x7a, 0x6e, 0xaa, 0x6e, 0xe6, 0xa6, 0x1a,
	0x2b, 0xa7, 0x7f, 0x54, 0x0b, 0x4f, 0xff, 0xac, 0xa2, 0xef, 0x5f, 0x3e, 0xdb, 0x45, 0x69, 0x67,
	0xe2, 0xc8, 0xac, 0x36, 0x86, 0x15, 0x3e, 0xb7, 0x4e, 0xbe, 0x88, 0x49, 0xc4, 0xde, 0xd4, 0xf8,
	0xb5, 0x9f, 0x11, 0xac, 0x9b, 0x83, 0x90, 0x44, 0x03, 0x3a, 0x74, 0x5a, 0xa4, 0xef, 0x45, 0x1e,
	0x0d, 0x34, 0x3a, 0xf4, 0xfa, 0x13, 0x7c, 0x07, 0x96, 0x58, 0x8e, 0xf8, 0x14, 0xfa, 0x3f, 0x01,
	0xfc, 0x11, 0x2c, 0x8c, 0xbd, 0xc0, 0xa1, 0xe3, 0x28, 0x6d, 0xb7, 0xbc, 0xff, 0x5e, 0x7d, 0x66,
	0x27, 0xea, 0xaf, 0xd6, 0x3b, 0xe6, 0x6a, 0x3d, 0x4f, 0xbb, 0xdf, 0xfe, 0xe5, 0xf9, 0x9e, 0x78,
	0x7d, 0xce, 0x97, 0x2f, 0x9f, 0xed, 0xd6, 0xb8, 0x64, 0x2f, 0x72, 0x3e, 0x97, 0xae, 0x18, 0xb5,
	0x76, 0x8a, 0xa0, 0xac, 0x91, 0xb0, 0x4f, 0x02, 0x66, 0xbb, 0x64, 0xc6, 0x87, 0x08, 0x30, 0xba,
	0x60, 0x99, 0x91, 0xa9, 0xc8, 0xff, 0xe0, 0xe4, 0xe1, 0xbf, 0x73, 0x72, 0x77, 0xca, 0xc9, 0x55,
	0xd3, 0xd6, 0x7e, 0x42, 0xf0, 0xce, 0xa5, 0xed, 0xf0, 0x21, 0xac, 0x9c, 0x50, 0xe6, 0x05, 0xae,
	0x35, 0x22, 0xa1, 0x47, 0xf9, 0x3b, 0x59, 0xde, 0xdf, 0x78, 0x6d, 0xdf, 0x5a, 0xd9, 0x25, 0xe3,
	0xeb, 0xf6, 0xf5, 0xc5, 0xba, 0xdd, 0xe0, 0xe9, 0x5a, 0x9a, 0x8d, 0x1f, 0xc1, 0x9a, 0xef, 0x05,
	0x16, 0x79, 0x4c, 0xfa, 0x71, 0xa2, 0xce, 0xab, 0x16, 0xff, 0x63, 0x55, 0xec, 0x7b, 0x81, 0x92,
	0x17, 0xe1, 0xb5, 0x6b, 0xdf, 0x20, 0x58, 0x36, 0xed, 0xe1, 0x70, 0xa2, 0x93, 0x28, 0x1e, 0x32,
	0xbc, 0x09, 0x4b, 0x13, 0x12, 0x59, 0x7d, 0x1a, 0x07, 0x2c, 0x7b, 0x03, 0x8b, 0x13, 0x12, 0x35,
	0x93, 0x33, 0xbe, 0x0b, 0x2b, 0x76, 0x2f, 0x62, 0xb6, 0x17, 0x64, 0x02, 0xbe, 0xbe, 0x37, 0xb2,
	0x20, 0x17, 0x6d, 0xc0, 0x62, 0x40, 0x33, 0xce, 0x97, 0x78, 0x21, 0xa0, 0x1c, 0xbd, 0x0f, 0x38,
	0xa0, 0xd6, 0xd8, 0x63, 0x03, 0xeb, 0x84, 0xb0, 0x5c, 0x54, 0x4a, 0x45, 0xab, 0x01, 0x3d, 0xf6,
	0xd8, 0xe0, 0x88, 0x30, 0x2e, 0xbe, 0x5f, 0x7a, 0xf2, 0x6d, 0xb5, 0xb0, 0xfb, 0x15, 0x02, 0x38,
	0xa2, 0x8c, 0xa8, 0xa3, 0x64, 0x68, 0xbc, 0x09, 0xeb, 0x47, 0xaa, 0xa9, 0x58, 0xaa, 0x66, 0xb6,
	0xd5, 0x8e, 0xd5, 0xed, 0x18, 0x9a, 0xd2, 0x6c, 0x3f, 0x68, 0x2b, 0x2d, 0xa1, 0x80, 0x6f, 0xc1,
	0xea, 0x34, 0xfc, 0x54, 0x31, 0x04, 0x84, 0xd7, 0xe1, 0xd6, 0x74, 0x50, 0x6e, 0x18, 0xa6, 0xdc,
	0xee, 0x08, 0x45, 0x8c, 0xe1, 0xe6, 0x34, 0xe8, 0xa8, 0xc2, 0x1c, 0xbe, 0x03, 0xe5, 0x57, 0x63,
	0xd6, 0x71, 0xdb, 0xfc, 0xd8, 0x3a, 0x52, 0x4c, 0x55, 0x28, 0x55, 0x4a, 0x4f, 0xbe, 0x13, 0x0b,
	0xbb, 0xbf, 0x22, 0xb8, 0xa9, 0x85, 0x74, 0x44, 0x23, 0x7b, 0x68, 0x30, 0x9b, 0xc5, 0x11, 0xae,
	0xc2, 0xa6, 0xa6, 0xab, 0x9a, 0x6a, 0xc8, 0x07, 0x96, 0x61, 0xca, 0x66, 0xd7, 0x98, 0x99, 0xec,
	0x5d, 0xd8, 0x98, 0x15, 0x18, 0xdd, 0xc6, 0x61, 0xdb, 0x34, 0x95, 0x96, 0x80, 0x92, 0xb6, 0xb3,
	0x58, 0x6e, 0x36, 0x15, 0x2d, 0xa1, 0xc5, 0xcb, 0xa8, 0xae, 0x3c, 0x54, 0x9a, 0x09, 0x9d, 0x4b,
	0x9e, 0xc8, 0x6b, 0xb9, 0x0d, 0x55, 0x4f, 0x60, 0xe9, 0xb2, 0xbe, 0x89, 0xa1, 0x96, 0x2e, 0x1f,
	0x77, 0x84, 0xb7, 0x32, 0x43, 0x3f, 0x22, 0xb8, 0x9d, 0x1b, 0xe2, 0xeb, 0x41, 0xc3, 0x6c, 0x1b,
	0x76, 0x60, 0xfb, 0x22, 0x5f, 0xf9, 0x44, 0x69, 0x76, 0x4d, 0x55, 0xb7, 0x74, 0xc5, 0xe8, 0x1e,
	0x98, 0x33, 0x0e, 0xb7, 0x61, 0xeb, 0x4a, 0x65, 0x47, 0x35, 0x2d, 0xbd, 0xdb, 0x11, 0xd0, 0xb5,
	0x2a, 0xa3, 0xdb, 0x6c, 0x2a, 0x86, 0x21, 0x14, 0xaf, 0x55, 0x3d, 0x90, 0xdb, 0x07, 0x5d, 0x5d,
	0x11, 0xe6, 0xf8, 0xf0, 0x8d, 0x0f, 0x4f, 0xcf, 0x44, 0xf4, 0xe2, 0x4c, 0x44, 0x7f, 0x9d, 0x89,
	0xe8, 0xe9, 0xb9, 0x58, 0x78, 0x71, 0x2e, 0x16, 0x7e, 0x3f, 0x17, 0x0b, 0x8f, 0xb6, 0x5d, 0x8f,
	0x0d, 0xe2, 0x5e, 0xbd, 0x4f, 0xfd, 0xec, 0x73, 0x24, 0x4d, 0xdd, 0xea, 0xc7, 0xfc, 0x6b, 0xd9,
	0x9b, 0x4f, 0x6f, 0xcd, 0x07, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xbc, 0xb2, 0x33, 0xf4, 0x44,
	0x07, 0x00, 0x00,
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.AddedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AddedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x22
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Weight) > 0 {
		i -= len(m.Weight)
		copy(dAtA[i:], m.Weight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Weight)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		{
			size, err := m.Windows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Threshold) > 0 {
		i -= len(m.Threshold)
		copy(dAtA[i:], m.Threshold)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Threshold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PercentageDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PercentageDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PercentageDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		{
			size, err := m.Windows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Percentage) > 0 {
		i -= len(m.Percentage)
		copy(dAtA[i:], m.Percentage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Percentage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecisionPolicyWindows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionPolicyWindows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecisionPolicyWindows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.MinExecutionPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinExecutionPeriod):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTypes(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x12
	n5, err5 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.VotingPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VotingPeriod):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintTypes(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TallyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NoWithVetoCount) > 0 {
		i -= len(m.NoWithVetoCount)
		copy(dAtA[i:], m.NoWithVetoCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NoWithVetoCount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NoCount) > 0 {
		i -= len(m.NoCount)
		copy(dAtA[i:], m.NoCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NoCount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AbstainCount) > 0 {
		i -= len(m.AbstainCount)
		copy(dAtA[i:], m.AbstainCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AbstainCount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.YesCount) > 0 {
		i -= len(m.YesCount)
		copy(dAtA[i:], m.YesCount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.YesCount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AddedAt)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *MemberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Weight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ThresholdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Threshold)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PercentageDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Percentage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DecisionPolicyWindows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.VotingPeriod)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.MinExecutionPeriod)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *TallyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.YesCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AbstainCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NoCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NoWithVetoCount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.AddedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &DecisionPolicyWindows{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PercentageDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PercentageDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PercentageDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Percentage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &DecisionPolicyWindows{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionPolicyWindows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionPolicyWindows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionPolicyWindows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.VotingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinExecutionPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.MinExecutionPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YesCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbstainCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWithVetoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoWithVetoCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
