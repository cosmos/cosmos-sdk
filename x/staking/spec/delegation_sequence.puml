@startuml
'https://plantuml.com/sequence-diagram

title: Delegating (currently undelegated funds delegator)
autonumber

participant "msgServer (staking)"
participant  "keeper (staking)" as keeper
"msgServer (staking)" -> keeper : Delegate(Context, DelegatorAddress, Amount, Validator, tokenSrc := Unbonded)

alt exchange rate is invalid (tokens in validator is 0)
    keeper -->  "msgServer (staking)" : error
end

alt perform a new delegation
    keeper -> keeper : delegation := create delegation object
end

alt new delegation
    keeper -> keeper : BeforeDelegationCreated hook
    note left: Calls IncrementValidatorPeriod (Used to calculate distribution) in keeper/validator.go
end
alt delegation exists, more tokens being added
    keeper -> keeper : BeforeDelegationModified hook
    note left: withdraw current delegation rewards (and increment period)
end

alt delegating from an account (subtractTokens == true)
    alt validator is currently bonded
        keeper -> keeper : sendName := BondedPool
    end
    alt validator is currently bonded
        keeper -> keeper : sendName := NotBondedPool
    end

keeper -> keeper.bankKeeper : DelegateCoinsFromAccountToModule
keeper.bankKeeper -> "func:DelegateCoinsFromAccountToModule" as DelegateCoinsFromAccountToModule **
DelegateCoinsFromAccountToModule -->  DelegateCoinsFromAccountToModule  : Check recipient has permission to stake
DelegateCoinsFromAccountToModule ->  "func:DelegateCoins" as DelegateCoins **
DelegateCoins --> DelegateCoins : Check the delegator has enough balances of all tokens delegated
DelegateCoins --> DelegateCoins : Track delegation (register that it exists to keep track of it)
DelegateCoins --> store : Transfer tokens to staker.
DelegateCoins --> DelegateCoinsFromAccountToModule : nil
destroy DelegateCoins
keeper.bankKeeper <-- DelegateCoinsFromAccountToModule: nil
destroy DelegateCoinsFromAccountToModule
keeper <-- keeper.bankKeeper : nil (success)
keeper -> validator : AddTokensFromDel
validator -> validator : calculate number of shares to issue
note left: If there are no shares (validator being created) then 1 token = 1 share.\nIf there are already shares, then\nadded shares =  (added tokens amount) * (current validator shares) / (current validator tokens)

'TODO: Find right keyword.
database store

validator -> validator : add delegated tokens to validator
keeper <-- validator : validator, addedShares
keeper -> store : update validator state
keeper -> keeper: calculate new validator's power
note left : Number of tokens divided by PowerReduction (default: 1,000,000,000,000,000,000 = 10^18)
keeper -> store : update validator's power in power index
note left : the power index has entries shaped as 35 || power || address.\nThis makes the validators sorted by power, high to low.
end

keeper -> keeper : AfterDelegationModified hook
note left: Calls initializeDelegation\nStore the previous period\nCalculate the number of tokens from shares\n(shares the delegator has) * (tokens in delegation object)/(total tokens delegated to the validator)\nStore delegation starting info.
"msgServer (staking)" <-- keeper : newShares (ignored by Delegate function)


"msgServer (staking)" -> "msgServer (staking)" : Emit event: Delegation(ValidatorAddress)
"msgServer (staking)" -> "msgServer (staking)" : Emit event: Message(DelegatorAddress)
"msgServer (staking)" -> "msgServer (staking)" : telemetry(Amount, Denom)
"handler (staking)" <-- "msgServer (staking)" : res := MsgDelegateResponse{}\n(empty struct)
SDK <-- "handler (staking)": return (Context, res, err)

@enduml

