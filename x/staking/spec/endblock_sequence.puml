@startuml
'https://plantuml.com/sequence-diagram

title: EndBlock\nAt this point the

participant keeper
participant keeper.bankKeeper
participant ctx.EventManager
database store

keeper -> keeper : BlockValidatorUpdates
group BlockValidatorUpdates
    note left : returns `updates`, a list of `abci.ValidatorUpdate`s
    keeper -> keeper : ApplyAndReturnValidatorSetUpdates
    group ApplyAndReturnValidatorSetUpdates
        keeper -> store : get the validators the set of validators for the beginning of the current block and their power.
        keeper <-- store : `last`
        keeper -> store : get the validators sorted by their current power (possibly updated in the block), highest to least.
        keeper <-- store : `iterator`
        loop for the first `maxValidators` validators in `iterator`
        'If there are less than `maxValidators`, then jut loop over all of them.
        '`maxValidators` is just an upper bound.
            alt validator is unbonded or unbonding
                keeper -> keeper : bondValidator(validator)
                note left : unbonded and unbonding treated as separate cases in the code,\nbut both just call bondValidator
                group bondValidator
                    keeper -> keeper
                    'TODO describe bondValidator state updates x/staking/keeper/val_state_change.go:284
                end
            end
            alt if validator power has changed
                keeper -> store : update validator's power in power index (add it if not already present)
                keeper -> keeper : append validator and its new power to `updates`
            end
            keeper -> keeper : delete validator from `last` map
        end
        'After loop: totalPower = amount of power of the new validator set
        '            amtFromNotBondedToBonded = number of previously not bonded tokens now bonded
        '            amtFromBondedToNotBonded = 0
        '            last = all validators at the beginning of the block
        keeper -> keeper : noLongerBonded := `last` sorted by address
        note left : `last` now contains exactly the validators of the current block\nthat will not be validators in the next block.
        loop for validator in noLongerBonded
            keeper -> keeper : bondedToUnbonding(validator)
            keeper -> store : delete validator from power index
            keeper -> keeper : append validator and its new power (0) to `updates`
        end
        'After loop: amtFromBondedToNotBonded = number of previously bonded tokens now not bonded
        alt newly bonded tokens > newly not bonded tokens
            keeper -> keeper.bankKeeper : sendCoinsFromModuleToModule(NotBondedPool, BondedPool, diff)
        else newly bonded tokens < newly not bonded tokens
            keeper -> keeper.bankKeeper : sendCoinsFromModuleToModule(BondedPool, NotBondedPool, diff)
        else both equal
        end
        keeper.bankKeeper -> store : transfer coins between modules
        keeper.bankKeeper -> ctx.EventManager : emit TransferEvent(from, to, amount)
        keeper.bankKeeper --> keeper
        alt if there has been any updates to the validator set or the powers
            keeper -> store : update LastTotalPower
        end
    end
    keeper -> keeper : UnbondAllMatureValidators
    group UnbondAllMatureValidators
        keeper -> store : get ValidatorQueue up to current block height and time
        keeper <-- store : `iterator`
        loop for `validator` in `iterator` which are ready to unbond
            keeper -> keeper : UnbondingToUnbonded(validator)
            group UnbondingToUnbonded
                keeper -> keeper : update validator object status
                keeper -> store : set validator in storage
            end
            alt validator has zero shares (no active delegation)
                keeper -> store : remove validator from key index
                keeper -> store : remove validator from cons address index
                keeper -> store : remove validator from power index
                keeper -> keeper : AfterValidatorRemoved hook
            end
        end
        loop for mature `delegation` in UnbondingQueue
            keeper -> store : delete `delegation` from unbonding queue
            keeper -> keeper : append `delegation` to `matureBonds`
        end
        loop for `delegation` in `matureBonds`
            keeper -> keeper : CompleteUnbonding(delegation)
            'TODO what happens in CompleteUnbonding?
            keeper -> ctx.EventManager : EventTypeCompleteUnbonding(amount, validator, delegator)
        end

        loop for mature `redelegation` in RedelegationQueue
            keeper -> store : delete `redelegation` from redelegation queue
            keeper -> keeper : append `redelegation` to `matureRedelegations`
        end
        loop for `redelegation` in `matureRedelegations`
            keeper -> keeper : CompleteRedelegation(redelegation)
            'TODO what happens in CompleteRedelegation?
            keeper -> ctx.EventManager : EventTypeCompleteRedelegation(amount, delegator, src_validator, dst_validator)
        end

    end

end

@enduml
